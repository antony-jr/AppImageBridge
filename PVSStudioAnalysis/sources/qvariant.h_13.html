
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qvariant.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Contact: https://www.qt.io/licensing/</a>
<a name="ln5">**</a>
<a name="ln6">** This file is part of the QtCore module of the Qt Toolkit.</a>
<a name="ln7">**</a>
<a name="ln8">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln9">** Commercial License Usage</a>
<a name="ln10">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln11">** accordance with the commercial license agreement provided with the</a>
<a name="ln12">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln13">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln14">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln15">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln16">**</a>
<a name="ln17">** GNU Lesser General Public License Usage</a>
<a name="ln18">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln19">** General Public License version 3 as published by the Free Software</a>
<a name="ln20">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln21">** packaging of this file. Please review the following information to</a>
<a name="ln22">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln23">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln24">**</a>
<a name="ln25">** GNU General Public License Usage</a>
<a name="ln26">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln27">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln28">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln29">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln30">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln31">** included in the packaging of this file. Please review the following</a>
<a name="ln32">** information to ensure the GNU General Public License requirements will</a>
<a name="ln33">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln34">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln35">**</a>
<a name="ln36">** $QT_END_LICENSE$</a>
<a name="ln37">**</a>
<a name="ln38">****************************************************************************/</a>
<a name="ln39"> </a>
<a name="ln40">#ifndef QVARIANT_H</a>
<a name="ln41">#define QVARIANT_H</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;QtCore/qatomic.h&gt;</a>
<a name="ln44">#include &lt;QtCore/qbytearray.h&gt;</a>
<a name="ln45">#include &lt;QtCore/qlist.h&gt;</a>
<a name="ln46">#include &lt;QtCore/qmetatype.h&gt;</a>
<a name="ln47">#include &lt;QtCore/qmap.h&gt;</a>
<a name="ln48">#include &lt;QtCore/qhash.h&gt;</a>
<a name="ln49">#include &lt;QtCore/qstring.h&gt;</a>
<a name="ln50">#include &lt;QtCore/qstringlist.h&gt;</a>
<a name="ln51">#include &lt;QtCore/qobject.h&gt;</a>
<a name="ln52">#ifndef QT_BOOTSTRAPPED</a>
<a name="ln53">#include &lt;QtCore/qbytearraylist.h&gt;</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#if QT_HAS_INCLUDE(&lt;variant&gt;) &amp;&amp; __cplusplus &gt;= 201703L</a>
<a name="ln57">#include &lt;variant&gt;</a>
<a name="ln58">#endif</a>
<a name="ln59"> </a>
<a name="ln60">QT_BEGIN_NAMESPACE</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">class QBitArray;</a>
<a name="ln64">class QDataStream;</a>
<a name="ln65">class QDate;</a>
<a name="ln66">class QDateTime;</a>
<a name="ln67">class QEasingCurve;</a>
<a name="ln68">class QLine;</a>
<a name="ln69">class QLineF;</a>
<a name="ln70">class QLocale;</a>
<a name="ln71">class QMatrix;</a>
<a name="ln72">class QTransform;</a>
<a name="ln73">class QStringList;</a>
<a name="ln74">class QTime;</a>
<a name="ln75">class QPoint;</a>
<a name="ln76">class QPointF;</a>
<a name="ln77">class QSize;</a>
<a name="ln78">class QSizeF;</a>
<a name="ln79">class QRect;</a>
<a name="ln80">class QRectF;</a>
<a name="ln81">#ifndef QT_NO_REGEXP</a>
<a name="ln82">class QRegExp;</a>
<a name="ln83">#endif // QT_NO_REGEXP</a>
<a name="ln84">#if QT_CONFIG(regularexpression)</a>
<a name="ln85">class QRegularExpression;</a>
<a name="ln86">#endif // QT_CONFIG(regularexpression)</a>
<a name="ln87">class QTextFormat;</a>
<a name="ln88">class QTextLength;</a>
<a name="ln89">class QUrl;</a>
<a name="ln90">class QVariant;</a>
<a name="ln91">class QVariantComparisonHelper;</a>
<a name="ln92"> </a>
<a name="ln93">template &lt;typename T&gt;</a>
<a name="ln94">inline QVariant qVariantFromValue(const T &amp;);</a>
<a name="ln95"> </a>
<a name="ln96">template&lt;typename T&gt;</a>
<a name="ln97">inline T qvariant_cast(const QVariant &amp;);</a>
<a name="ln98"> </a>
<a name="ln99">namespace QtPrivate {</a>
<a name="ln100"> </a>
<a name="ln101">    template &lt;typename Derived, typename Argument, typename ReturnType&gt;</a>
<a name="ln102">    struct ObjectInvoker</a>
<a name="ln103">    {</a>
<a name="ln104">        static ReturnType invoke(Argument a)</a>
<a name="ln105">        {</a>
<a name="ln106">            return Derived::object(a);</a>
<a name="ln107">        }</a>
<a name="ln108">    };</a>
<a name="ln109"> </a>
<a name="ln110">    template &lt;typename Derived, typename Argument, typename ReturnType&gt;</a>
<a name="ln111">    struct MetaTypeInvoker</a>
<a name="ln112">    {</a>
<a name="ln113">        static ReturnType invoke(Argument a)</a>
<a name="ln114">        {</a>
<a name="ln115">            return Derived::metaType(a);</a>
<a name="ln116">        }</a>
<a name="ln117">    };</a>
<a name="ln118"> </a>
<a name="ln119">    template &lt;typename Derived, typename T, typename Argument, typename ReturnType, bool = IsPointerToTypeDerivedFromQObject&lt;T&gt;::Value&gt;</a>
<a name="ln120">    struct TreatAsQObjectBeforeMetaType : ObjectInvoker&lt;Derived, Argument, ReturnType&gt;</a>
<a name="ln121">    {</a>
<a name="ln122">    };</a>
<a name="ln123"> </a>
<a name="ln124">    template &lt;typename Derived, typename T, typename Argument, typename ReturnType&gt;</a>
<a name="ln125">    struct TreatAsQObjectBeforeMetaType&lt;Derived, T, Argument, ReturnType, false&gt; : MetaTypeInvoker&lt;Derived, Argument, ReturnType&gt;</a>
<a name="ln126">    {</a>
<a name="ln127">    };</a>
<a name="ln128"> </a>
<a name="ln129">    template&lt;typename T&gt; struct QVariantValueHelper;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">class Q_CORE_EXPORT QVariant</a>
<a name="ln133">{</a>
<a name="ln134"> public:</a>
<a name="ln135">    enum Type {</a>
<a name="ln136">        Invalid = QMetaType::UnknownType,</a>
<a name="ln137">        Bool = QMetaType::Bool,</a>
<a name="ln138">        Int = QMetaType::Int,</a>
<a name="ln139">        UInt = QMetaType::UInt,</a>
<a name="ln140">        LongLong = QMetaType::LongLong,</a>
<a name="ln141">        ULongLong = QMetaType::ULongLong,</a>
<a name="ln142">        Double = QMetaType::Double,</a>
<a name="ln143">        Char = QMetaType::QChar,</a>
<a name="ln144">        Map = QMetaType::QVariantMap,</a>
<a name="ln145">        List = QMetaType::QVariantList,</a>
<a name="ln146">        String = QMetaType::QString,</a>
<a name="ln147">        StringList = QMetaType::QStringList,</a>
<a name="ln148">        ByteArray = QMetaType::QByteArray,</a>
<a name="ln149">        BitArray = QMetaType::QBitArray,</a>
<a name="ln150">        Date = QMetaType::QDate,</a>
<a name="ln151">        Time = QMetaType::QTime,</a>
<a name="ln152">        DateTime = QMetaType::QDateTime,</a>
<a name="ln153">        Url = QMetaType::QUrl,</a>
<a name="ln154">        Locale = QMetaType::QLocale,</a>
<a name="ln155">        Rect = QMetaType::QRect,</a>
<a name="ln156">        RectF = QMetaType::QRectF,</a>
<a name="ln157">        Size = QMetaType::QSize,</a>
<a name="ln158">        SizeF = QMetaType::QSizeF,</a>
<a name="ln159">        Line = QMetaType::QLine,</a>
<a name="ln160">        LineF = QMetaType::QLineF,</a>
<a name="ln161">        Point = QMetaType::QPoint,</a>
<a name="ln162">        PointF = QMetaType::QPointF,</a>
<a name="ln163">        RegExp = QMetaType::QRegExp,</a>
<a name="ln164">        RegularExpression = QMetaType::QRegularExpression,</a>
<a name="ln165">        Hash = QMetaType::QVariantHash,</a>
<a name="ln166">        EasingCurve = QMetaType::QEasingCurve,</a>
<a name="ln167">        Uuid = QMetaType::QUuid,</a>
<a name="ln168">#if QT_CONFIG(itemmodel)</a>
<a name="ln169">        ModelIndex = QMetaType::QModelIndex,</a>
<a name="ln170">        PersistentModelIndex = QMetaType::QPersistentModelIndex,</a>
<a name="ln171">#endif</a>
<a name="ln172">        LastCoreType = QMetaType::LastCoreType,</a>
<a name="ln173"> </a>
<a name="ln174">        Font = QMetaType::QFont,</a>
<a name="ln175">        Pixmap = QMetaType::QPixmap,</a>
<a name="ln176">        Brush = QMetaType::QBrush,</a>
<a name="ln177">        Color = QMetaType::QColor,</a>
<a name="ln178">        Palette = QMetaType::QPalette,</a>
<a name="ln179">        Image = QMetaType::QImage,</a>
<a name="ln180">        Polygon = QMetaType::QPolygon,</a>
<a name="ln181">        Region = QMetaType::QRegion,</a>
<a name="ln182">        Bitmap = QMetaType::QBitmap,</a>
<a name="ln183">        Cursor = QMetaType::QCursor,</a>
<a name="ln184">        KeySequence = QMetaType::QKeySequence,</a>
<a name="ln185">        Pen = QMetaType::QPen,</a>
<a name="ln186">        TextLength = QMetaType::QTextLength,</a>
<a name="ln187">        TextFormat = QMetaType::QTextFormat,</a>
<a name="ln188">        Matrix = QMetaType::QMatrix,</a>
<a name="ln189">        Transform = QMetaType::QTransform,</a>
<a name="ln190">        Matrix4x4 = QMetaType::QMatrix4x4,</a>
<a name="ln191">        Vector2D = QMetaType::QVector2D,</a>
<a name="ln192">        Vector3D = QMetaType::QVector3D,</a>
<a name="ln193">        Vector4D = QMetaType::QVector4D,</a>
<a name="ln194">        Quaternion = QMetaType::QQuaternion,</a>
<a name="ln195">        PolygonF = QMetaType::QPolygonF,</a>
<a name="ln196">        Icon = QMetaType::QIcon,</a>
<a name="ln197">        LastGuiType = QMetaType::LastGuiType,</a>
<a name="ln198"> </a>
<a name="ln199">        SizePolicy = QMetaType::QSizePolicy,</a>
<a name="ln200"> </a>
<a name="ln201">        UserType = QMetaType::User,</a>
<a name="ln202">        LastType = 0xffffffff // need this so that gcc &gt;= 3.4 allocates 32 bits for Type</a>
<a name="ln203">    };</a>
<a name="ln204"> </a>
<a name="ln205">    QVariant() Q_DECL_NOTHROW : d() {}</a>
<a name="ln206">    ~QVariant();</a>
<a name="ln207">    QVariant(Type type);</a>
<a name="ln208">    QVariant(int typeId, const void *copy);</a>
<a name="ln209">    QVariant(int typeId, const void *copy, uint flags);</a>
<a name="ln210">    QVariant(const QVariant &amp;other);</a>
<a name="ln211"> </a>
<a name="ln212">#ifndef QT_NO_DATASTREAM</a>
<a name="ln213">    QVariant(QDataStream &amp;s);</a>
<a name="ln214">#endif</a>
<a name="ln215"> </a>
<a name="ln216">    QVariant(int i);</a>
<a name="ln217">    QVariant(uint ui);</a>
<a name="ln218">    QVariant(qlonglong ll);</a>
<a name="ln219">    QVariant(qulonglong ull);</a>
<a name="ln220">    QVariant(bool b);</a>
<a name="ln221">    QVariant(double d);</a>
<a name="ln222">    QVariant(float f);</a>
<a name="ln223">#ifndef QT_NO_CAST_FROM_ASCII</a>
<a name="ln224">    QT_ASCII_CAST_WARN QVariant(const char *str);</a>
<a name="ln225">#endif</a>
<a name="ln226"> </a>
<a name="ln227">    QVariant(const QByteArray &amp;bytearray);</a>
<a name="ln228">    QVariant(const QBitArray &amp;bitarray);</a>
<a name="ln229">    QVariant(const QString &amp;string);</a>
<a name="ln230">    QVariant(QLatin1String string);</a>
<a name="ln231">    QVariant(const QStringList &amp;stringlist);</a>
<a name="ln232">    QVariant(QChar qchar);</a>
<a name="ln233">    QVariant(const QDate &amp;date);</a>
<a name="ln234">    QVariant(const QTime &amp;time);</a>
<a name="ln235">    QVariant(const QDateTime &amp;datetime);</a>
<a name="ln236">    QVariant(const QList&lt;QVariant&gt; &amp;list);</a>
<a name="ln237">    QVariant(const QMap&lt;QString,QVariant&gt; &amp;map);</a>
<a name="ln238">    QVariant(const QHash&lt;QString,QVariant&gt; &amp;hash);</a>
<a name="ln239">#ifndef QT_NO_GEOM_VARIANT</a>
<a name="ln240">    QVariant(const QSize &amp;size);</a>
<a name="ln241">    QVariant(const QSizeF &amp;size);</a>
<a name="ln242">    QVariant(const QPoint &amp;pt);</a>
<a name="ln243">    QVariant(const QPointF &amp;pt);</a>
<a name="ln244">    QVariant(const QLine &amp;line);</a>
<a name="ln245">    QVariant(const QLineF &amp;line);</a>
<a name="ln246">    QVariant(const QRect &amp;rect);</a>
<a name="ln247">    QVariant(const QRectF &amp;rect);</a>
<a name="ln248">#endif</a>
<a name="ln249">    QVariant(const QLocale &amp;locale);</a>
<a name="ln250">#ifndef QT_NO_REGEXP</a>
<a name="ln251">    QVariant(const QRegExp &amp;regExp);</a>
<a name="ln252">#endif // QT_NO_REGEXP</a>
<a name="ln253">#if QT_CONFIG(regularexpression)</a>
<a name="ln254">    QVariant(const QRegularExpression &amp;re);</a>
<a name="ln255">#endif // QT_CONFIG(regularexpression)</a>
<a name="ln256">#ifndef QT_BOOTSTRAPPED</a>
<a name="ln257">    QVariant(const QUrl &amp;url);</a>
<a name="ln258">    QVariant(const QEasingCurve &amp;easing);</a>
<a name="ln259">    QVariant(const QUuid &amp;uuid);</a>
<a name="ln260">    QVariant(const QJsonValue &amp;jsonValue);</a>
<a name="ln261">    QVariant(const QJsonObject &amp;jsonObject);</a>
<a name="ln262">    QVariant(const QJsonArray &amp;jsonArray);</a>
<a name="ln263">    QVariant(const QJsonDocument &amp;jsonDocument);</a>
<a name="ln264">#endif // QT_BOOTSTRAPPED</a>
<a name="ln265">#if QT_CONFIG(itemmodel)</a>
<a name="ln266">    QVariant(const QModelIndex &amp;modelIndex);</a>
<a name="ln267">    QVariant(const QPersistentModelIndex &amp;modelIndex);</a>
<a name="ln268">#endif</a>
<a name="ln269"> </a>
<a name="ln270">    QVariant&amp; operator=(const QVariant &amp;other);</a>
<a name="ln271">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln272">    inline QVariant(QVariant &amp;&amp;other) Q_DECL_NOTHROW : d(other.d)</a>
<a name="ln273">    { other.d = Private(); }</a>
<a name="ln274">    inline QVariant &amp;operator=(QVariant &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln275">    { qSwap(d, other.d); return *this; }</a>
<a name="ln276">#endif</a>
<a name="ln277"> </a>
<a name="ln278">    inline void swap(QVariant &amp;other) Q_DECL_NOTHROW { qSwap(d, other.d); }</a>
<a name="ln279"> </a>
<a name="ln280">    Type type() const;</a>
<a name="ln281">    int userType() const;</a>
<a name="ln282">    const char *typeName() const;</a>
<a name="ln283"> </a>
<a name="ln284">    bool canConvert(int targetTypeId) const;</a>
<a name="ln285">    bool convert(int targetTypeId);</a>
<a name="ln286"> </a>
<a name="ln287">    inline bool isValid() const;</a>
<a name="ln288">    bool isNull() const;</a>
<a name="ln289"> </a>
<a name="ln290">    void clear();</a>
<a name="ln291"> </a>
<a name="ln292">    void detach();</a>
<a name="ln293">    inline bool isDetached() const;</a>
<a name="ln294"> </a>
<a name="ln295">    int toInt(bool *ok = nullptr) const;</a>
<a name="ln296">    uint toUInt(bool *ok = nullptr) const;</a>
<a name="ln297">    qlonglong toLongLong(bool *ok = nullptr) const;</a>
<a name="ln298">    qulonglong toULongLong(bool *ok = nullptr) const;</a>
<a name="ln299">    bool toBool() const;</a>
<a name="ln300">    double toDouble(bool *ok = nullptr) const;</a>
<a name="ln301">    float toFloat(bool *ok = nullptr) const;</a>
<a name="ln302">    qreal toReal(bool *ok = nullptr) const;</a>
<a name="ln303">    QByteArray toByteArray() const;</a>
<a name="ln304">    QBitArray toBitArray() const;</a>
<a name="ln305">    QString toString() const;</a>
<a name="ln306">    QStringList toStringList() const;</a>
<a name="ln307">    QChar toChar() const;</a>
<a name="ln308">    QDate toDate() const;</a>
<a name="ln309">    QTime toTime() const;</a>
<a name="ln310">    QDateTime toDateTime() const;</a>
<a name="ln311">    QList&lt;QVariant&gt; toList() const;</a>
<a name="ln312">    QMap&lt;QString, QVariant&gt; toMap() const;</a>
<a name="ln313">    QHash&lt;QString, QVariant&gt; toHash() const;</a>
<a name="ln314"> </a>
<a name="ln315">#ifndef QT_NO_GEOM_VARIANT</a>
<a name="ln316">    QPoint toPoint() const;</a>
<a name="ln317">    QPointF toPointF() const;</a>
<a name="ln318">    QRect toRect() const;</a>
<a name="ln319">    QSize toSize() const;</a>
<a name="ln320">    QSizeF toSizeF() const;</a>
<a name="ln321">    QLine toLine() const;</a>
<a name="ln322">    QLineF toLineF() const;</a>
<a name="ln323">    QRectF toRectF() const;</a>
<a name="ln324">#endif</a>
<a name="ln325">    QLocale toLocale() const;</a>
<a name="ln326">#ifndef QT_NO_REGEXP</a>
<a name="ln327">    QRegExp toRegExp() const;</a>
<a name="ln328">#endif // QT_NO_REGEXP</a>
<a name="ln329">#if QT_CONFIG(regularexpression)</a>
<a name="ln330">    QRegularExpression toRegularExpression() const;</a>
<a name="ln331">#endif // QT_CONFIG(regularexpression)</a>
<a name="ln332">#ifndef QT_BOOTSTRAPPED</a>
<a name="ln333">    QUrl toUrl() const;</a>
<a name="ln334">    QEasingCurve toEasingCurve() const;</a>
<a name="ln335">    QUuid toUuid() const;</a>
<a name="ln336">    QJsonValue toJsonValue() const;</a>
<a name="ln337">    QJsonObject toJsonObject() const;</a>
<a name="ln338">    QJsonArray toJsonArray() const;</a>
<a name="ln339">    QJsonDocument toJsonDocument() const;</a>
<a name="ln340">#endif // QT_BOOTSTRAPPED</a>
<a name="ln341">#if QT_CONFIG(itemmodel)</a>
<a name="ln342">    QModelIndex toModelIndex() const;</a>
<a name="ln343">    QPersistentModelIndex toPersistentModelIndex() const;</a>
<a name="ln344">#endif</a>
<a name="ln345"> </a>
<a name="ln346">#ifndef QT_NO_DATASTREAM</a>
<a name="ln347">    void load(QDataStream &amp;ds);</a>
<a name="ln348">    void save(QDataStream &amp;ds) const;</a>
<a name="ln349">#endif</a>
<a name="ln350">    static const char *typeToName(int typeId);</a>
<a name="ln351">    static Type nameToType(const char *name);</a>
<a name="ln352"> </a>
<a name="ln353">    void *data();</a>
<a name="ln354">    const void *constData() const;</a>
<a name="ln355">    inline const void *data() const { return constData(); }</a>
<a name="ln356"> </a>
<a name="ln357">    template&lt;typename T&gt;</a>
<a name="ln358">    inline void setValue(const T &amp;value);</a>
<a name="ln359"> </a>
<a name="ln360">    template&lt;typename T&gt;</a>
<a name="ln361">    inline T value() const</a>
<a name="ln362">    { return qvariant_cast&lt;T&gt;(*this); }</a>
<a name="ln363"> </a>
<a name="ln364">    template&lt;typename T&gt;</a>
<a name="ln365">    static inline QVariant fromValue(const T &amp;value)</a>
<a name="ln366">    { return qVariantFromValue(value); }</a>
<a name="ln367"> </a>
<a name="ln368">#if defined(Q_CLANG_QDOC) || (QT_HAS_INCLUDE(&lt;variant&gt;) &amp;&amp; __cplusplus &gt;= 201703L)</a>
<a name="ln369">    template&lt;typename... Types&gt;</a>
<a name="ln370">    static inline QVariant fromStdVariant(const std::variant&lt;Types...&gt; &amp;value)</a>
<a name="ln371">    {</a>
<a name="ln372">        if (value.valueless_by_exception())</a>
<a name="ln373">            return QVariant();</a>
<a name="ln374">        return std::visit([](const auto &amp;arg) { return fromValue(arg); }, value);</a>
<a name="ln375">    }</a>
<a name="ln376">#endif</a>
<a name="ln377"> </a>
<a name="ln378">    template&lt;typename T&gt;</a>
<a name="ln379">    bool canConvert() const</a>
<a name="ln380">    { return canConvert(qMetaTypeId&lt;T&gt;()); }</a>
<a name="ln381"> </a>
<a name="ln382"> public:</a>
<a name="ln383">    struct PrivateShared</a>
<a name="ln384">    {</a>
<a name="ln385">        inline PrivateShared(void *v) : ptr(v), ref(1) { }</a>
<a name="ln386">        void *ptr;</a>
<a name="ln387">        QAtomicInt ref;</a>
<a name="ln388">    };</a>
<a name="ln389">    struct Private</a>
<a name="ln390">    {</a>
<a name="ln391">        inline Private() Q_DECL_NOTHROW : type(Invalid), is_shared(false), is_null(true)</a>
<a name="ln392">        { data.ptr = nullptr; }</a>
<a name="ln393"> </a>
<a name="ln394">        // Internal constructor for initialized variants.</a>
<a name="ln395">        explicit inline Private(uint variantType) Q_DECL_NOTHROW</a>
<a name="ln396">            : type(variantType), is_shared(false), is_null(false)</a>
<a name="ln397">        {}</a>
<a name="ln398"> </a>
<a name="ln399">        inline Private(const Private &amp;other) Q_DECL_NOTHROW</a>
<a name="ln400">            : data(other.data), type(other.type),</a>
<a name="ln401">              is_shared(other.is_shared), is_null(other.is_null)</a>
<a name="ln402">        {}</a>
<a name="ln403">        union Data</a>
<a name="ln404">        {</a>
<a name="ln405">            char c;</a>
<a name="ln406">            uchar uc;</a>
<a name="ln407">            short s;</a>
<a name="ln408">            signed char sc;</a>
<a name="ln409">            ushort us;</a>
<a name="ln410">            int i;</a>
<a name="ln411">            uint u;</a>
<a name="ln412">            long l;</a>
<a name="ln413">            ulong ul;</a>
<a name="ln414">            bool b;</a>
<a name="ln415">            double d;</a>
<a name="ln416">            float f;</a>
<a name="ln417">            qreal real;</a>
<a name="ln418">            qlonglong ll;</a>
<a name="ln419">            qulonglong ull;</a>
<a name="ln420">            QObject *o;</a>
<a name="ln421">            void *ptr;</a>
<a name="ln422">            PrivateShared *shared;</a>
<a name="ln423">        } data;</a>
<a name="ln424">        uint type : 30;</a>
<a name="ln425">        uint is_shared : 1;</a>
<a name="ln426">        uint is_null : 1;</a>
<a name="ln427">    };</a>
<a name="ln428"> public:</a>
<a name="ln429">    typedef void (*f_construct)(Private *, const void *);</a>
<a name="ln430">    typedef void (*f_clear)(Private *);</a>
<a name="ln431">    typedef bool (*f_null)(const Private *);</a>
<a name="ln432">#ifndef QT_NO_DATASTREAM</a>
<a name="ln433">    typedef void (*f_load)(Private *, QDataStream &amp;);</a>
<a name="ln434">    typedef void (*f_save)(const Private *, QDataStream &amp;);</a>
<a name="ln435">#endif</a>
<a name="ln436">    typedef bool (*f_compare)(const Private *, const Private *);</a>
<a name="ln437">    typedef bool (*f_convert)(const QVariant::Private *d, int t, void *, bool *);</a>
<a name="ln438">    typedef bool (*f_canConvert)(const QVariant::Private *d, int t);</a>
<a name="ln439">    typedef void (*f_debugStream)(QDebug, const QVariant &amp;);</a>
<a name="ln440">    struct Handler {</a>
<a name="ln441">        f_construct construct;</a>
<a name="ln442">        f_clear clear;</a>
<a name="ln443">        f_null isNull;</a>
<a name="ln444">#ifndef QT_NO_DATASTREAM</a>
<a name="ln445">        f_load load;</a>
<a name="ln446">        f_save save;</a>
<a name="ln447">#endif</a>
<a name="ln448">        f_compare compare;</a>
<a name="ln449">        f_convert convert;</a>
<a name="ln450">        f_canConvert canConvert;</a>
<a name="ln451">        f_debugStream debugStream;</a>
<a name="ln452">    };</a>
<a name="ln453"> </a>
<a name="ln454">    inline bool operator==(const QVariant &amp;v) const</a>
<a name="ln455">    { return cmp(v); }</a>
<a name="ln456">    inline bool operator!=(const QVariant &amp;v) const</a>
<a name="ln457">    { return !cmp(v); }</a>
<a name="ln458">    inline bool operator&lt;(const QVariant &amp;v) const</a>
<a name="ln459">    { return compare(v) &lt; 0; }</a>
<a name="ln460">    inline bool operator&lt;=(const QVariant &amp;v) const</a>
<a name="ln461">    { return compare(v) &lt;= 0; }</a>
<a name="ln462">    inline bool operator&gt;(const QVariant &amp;v) const</a>
<a name="ln463">    { return compare(v) &gt; 0; }</a>
<a name="ln464">    inline bool operator&gt;=(const QVariant &amp;v) const</a>
<a name="ln465">    { return compare(v) &gt;= 0; }</a>
<a name="ln466"> </a>
<a name="ln467">protected:</a>
<a name="ln468">    friend inline bool operator==(const QVariant &amp;, const QVariantComparisonHelper &amp;);</a>
<a name="ln469">#ifndef QT_NO_DEBUG_STREAM</a>
<a name="ln470">    friend Q_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QVariant &amp;);</a>
<a name="ln471">#endif</a>
<a name="ln472">// ### Qt6: FIXME: Remove the special Q_CC_MSVC handling, it was introduced to maintain BC for QTBUG-41810 .</a>
<a name="ln473">#if !defined(Q_NO_TEMPLATE_FRIENDS) &amp;&amp; !defined(Q_CC_MSVC)</a>
<a name="ln474">    template&lt;typename T&gt;</a>
<a name="ln475">    friend inline T qvariant_cast(const QVariant &amp;);</a>
<a name="ln476">    template&lt;typename T&gt; friend struct QtPrivate::QVariantValueHelper;</a>
<a name="ln477">protected:</a>
<a name="ln478">#else</a>
<a name="ln479">public:</a>
<a name="ln480">#endif</a>
<a name="ln481">    Private d;</a>
<a name="ln482">    void create(int type, const void *copy);</a>
<a name="ln483">    bool cmp(const QVariant &amp;other) const;</a>
<a name="ln484">    int compare(const QVariant &amp;other) const;</a>
<a name="ln485">    bool convert(const int t, void *ptr) const; // ### Qt6: drop const</a>
<a name="ln486"> </a>
<a name="ln487">private:</a>
<a name="ln488">    // force compile error, prevent QVariant(bool) to be called</a>
<a name="ln489">    inline QVariant(void *) Q_DECL_EQ_DELETE;</a>
<a name="ln490">    // QVariant::Type is marked as \obsolete, but we don't want to</a>
<a name="ln491">    // provide a constructor from its intended replacement,</a>
<a name="ln492">    // QMetaType::Type, instead, because the idea behind these</a>
<a name="ln493">    // constructors is flawed in the first place. But we also don't</a>
<a name="ln494">    // want QVariant(QMetaType::String) to compile and falsely be an</a>
<a name="ln495">    // int variant, so delete this constructor:</a>
<a name="ln496">    QVariant(QMetaType::Type) Q_DECL_EQ_DELETE;</a>
<a name="ln497"> </a>
<a name="ln498">    // These constructors don't create QVariants of the type associcated</a>
<a name="ln499">    // with the enum, as expected, but they would create a QVariant of</a>
<a name="ln500">    // type int with the value of the enum value.</a>
<a name="ln501">    // Use QVariant v = QColor(Qt::red) instead of QVariant v = Qt::red for</a>
<a name="ln502">    // example.</a>
<a name="ln503">    QVariant(Qt::GlobalColor) Q_DECL_EQ_DELETE;</a>
<a name="ln504">    QVariant(Qt::BrushStyle) Q_DECL_EQ_DELETE;</a>
<a name="ln505">    QVariant(Qt::PenStyle) Q_DECL_EQ_DELETE;</a>
<a name="ln506">    QVariant(Qt::CursorShape) Q_DECL_EQ_DELETE;</a>
<a name="ln507">#ifdef QT_NO_CAST_FROM_ASCII</a>
<a name="ln508">    // force compile error when implicit conversion is not wanted</a>
<a name="ln509">    inline QVariant(const char *) Q_DECL_EQ_DELETE;</a>
<a name="ln510">#endif</a>
<a name="ln511">public:</a>
<a name="ln512">    typedef Private DataPtr;</a>
<a name="ln513">    inline DataPtr &amp;data_ptr() { return d; }</a>
<a name="ln514">    inline const DataPtr &amp;data_ptr() const { return d; }</a>
<a name="ln515">};</a>
<a name="ln516"> </a>
<a name="ln517">template &lt;typename T&gt;</a>
<a name="ln518">inline QVariant qVariantFromValue(const T &amp;t)</a>
<a name="ln519">{</a>
<a name="ln520">    return QVariant(qMetaTypeId&lt;T&gt;(), &amp;t, QTypeInfo&lt;T&gt;::isPointer);</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">template &lt;&gt;</a>
<a name="ln524">inline QVariant qVariantFromValue(const QVariant &amp;t) { return t; }</a>
<a name="ln525"> </a>
<a name="ln526">#if QT_HAS_INCLUDE(&lt;variant&gt;) &amp;&amp; __cplusplus &gt;= 201703L</a>
<a name="ln527">template &lt;&gt;</a>
<a name="ln528">inline QVariant qVariantFromValue(const std::monostate &amp;) { return QVariant(); }</a>
<a name="ln529">#endif</a>
<a name="ln530"> </a>
<a name="ln531">template &lt;typename T&gt;</a>
<a name="ln532">inline void qVariantSetValue(QVariant &amp;v, const T &amp;t)</a>
<a name="ln533">{</a>
<a name="ln534">    //if possible we reuse the current QVariant private</a>
<a name="ln535">    const uint type = qMetaTypeId&lt;T&gt;();</a>
<a name="ln536">    QVariant::Private &amp;d = v.data_ptr();</a>
<a name="ln537">    if (v.isDetached() &amp;&amp; (type == d.type || (type &lt;= uint(QVariant::Char) &amp;&amp; d.type &lt;= uint(QVariant::Char)))) {</a>
<a name="ln538">        d.type = type;</a>
<a name="ln539">        d.is_null = false;</a>
<a name="ln540">        T *old = reinterpret_cast&lt;T*&gt;(d.is_shared ? d.data.shared-&gt;ptr : &amp;d.data.ptr);</a>
<a name="ln541">        if (QTypeInfo&lt;T&gt;::isComplex)</a>
<a name="ln542">            old-&gt;~T();</a>
<a name="ln543">        new (old) T(t); //call the copy constructor</a>
<a name="ln544">    } else {</a>
<a name="ln545">        v = QVariant(type, &amp;t, QTypeInfo&lt;T&gt;::isPointer);</a>
<a name="ln546">    }</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">template &lt;&gt;</a>
<a name="ln550">inline void qVariantSetValue&lt;QVariant&gt;(QVariant &amp;v, const QVariant &amp;t)</a>
<a name="ln551">{</a>
<a name="ln552">    v = t;</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">inline bool QVariant::isValid() const { return d.type != Invalid; }</a>
<a name="ln556"> </a>
<a name="ln557">template&lt;typename T&gt;</a>
<a name="ln558">inline void QVariant::setValue(const T &amp;avalue)</a>
<a name="ln559">{ qVariantSetValue(*this, avalue); }</a>
<a name="ln560"> </a>
<a name="ln561">#ifndef QT_NO_DATASTREAM</a>
<a name="ln562">Q_CORE_EXPORT QDataStream&amp; operator&gt;&gt; (QDataStream&amp; s, QVariant&amp; p);</a>
<a name="ln563">Q_CORE_EXPORT QDataStream&amp; operator&lt;&lt; (QDataStream&amp; s, const QVariant&amp; p);</a>
<a name="ln564">Q_CORE_EXPORT QDataStream&amp; operator&gt;&gt; (QDataStream&amp; s, QVariant::Type&amp; p);</a>
<a name="ln565">Q_CORE_EXPORT QDataStream&amp; operator&lt;&lt; (QDataStream&amp; s, const QVariant::Type p);</a>
<a name="ln566">#endif</a>
<a name="ln567"> </a>
<a name="ln568">inline bool QVariant::isDetached() const</a>
<a name="ln569">{ return !d.is_shared || d.data.shared-&gt;ref.load() == 1; }</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">#ifdef Q_QDOC</a>
<a name="ln573">    inline bool operator==(const QVariant &amp;v1, const QVariant &amp;v2);</a>
<a name="ln574">    inline bool operator!=(const QVariant &amp;v1, const QVariant &amp;v2);</a>
<a name="ln575">#else</a>
<a name="ln576"> </a>
<a name="ln577">/* Helper class to add one more level of indirection to prevent</a>
<a name="ln578">   implicit casts.</a>
<a name="ln579">*/</a>
<a name="ln580">class QVariantComparisonHelper</a>
<a name="ln581">{</a>
<a name="ln582">public:</a>
<a name="ln583">    inline QVariantComparisonHelper(const QVariant &amp;var)</a>
<a name="ln584">        : v(&amp;var) {}</a>
<a name="ln585">private:</a>
<a name="ln586">    friend inline bool operator==(const QVariant &amp;, const QVariantComparisonHelper &amp;);</a>
<a name="ln587">    const QVariant *v;</a>
<a name="ln588">};</a>
<a name="ln589"> </a>
<a name="ln590">inline bool operator==(const QVariant &amp;v1, const QVariantComparisonHelper &amp;v2)</a>
<a name="ln591">{</a>
<a name="ln592">    return v1.cmp(*v2.v);</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">inline bool operator!=(const QVariant &amp;v1, const QVariantComparisonHelper &amp;v2)</a>
<a name="ln596">{</a>
<a name="ln597">    return !operator==(v1, v2);</a>
<a name="ln598">}</a>
<a name="ln599">#endif</a>
<a name="ln600">Q_DECLARE_SHARED(QVariant)</a>
<a name="ln601"> </a>
<a name="ln602">class Q_CORE_EXPORT QSequentialIterable</a>
<a name="ln603">{</a>
<a name="ln604">    QtMetaTypePrivate::QSequentialIterableImpl m_impl;</a>
<a name="ln605">public:</a>
<a name="ln606">    struct Q_CORE_EXPORT const_iterator</a>
<a name="ln607">    {</a>
<a name="ln608">    private:</a>
<a name="ln609">        QtMetaTypePrivate::QSequentialIterableImpl m_impl;</a>
<a name="ln610">        QAtomicInt *ref;</a>
<a name="ln611">        friend class QSequentialIterable;</a>
<a name="ln612">        explicit const_iterator(const QSequentialIterable &amp;iter, QAtomicInt *ref_);</a>
<a name="ln613"> </a>
<a name="ln614">        explicit const_iterator(const QtMetaTypePrivate::QSequentialIterableImpl &amp;impl, QAtomicInt *ref_);</a>
<a name="ln615"> </a>
<a name="ln616">        void begin();</a>
<a name="ln617">        void end();</a>
<a name="ln618">    public:</a>
<a name="ln619">        ~const_iterator();</a>
<a name="ln620"> </a>
<a name="ln621">        const_iterator(const const_iterator &amp;other);</a>
<a name="ln622"> </a>
<a name="ln623">        const_iterator&amp; operator=(const const_iterator &amp;other);</a>
<a name="ln624"> </a>
<a name="ln625">        const QVariant operator*() const;</a>
<a name="ln626">        bool operator==(const const_iterator &amp;o) const;</a>
<a name="ln627">        bool operator!=(const const_iterator &amp;o) const;</a>
<a name="ln628">        const_iterator &amp;operator++();</a>
<a name="ln629">        const_iterator operator++(int);</a>
<a name="ln630">        const_iterator &amp;operator--();</a>
<a name="ln631">        const_iterator operator--(int);</a>
<a name="ln632">        const_iterator &amp;operator+=(int j);</a>
<a name="ln633">        const_iterator &amp;operator-=(int j);</a>
<a name="ln634">        const_iterator operator+(int j) const;</a>
<a name="ln635">        const_iterator operator-(int j) const;</a>
<a name="ln636">    };</a>
<a name="ln637"> </a>
<a name="ln638">    friend struct const_iterator;</a>
<a name="ln639"> </a>
<a name="ln640">#if QT_VERSION &lt; QT_VERSION_CHECK(6, 0, 0)</a>
<a name="ln641">    explicit QSequentialIterable(QtMetaTypePrivate::QSequentialIterableImpl impl);</a>
<a name="ln642">#else</a>
<a name="ln643">    explicit QSequentialIterable(const QtMetaTypePrivate::QSequentialIterableImpl &amp;impl);</a>
<a name="ln644">#endif</a>
<a name="ln645"> </a>
<a name="ln646">    const_iterator begin() const;</a>
<a name="ln647">    const_iterator end() const;</a>
<a name="ln648"> </a>
<a name="ln649">    QVariant at(int idx) const;</a>
<a name="ln650">    int size() const;</a>
<a name="ln651"> </a>
<a name="ln652">    bool canReverseIterate() const;</a>
<a name="ln653">};</a>
<a name="ln654"> </a>
<a name="ln655">class Q_CORE_EXPORT QAssociativeIterable</a>
<a name="ln656">{</a>
<a name="ln657">    QtMetaTypePrivate::QAssociativeIterableImpl m_impl;</a>
<a name="ln658">public:</a>
<a name="ln659">    struct Q_CORE_EXPORT const_iterator</a>
<a name="ln660">    {</a>
<a name="ln661">    private:</a>
<a name="ln662">        QtMetaTypePrivate::QAssociativeIterableImpl m_impl;</a>
<a name="ln663">        QAtomicInt *ref;</a>
<a name="ln664">        friend class QAssociativeIterable;</a>
<a name="ln665">        explicit const_iterator(const QAssociativeIterable &amp;iter, QAtomicInt *ref_);</a>
<a name="ln666"> </a>
<a name="ln667">        explicit const_iterator(const QtMetaTypePrivate::QAssociativeIterableImpl &amp;impl, QAtomicInt *ref_);</a>
<a name="ln668"> </a>
<a name="ln669">        void begin();</a>
<a name="ln670">        void end();</a>
<a name="ln671">        void find(const QVariant &amp;key);</a>
<a name="ln672">    public:</a>
<a name="ln673">        ~const_iterator();</a>
<a name="ln674">        const_iterator(const const_iterator &amp;other);</a>
<a name="ln675"> </a>
<a name="ln676">        const_iterator&amp; operator=(const const_iterator &amp;other);</a>
<a name="ln677"> </a>
<a name="ln678">        const QVariant key() const;</a>
<a name="ln679"> </a>
<a name="ln680">        const QVariant value() const;</a>
<a name="ln681"> </a>
<a name="ln682">        const QVariant operator*() const;</a>
<a name="ln683">        bool operator==(const const_iterator &amp;o) const;</a>
<a name="ln684">        bool operator!=(const const_iterator &amp;o) const;</a>
<a name="ln685">        const_iterator &amp;operator++();</a>
<a name="ln686">        const_iterator operator++(int);</a>
<a name="ln687">        const_iterator &amp;operator--();</a>
<a name="ln688">        const_iterator operator--(int);</a>
<a name="ln689">        const_iterator &amp;operator+=(int j);</a>
<a name="ln690">        const_iterator &amp;operator-=(int j);</a>
<a name="ln691">        const_iterator operator+(int j) const;</a>
<a name="ln692">        const_iterator operator-(int j) const;</a>
<a name="ln693">    };</a>
<a name="ln694"> </a>
<a name="ln695">    friend struct const_iterator;</a>
<a name="ln696"> </a>
<a name="ln697">#if QT_VERSION &lt; QT_VERSION_CHECK(6, 0, 0)</a>
<a name="ln698">    explicit QAssociativeIterable(QtMetaTypePrivate::QAssociativeIterableImpl impl);</a>
<a name="ln699">#else</a>
<a name="ln700">    explicit QAssociativeIterable(const QtMetaTypePrivate::QAssociativeIterableImpl &amp;impl);</a>
<a name="ln701">#endif</a>
<a name="ln702"> </a>
<a name="ln703">    const_iterator begin() const;</a>
<a name="ln704">    const_iterator end() const;</a>
<a name="ln705">    const_iterator find(const QVariant &amp;key) const;</a>
<a name="ln706"> </a>
<a name="ln707">    QVariant value(const QVariant &amp;key) const;</a>
<a name="ln708"> </a>
<a name="ln709">    int size() const;</a>
<a name="ln710">};</a>
<a name="ln711"> </a>
<a name="ln712">#ifndef QT_MOC</a>
<a name="ln713">namespace QtPrivate {</a>
<a name="ln714">    template&lt;typename T&gt;</a>
<a name="ln715">    struct QVariantValueHelper : TreatAsQObjectBeforeMetaType&lt;QVariantValueHelper&lt;T&gt;, T, const QVariant &amp;, T&gt;</a>
<a name="ln716">    {</a>
<a name="ln717">        static T metaType(const QVariant &amp;v)</a>
<a name="ln718">        {</a>
<a name="ln719">            const int vid = qMetaTypeId&lt;T&gt;();</a>
<a name="ln720">            if (vid == v.userType())</a>
<a name="ln721">                return *reinterpret_cast&lt;const T *&gt;(v.constData());</a>
<a name="ln722">            T t;</a>
<a name="ln723">            if (v.convert(vid, &amp;t))</a>
<a name="ln724">                return t;</a>
<a name="ln725">            return T();</a>
<a name="ln726">        }</a>
<a name="ln727">#ifndef QT_NO_QOBJECT</a>
<a name="ln728">        static T object(const QVariant &amp;v)</a>
<a name="ln729">        {</a>
<a name="ln730">            return qobject_cast&lt;T&gt;(QMetaType::typeFlags(v.userType()) &amp; QMetaType::PointerToQObject</a>
<a name="ln731">                ? v.d.data.o</a>
<a name="ln732">                : QVariantValueHelper::metaType(v));</a>
<a name="ln733">        }</a>
<a name="ln734">#endif</a>
<a name="ln735">    };</a>
<a name="ln736"> </a>
<a name="ln737">    template&lt;typename T&gt;</a>
<a name="ln738">    struct QVariantValueHelperInterface : QVariantValueHelper&lt;T&gt;</a>
<a name="ln739">    {</a>
<a name="ln740">    };</a>
<a name="ln741"> </a>
<a name="ln742">    template&lt;&gt;</a>
<a name="ln743">    struct QVariantValueHelperInterface&lt;QSequentialIterable&gt;</a>
<a name="ln744">    {</a>
<a name="ln745">        static QSequentialIterable invoke(const QVariant &amp;v)</a>
<a name="ln746">        {</a>
<a name="ln747">            const int typeId = v.userType();</a>
<a name="ln748">            if (typeId == qMetaTypeId&lt;QVariantList&gt;()) {</a>
<a name="ln749">                return QSequentialIterable(QtMetaTypePrivate::QSequentialIterableImpl(reinterpret_cast&lt;const QVariantList*&gt;(v.constData())));</a>
<a name="ln750">            }</a>
<a name="ln751">            if (typeId == qMetaTypeId&lt;QStringList&gt;()) {</a>
<a name="ln752">                return QSequentialIterable(QtMetaTypePrivate::QSequentialIterableImpl(reinterpret_cast&lt;const QStringList*&gt;(v.constData())));</a>
<a name="ln753">            }</a>
<a name="ln754">#ifndef QT_BOOTSTRAPPED</a>
<a name="ln755">            if (typeId == qMetaTypeId&lt;QByteArrayList&gt;()) {</a>
<a name="ln756">                return QSequentialIterable(QtMetaTypePrivate::QSequentialIterableImpl(reinterpret_cast&lt;const QByteArrayList*&gt;(v.constData())));</a>
<a name="ln757">            }</a>
<a name="ln758">#endif</a>
<a name="ln759">            return QSequentialIterable(v.value&lt;QtMetaTypePrivate::QSequentialIterableImpl&gt;());</a>
<a name="ln760">        }</a>
<a name="ln761">    };</a>
<a name="ln762">    template&lt;&gt;</a>
<a name="ln763">    struct QVariantValueHelperInterface&lt;QAssociativeIterable&gt;</a>
<a name="ln764">    {</a>
<a name="ln765">        static QAssociativeIterable invoke(const QVariant &amp;v)</a>
<a name="ln766">        {</a>
<a name="ln767">            const int typeId = v.userType();</a>
<a name="ln768">            if (typeId == qMetaTypeId&lt;QVariantMap&gt;()) {</a>
<a name="ln769">                return QAssociativeIterable(QtMetaTypePrivate::QAssociativeIterableImpl(reinterpret_cast&lt;const QVariantMap*&gt;(v.constData())));</a>
<a name="ln770">            }</a>
<a name="ln771">            if (typeId == qMetaTypeId&lt;QVariantHash&gt;()) {</a>
<a name="ln772">                return QAssociativeIterable(QtMetaTypePrivate::QAssociativeIterableImpl(reinterpret_cast&lt;const QVariantHash*&gt;(v.constData())));</a>
<a name="ln773">            }</a>
<a name="ln774">            return QAssociativeIterable(v.value&lt;QtMetaTypePrivate::QAssociativeIterableImpl&gt;());</a>
<a name="ln775">        }</a>
<a name="ln776">    };</a>
<a name="ln777">    template&lt;&gt;</a>
<a name="ln778">    struct QVariantValueHelperInterface&lt;QVariantList&gt;</a>
<a name="ln779">    {</a>
<a name="ln780">        static QVariantList invoke(const QVariant &amp;v)</a>
<a name="ln781">        {</a>
<a name="ln782">            const int typeId = v.userType();</a>
<a name="ln783">            if (typeId == qMetaTypeId&lt;QStringList&gt;() || typeId == qMetaTypeId&lt;QByteArrayList&gt;() || QMetaType::hasRegisteredConverterFunction(typeId, qMetaTypeId&lt;QtMetaTypePrivate::QSequentialIterableImpl&gt;())) {</a>
<a name="ln784">                QSequentialIterable iter = QVariantValueHelperInterface&lt;QSequentialIterable&gt;::invoke(v);</a>
<a name="ln785">                QVariantList l;</a>
<a name="ln786">                l.reserve(iter.size());</a>
<a name="ln787">                for (QSequentialIterable::const_iterator it = iter.begin(), end = iter.end(); it != end; ++it)</a>
<a name="ln788">                    l &lt;&lt; *it;</a>
<a name="ln789">                return l;</a>
<a name="ln790">            }</a>
<a name="ln791">            return QVariantValueHelper&lt;QVariantList&gt;::invoke(v);</a>
<a name="ln792">        }</a>
<a name="ln793">    };</a>
<a name="ln794">    template&lt;&gt;</a>
<a name="ln795">    struct QVariantValueHelperInterface&lt;QVariantHash&gt;</a>
<a name="ln796">    {</a>
<a name="ln797">        static QVariantHash invoke(const QVariant &amp;v)</a>
<a name="ln798">        {</a>
<a name="ln799">            const int typeId = v.userType();</a>
<a name="ln800">            if (typeId == qMetaTypeId&lt;QVariantMap&gt;() || QMetaType::hasRegisteredConverterFunction(typeId, qMetaTypeId&lt;QtMetaTypePrivate::QAssociativeIterableImpl&gt;())) {</a>
<a name="ln801">                QAssociativeIterable iter = QVariantValueHelperInterface&lt;QAssociativeIterable&gt;::invoke(v);</a>
<a name="ln802">                QVariantHash l;</a>
<a name="ln803">                l.reserve(iter.size());</a>
<a name="ln804">                for (QAssociativeIterable::const_iterator it = iter.begin(), end = iter.end(); it != end; ++it)</a>
<a name="ln805">                    l.insertMulti(it.key().toString(), it.value());</a>
<a name="ln806">                return l;</a>
<a name="ln807">            }</a>
<a name="ln808">            return QVariantValueHelper&lt;QVariantHash&gt;::invoke(v);</a>
<a name="ln809">        }</a>
<a name="ln810">    };</a>
<a name="ln811">    template&lt;&gt;</a>
<a name="ln812">    struct QVariantValueHelperInterface&lt;QVariantMap&gt;</a>
<a name="ln813">    {</a>
<a name="ln814">        static QVariantMap invoke(const QVariant &amp;v)</a>
<a name="ln815">        {</a>
<a name="ln816">            const int typeId = v.userType();</a>
<a name="ln817">            if (typeId == qMetaTypeId&lt;QVariantHash&gt;() || QMetaType::hasRegisteredConverterFunction(typeId, qMetaTypeId&lt;QtMetaTypePrivate::QAssociativeIterableImpl&gt;())) {</a>
<a name="ln818">                QAssociativeIterable iter = QVariantValueHelperInterface&lt;QAssociativeIterable&gt;::invoke(v);</a>
<a name="ln819">                QVariantMap l;</a>
<a name="ln820">                for (QAssociativeIterable::const_iterator it = iter.begin(), end = iter.end(); it != end; ++it)</a>
<a name="ln821">                    l.insertMulti(it.key().toString(), it.value());</a>
<a name="ln822">                return l;</a>
<a name="ln823">            }</a>
<a name="ln824">            return QVariantValueHelper&lt;QVariantMap&gt;::invoke(v);</a>
<a name="ln825">        }</a>
<a name="ln826">    };</a>
<a name="ln827">    template&lt;&gt;</a>
<a name="ln828">    struct QVariantValueHelperInterface&lt;QPair&lt;QVariant, QVariant&gt; &gt;</a>
<a name="ln829">    {</a>
<a name="ln830">        static QPair&lt;QVariant, QVariant&gt; invoke(const QVariant &amp;v)</a>
<a name="ln831">        {</a>
<a name="ln832">            const int typeId = v.userType();</a>
<a name="ln833">            if (typeId == qMetaTypeId&lt;QPair&lt;QVariant, QVariant&gt; &gt;())</a>
<a name="ln834">                return QVariantValueHelper&lt;QPair&lt;QVariant, QVariant&gt; &gt;::invoke(v);</a>
<a name="ln835"> </a>
<a name="ln836">            if (QMetaType::hasRegisteredConverterFunction(typeId, qMetaTypeId&lt;QtMetaTypePrivate::QPairVariantInterfaceImpl&gt;())) {</a>
<a name="ln837">                QtMetaTypePrivate::QPairVariantInterfaceImpl pi = v.value&lt;QtMetaTypePrivate::QPairVariantInterfaceImpl&gt;();</a>
<a name="ln838"> </a>
<a name="ln839">                const QtMetaTypePrivate::VariantData d1 = pi.first();</a>
<a name="ln840">                QVariant v1(d1.metaTypeId, d1.data, d1.flags);</a>
<a name="ln841">                if (d1.metaTypeId == qMetaTypeId&lt;QVariant&gt;())</a>
<a name="ln842">                    v1 = *reinterpret_cast&lt;const QVariant*&gt;(d1.data);</a>
<a name="ln843"> </a>
<a name="ln844">                const QtMetaTypePrivate::VariantData d2 = pi.second();</a>
<a name="ln845">                QVariant v2(d2.metaTypeId, d2.data, d2.flags);</a>
<a name="ln846">                if (d2.metaTypeId == qMetaTypeId&lt;QVariant&gt;())</a>
<a name="ln847">                    v2 = *reinterpret_cast&lt;const QVariant*&gt;(d2.data);</a>
<a name="ln848"> </a>
<a name="ln849">                return QPair&lt;QVariant, QVariant&gt;(v1, v2);</a>
<a name="ln850">            }</a>
<a name="ln851">            return QVariantValueHelper&lt;QPair&lt;QVariant, QVariant&gt; &gt;::invoke(v);</a>
<a name="ln852">        }</a>
<a name="ln853">    };</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">template&lt;typename T&gt; inline T qvariant_cast(const QVariant &amp;v)</a>
<a name="ln857">{</a>
<a name="ln858">    return QtPrivate::QVariantValueHelperInterface&lt;T&gt;::invoke(v);</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">template&lt;&gt; inline QVariant qvariant_cast&lt;QVariant&gt;(const QVariant &amp;v)</a>
<a name="ln862">{</a>
<a name="ln863">    if (v.userType() == QMetaType::QVariant)</a>
<a name="ln864">        return *reinterpret_cast&lt;const QVariant *&gt;(v.constData());</a>
<a name="ln865">    return v;</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">#if QT_DEPRECATED_SINCE(5, 0)</a>
<a name="ln869">template&lt;typename T&gt;</a>
<a name="ln870">inline QT_DEPRECATED T qVariantValue(const QVariant &amp;variant)</a>
<a name="ln871">{ return qvariant_cast&lt;T&gt;(variant); }</a>
<a name="ln872"> </a>
<a name="ln873">template&lt;typename T&gt;</a>
<a name="ln874">inline QT_DEPRECATED bool qVariantCanConvert(const QVariant &amp;variant)</a>
<a name="ln875">{ return variant.template canConvert&lt;T&gt;(); }</a>
<a name="ln876">#endif</a>
<a name="ln877"> </a>
<a name="ln878">#endif</a>
<a name="ln879"> </a>
<a name="ln880">#ifndef QT_NO_DEBUG_STREAM</a>
<a name="ln881">Q_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QVariant &amp;);</a>
<a name="ln882">Q_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QVariant::Type);</a>
<a name="ln883">#endif</a>
<a name="ln884"> </a>
<a name="ln885">QT_END_NAMESPACE</a>
<a name="ln886"> </a>
<a name="ln887">#endif // QVARIANT_H</a>

</code></pre>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: data.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
