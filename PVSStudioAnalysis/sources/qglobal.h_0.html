
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qglobal.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Copyright (C) 2016 Intel Corporation.</a>
<a name="ln5">** Contact: https://www.qt.io/licensing/</a>
<a name="ln6">**</a>
<a name="ln7">** This file is part of the QtCore module of the Qt Toolkit.</a>
<a name="ln8">**</a>
<a name="ln9">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln10">** Commercial License Usage</a>
<a name="ln11">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln12">** accordance with the commercial license agreement provided with the</a>
<a name="ln13">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln14">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln15">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln16">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln17">**</a>
<a name="ln18">** GNU Lesser General Public License Usage</a>
<a name="ln19">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln20">** General Public License version 3 as published by the Free Software</a>
<a name="ln21">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln22">** packaging of this file. Please review the following information to</a>
<a name="ln23">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln24">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln25">**</a>
<a name="ln26">** GNU General Public License Usage</a>
<a name="ln27">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln28">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln29">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln30">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln31">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln32">** included in the packaging of this file. Please review the following</a>
<a name="ln33">** information to ensure the GNU General Public License requirements will</a>
<a name="ln34">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln35">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln36">**</a>
<a name="ln37">** $QT_END_LICENSE$</a>
<a name="ln38">**</a>
<a name="ln39">****************************************************************************/</a>
<a name="ln40"> </a>
<a name="ln41">#ifndef QGLOBAL_H</a>
<a name="ln42">#define QGLOBAL_H</a>
<a name="ln43"> </a>
<a name="ln44">#ifdef __cplusplus</a>
<a name="ln45">#  include &lt;type_traits&gt;</a>
<a name="ln46">#  include &lt;cstddef&gt;</a>
<a name="ln47">#  include &lt;utility&gt;</a>
<a name="ln48">#endif</a>
<a name="ln49">#ifndef __ASSEMBLER__</a>
<a name="ln50">#  include &lt;assert.h&gt;</a>
<a name="ln51">#  include &lt;stddef.h&gt;</a>
<a name="ln52">#endif</a>
<a name="ln53"> </a>
<a name="ln54">/*</a>
<a name="ln55">   QT_VERSION is (major &lt;&lt; 16) + (minor &lt;&lt; 8) + patch.</a>
<a name="ln56">*/</a>
<a name="ln57">#define QT_VERSION      QT_VERSION_CHECK(QT_VERSION_MAJOR, QT_VERSION_MINOR, QT_VERSION_PATCH)</a>
<a name="ln58">/*</a>
<a name="ln59">   can be used like #if (QT_VERSION &gt;= QT_VERSION_CHECK(4, 4, 0))</a>
<a name="ln60">*/</a>
<a name="ln61">#define QT_VERSION_CHECK(major, minor, patch) ((major&lt;&lt;16)|(minor&lt;&lt;8)|(patch))</a>
<a name="ln62"> </a>
<a name="ln63">#ifdef QT_BOOTSTRAPPED</a>
<a name="ln64">#include &lt;QtCore/qconfig-bootstrapped.h&gt;</a>
<a name="ln65">#else</a>
<a name="ln66">#include &lt;QtCore/qconfig.h&gt;</a>
<a name="ln67">#include &lt;QtCore/qtcore-config.h&gt;</a>
<a name="ln68">#endif</a>
<a name="ln69"> </a>
<a name="ln70">// The QT_SUPPORTS macro is deprecated. Don't use it in new code.</a>
<a name="ln71">// Instead, use QT_CONFIG(feature)</a>
<a name="ln72">// ### Qt6: remove macro</a>
<a name="ln73">#ifdef _MSC_VER</a>
<a name="ln74">#  define QT_SUPPORTS(FEATURE) (!defined QT_NO_##FEATURE)</a>
<a name="ln75">#else</a>
<a name="ln76">#  define QT_SUPPORTS(FEATURE) (!defined(QT_NO_##FEATURE))</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">/*</a>
<a name="ln80">    The QT_CONFIG macro implements a safe compile time check for features of Qt.</a>
<a name="ln81">    Features can be in three states:</a>
<a name="ln82">        0 or undefined: This will lead to a compile error when testing for it</a>
<a name="ln83">        -1: The feature is not available</a>
<a name="ln84">        1: The feature is available</a>
<a name="ln85">*/</a>
<a name="ln86">#define QT_CONFIG(feature) (1/QT_FEATURE_##feature == 1)</a>
<a name="ln87">#define QT_REQUIRE_CONFIG(feature) Q_STATIC_ASSERT_X(QT_FEATURE_##feature == 1, &quot;Required feature &quot; #feature &quot; for file &quot; __FILE__ &quot; not available.&quot;)</a>
<a name="ln88"> </a>
<a name="ln89">#if QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0)</a>
<a name="ln90">#  define QT_NO_UNSHARABLE_CONTAINERS</a>
<a name="ln91">#  define QT6_VIRTUAL virtual</a>
<a name="ln92">#  define QT6_NOT_VIRTUAL</a>
<a name="ln93">#else</a>
<a name="ln94">#  define QT6_VIRTUAL</a>
<a name="ln95">#  define QT6_NOT_VIRTUAL virtual</a>
<a name="ln96">#endif</a>
<a name="ln97"> </a>
<a name="ln98">/* These two macros makes it possible to turn the builtin line expander into a</a>
<a name="ln99"> * string literal. */</a>
<a name="ln100">#define QT_STRINGIFY2(x) #x</a>
<a name="ln101">#define QT_STRINGIFY(x) QT_STRINGIFY2(x)</a>
<a name="ln102"> </a>
<a name="ln103">#include &lt;QtCore/qsystemdetection.h&gt;</a>
<a name="ln104">#include &lt;QtCore/qprocessordetection.h&gt;</a>
<a name="ln105">#include &lt;QtCore/qcompilerdetection.h&gt;</a>
<a name="ln106"> </a>
<a name="ln107">#if defined (__ELF__)</a>
<a name="ln108">#  define Q_OF_ELF</a>
<a name="ln109">#endif</a>
<a name="ln110">#if defined (__MACH__) &amp;&amp; defined (__APPLE__)</a>
<a name="ln111">#  define Q_OF_MACH_O</a>
<a name="ln112">#endif</a>
<a name="ln113"> </a>
<a name="ln114">/*</a>
<a name="ln115">   Avoid &quot;unused parameter&quot; warnings</a>
<a name="ln116">*/</a>
<a name="ln117">#define Q_UNUSED(x) (void)x;</a>
<a name="ln118"> </a>
<a name="ln119">#if defined(__cplusplus) &amp;&amp; defined(Q_COMPILER_STATIC_ASSERT)</a>
<a name="ln120">#  define Q_STATIC_ASSERT(Condition) static_assert(bool(Condition), #Condition)</a>
<a name="ln121">#  define Q_STATIC_ASSERT_X(Condition, Message) static_assert(bool(Condition), Message)</a>
<a name="ln122">#elif defined(Q_COMPILER_STATIC_ASSERT)</a>
<a name="ln123">// C11 mode - using the _S version in case &lt;assert.h&gt; doesn't do the right thing</a>
<a name="ln124">#  define Q_STATIC_ASSERT(Condition) _Static_assert(!!(Condition), #Condition)</a>
<a name="ln125">#  define Q_STATIC_ASSERT_X(Condition, Message) _Static_assert(!!(Condition), Message)</a>
<a name="ln126">#else</a>
<a name="ln127">// C89 &amp; C99 version</a>
<a name="ln128">#  define Q_STATIC_ASSERT_PRIVATE_JOIN(A, B) Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL(A, B)</a>
<a name="ln129">#  define Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL(A, B) A ## B</a>
<a name="ln130">#  ifdef __COUNTER__</a>
<a name="ln131">#  define Q_STATIC_ASSERT(Condition) \</a>
<a name="ln132">    typedef char Q_STATIC_ASSERT_PRIVATE_JOIN(q_static_assert_result, __COUNTER__) [(Condition) ? 1 : -1];</a>
<a name="ln133">#  else</a>
<a name="ln134">#  define Q_STATIC_ASSERT(Condition) \</a>
<a name="ln135">    typedef char Q_STATIC_ASSERT_PRIVATE_JOIN(q_static_assert_result, __LINE__) [(Condition) ? 1 : -1];</a>
<a name="ln136">#  endif /* __COUNTER__ */</a>
<a name="ln137">#  define Q_STATIC_ASSERT_X(Condition, Message) Q_STATIC_ASSERT(Condition)</a>
<a name="ln138">#endif</a>
<a name="ln139"> </a>
<a name="ln140">#ifdef __cplusplus</a>
<a name="ln141"> </a>
<a name="ln142">#include &lt;algorithm&gt;</a>
<a name="ln143"> </a>
<a name="ln144">#if !defined(QT_NAMESPACE) || defined(Q_MOC_RUN) /* user namespace */</a>
<a name="ln145"> </a>
<a name="ln146"># define QT_PREPEND_NAMESPACE(name) ::name</a>
<a name="ln147"># define QT_USE_NAMESPACE</a>
<a name="ln148"># define QT_BEGIN_NAMESPACE</a>
<a name="ln149"># define QT_END_NAMESPACE</a>
<a name="ln150"># define QT_BEGIN_INCLUDE_NAMESPACE</a>
<a name="ln151"># define QT_END_INCLUDE_NAMESPACE</a>
<a name="ln152">#ifndef QT_BEGIN_MOC_NAMESPACE</a>
<a name="ln153"># define QT_BEGIN_MOC_NAMESPACE</a>
<a name="ln154">#endif</a>
<a name="ln155">#ifndef QT_END_MOC_NAMESPACE</a>
<a name="ln156"># define QT_END_MOC_NAMESPACE</a>
<a name="ln157">#endif</a>
<a name="ln158"># define QT_FORWARD_DECLARE_CLASS(name) class name;</a>
<a name="ln159"># define QT_FORWARD_DECLARE_STRUCT(name) struct name;</a>
<a name="ln160"># define QT_MANGLE_NAMESPACE(name) name</a>
<a name="ln161"> </a>
<a name="ln162">#else /* user namespace */</a>
<a name="ln163"> </a>
<a name="ln164"># define QT_PREPEND_NAMESPACE(name) ::QT_NAMESPACE::name</a>
<a name="ln165"># define QT_USE_NAMESPACE using namespace ::QT_NAMESPACE;</a>
<a name="ln166"># define QT_BEGIN_NAMESPACE namespace QT_NAMESPACE {</a>
<a name="ln167"># define QT_END_NAMESPACE }</a>
<a name="ln168"># define QT_BEGIN_INCLUDE_NAMESPACE }</a>
<a name="ln169"># define QT_END_INCLUDE_NAMESPACE namespace QT_NAMESPACE {</a>
<a name="ln170">#ifndef QT_BEGIN_MOC_NAMESPACE</a>
<a name="ln171"># define QT_BEGIN_MOC_NAMESPACE QT_USE_NAMESPACE</a>
<a name="ln172">#endif</a>
<a name="ln173">#ifndef QT_END_MOC_NAMESPACE</a>
<a name="ln174"># define QT_END_MOC_NAMESPACE</a>
<a name="ln175">#endif</a>
<a name="ln176"># define QT_FORWARD_DECLARE_CLASS(name) \</a>
<a name="ln177">    QT_BEGIN_NAMESPACE class name; QT_END_NAMESPACE \</a>
<a name="ln178">    using QT_PREPEND_NAMESPACE(name);</a>
<a name="ln179"> </a>
<a name="ln180"># define QT_FORWARD_DECLARE_STRUCT(name) \</a>
<a name="ln181">    QT_BEGIN_NAMESPACE struct name; QT_END_NAMESPACE \</a>
<a name="ln182">    using QT_PREPEND_NAMESPACE(name);</a>
<a name="ln183"> </a>
<a name="ln184"># define QT_MANGLE_NAMESPACE0(x) x</a>
<a name="ln185"># define QT_MANGLE_NAMESPACE1(a, b) a##_##b</a>
<a name="ln186"># define QT_MANGLE_NAMESPACE2(a, b) QT_MANGLE_NAMESPACE1(a,b)</a>
<a name="ln187"># define QT_MANGLE_NAMESPACE(name) QT_MANGLE_NAMESPACE2( \</a>
<a name="ln188">        QT_MANGLE_NAMESPACE0(name), QT_MANGLE_NAMESPACE0(QT_NAMESPACE))</a>
<a name="ln189"> </a>
<a name="ln190">namespace QT_NAMESPACE {}</a>
<a name="ln191"> </a>
<a name="ln192"># ifndef QT_BOOTSTRAPPED</a>
<a name="ln193"># ifndef QT_NO_USING_NAMESPACE</a>
<a name="ln194">   /*</a>
<a name="ln195">    This expands to a &quot;using QT_NAMESPACE&quot; also in _header files_.</a>
<a name="ln196">    It is the only way the feature can be used without too much</a>
<a name="ln197">    pain, but if people _really_ do not want it they can add</a>
<a name="ln198">    DEFINES += QT_NO_USING_NAMESPACE to their .pro files.</a>
<a name="ln199">    */</a>
<a name="ln200">   QT_USE_NAMESPACE</a>
<a name="ln201"># endif</a>
<a name="ln202"># endif</a>
<a name="ln203"> </a>
<a name="ln204">#endif /* user namespace */</a>
<a name="ln205"> </a>
<a name="ln206">#else /* __cplusplus */</a>
<a name="ln207"> </a>
<a name="ln208"># define QT_BEGIN_NAMESPACE</a>
<a name="ln209"># define QT_END_NAMESPACE</a>
<a name="ln210"># define QT_USE_NAMESPACE</a>
<a name="ln211"># define QT_BEGIN_INCLUDE_NAMESPACE</a>
<a name="ln212"># define QT_END_INCLUDE_NAMESPACE</a>
<a name="ln213"> </a>
<a name="ln214">#endif /* __cplusplus */</a>
<a name="ln215"> </a>
<a name="ln216">// ### Qt6: remove me.</a>
<a name="ln217">#define QT_BEGIN_HEADER</a>
<a name="ln218">#define QT_END_HEADER</a>
<a name="ln219"> </a>
<a name="ln220">#if defined(Q_OS_DARWIN) &amp;&amp; !defined(QT_LARGEFILE_SUPPORT)</a>
<a name="ln221">#  define QT_LARGEFILE_SUPPORT 64</a>
<a name="ln222">#endif</a>
<a name="ln223"> </a>
<a name="ln224">#ifndef __ASSEMBLER__</a>
<a name="ln225">QT_BEGIN_NAMESPACE</a>
<a name="ln226"> </a>
<a name="ln227">/*</a>
<a name="ln228">   Size-dependent types (architechture-dependent byte order)</a>
<a name="ln229"> </a>
<a name="ln230">   Make sure to update QMetaType when changing these typedefs</a>
<a name="ln231">*/</a>
<a name="ln232"> </a>
<a name="ln233">typedef signed char qint8;         /* 8 bit signed */</a>
<a name="ln234">typedef unsigned char quint8;      /* 8 bit unsigned */</a>
<a name="ln235">typedef short qint16;              /* 16 bit signed */</a>
<a name="ln236">typedef unsigned short quint16;    /* 16 bit unsigned */</a>
<a name="ln237">typedef int qint32;                /* 32 bit signed */</a>
<a name="ln238">typedef unsigned int quint32;      /* 32 bit unsigned */</a>
<a name="ln239">#if defined(Q_OS_WIN) &amp;&amp; !defined(Q_CC_GNU)</a>
<a name="ln240">#  define Q_INT64_C(c) c ## i64    /* signed 64 bit constant */</a>
<a name="ln241">#  define Q_UINT64_C(c) c ## ui64   /* unsigned 64 bit constant */</a>
<a name="ln242">typedef __int64 qint64;            /* 64 bit signed */</a>
<a name="ln243">typedef unsigned __int64 quint64;  /* 64 bit unsigned */</a>
<a name="ln244">#else</a>
<a name="ln245">#ifdef __cplusplus</a>
<a name="ln246">#  define Q_INT64_C(c) static_cast&lt;long long&gt;(c ## LL)     /* signed 64 bit constant */</a>
<a name="ln247">#  define Q_UINT64_C(c) static_cast&lt;unsigned long long&gt;(c ## ULL) /* unsigned 64 bit constant */</a>
<a name="ln248">#else</a>
<a name="ln249">#  define Q_INT64_C(c) ((long long)(c ## LL))               /* signed 64 bit constant */</a>
<a name="ln250">#  define Q_UINT64_C(c) ((unsigned long long)(c ## ULL))    /* unsigned 64 bit constant */</a>
<a name="ln251">#endif</a>
<a name="ln252">typedef long long qint64;           /* 64 bit signed */</a>
<a name="ln253">typedef unsigned long long quint64; /* 64 bit unsigned */</a>
<a name="ln254">#endif</a>
<a name="ln255"> </a>
<a name="ln256">typedef qint64 qlonglong;</a>
<a name="ln257">typedef quint64 qulonglong;</a>
<a name="ln258"> </a>
<a name="ln259">#ifndef __cplusplus</a>
<a name="ln260">// In C++ mode, we define below using QIntegerForSize template</a>
<a name="ln261">Q_STATIC_ASSERT_X(sizeof(ptrdiff_t) == sizeof(size_t), &quot;Weird ptrdiff_t and size_t definitions&quot;);</a>
<a name="ln262">typedef ptrdiff_t qptrdiff;</a>
<a name="ln263">typedef ptrdiff_t qsizetype;</a>
<a name="ln264">typedef ptrdiff_t qintptr;</a>
<a name="ln265">typedef size_t quintptr;</a>
<a name="ln266">#endif</a>
<a name="ln267"> </a>
<a name="ln268">/*</a>
<a name="ln269">   Useful type definitions for Qt</a>
<a name="ln270">*/</a>
<a name="ln271"> </a>
<a name="ln272">QT_BEGIN_INCLUDE_NAMESPACE</a>
<a name="ln273">typedef unsigned char uchar;</a>
<a name="ln274">typedef unsigned short ushort;</a>
<a name="ln275">typedef unsigned int uint;</a>
<a name="ln276">typedef unsigned long ulong;</a>
<a name="ln277">QT_END_INCLUDE_NAMESPACE</a>
<a name="ln278"> </a>
<a name="ln279">#if defined(QT_COORD_TYPE)</a>
<a name="ln280">typedef QT_COORD_TYPE qreal;</a>
<a name="ln281">#else</a>
<a name="ln282">typedef double qreal;</a>
<a name="ln283">#endif</a>
<a name="ln284"> </a>
<a name="ln285">#if defined(QT_NO_DEPRECATED)</a>
<a name="ln286">#  undef QT_DEPRECATED</a>
<a name="ln287">#  undef QT_DEPRECATED_X</a>
<a name="ln288">#  undef QT_DEPRECATED_VARIABLE</a>
<a name="ln289">#  undef QT_DEPRECATED_CONSTRUCTOR</a>
<a name="ln290">#elif defined(QT_DEPRECATED_WARNINGS)</a>
<a name="ln291">#  undef QT_DEPRECATED</a>
<a name="ln292">#  define QT_DEPRECATED Q_DECL_DEPRECATED</a>
<a name="ln293">#  undef QT_DEPRECATED_X</a>
<a name="ln294">#  define QT_DEPRECATED_X(text) Q_DECL_DEPRECATED_X(text)</a>
<a name="ln295">#  undef QT_DEPRECATED_VARIABLE</a>
<a name="ln296">#  define QT_DEPRECATED_VARIABLE Q_DECL_VARIABLE_DEPRECATED</a>
<a name="ln297">#  undef QT_DEPRECATED_CONSTRUCTOR</a>
<a name="ln298">#  define QT_DEPRECATED_CONSTRUCTOR explicit Q_DECL_CONSTRUCTOR_DEPRECATED</a>
<a name="ln299">#else</a>
<a name="ln300">#  undef QT_DEPRECATED</a>
<a name="ln301">#  define QT_DEPRECATED</a>
<a name="ln302">#  undef QT_DEPRECATED_X</a>
<a name="ln303">#  define QT_DEPRECATED_X(text)</a>
<a name="ln304">#  undef QT_DEPRECATED_VARIABLE</a>
<a name="ln305">#  define QT_DEPRECATED_VARIABLE</a>
<a name="ln306">#  undef QT_DEPRECATED_CONSTRUCTOR</a>
<a name="ln307">#  define QT_DEPRECATED_CONSTRUCTOR</a>
<a name="ln308">#endif</a>
<a name="ln309"> </a>
<a name="ln310">#ifndef QT_DISABLE_DEPRECATED_BEFORE</a>
<a name="ln311">#define QT_DISABLE_DEPRECATED_BEFORE QT_VERSION_CHECK(5, 0, 0)</a>
<a name="ln312">#endif</a>
<a name="ln313"> </a>
<a name="ln314">/*</a>
<a name="ln315">    QT_DEPRECATED_SINCE(major, minor) evaluates as true if the Qt version is greater than</a>
<a name="ln316">    the deprecation point specified.</a>
<a name="ln317"> </a>
<a name="ln318">    Use it to specify from which version of Qt a function or class has been deprecated</a>
<a name="ln319"> </a>
<a name="ln320">    Example:</a>
<a name="ln321">        #if QT_DEPRECATED_SINCE(5,1)</a>
<a name="ln322">            QT_DEPRECATED void deprecatedFunction(); //function deprecated since Qt 5.1</a>
<a name="ln323">        #endif</a>
<a name="ln324"> </a>
<a name="ln325">*/</a>
<a name="ln326">#ifdef QT_DEPRECATED</a>
<a name="ln327">#define QT_DEPRECATED_SINCE(major, minor) (QT_VERSION_CHECK(major, minor, 0) &gt; QT_DISABLE_DEPRECATED_BEFORE)</a>
<a name="ln328">#else</a>
<a name="ln329">#define QT_DEPRECATED_SINCE(major, minor) 0</a>
<a name="ln330">#endif</a>
<a name="ln331"> </a>
<a name="ln332">/*</a>
<a name="ln333">   The Qt modules' export macros.</a>
<a name="ln334">   The options are:</a>
<a name="ln335">    - defined(QT_STATIC): Qt was built or is being built in static mode</a>
<a name="ln336">    - defined(QT_SHARED): Qt was built or is being built in shared/dynamic mode</a>
<a name="ln337">   If neither was defined, then QT_SHARED is implied. If Qt was compiled in static</a>
<a name="ln338">   mode, QT_STATIC is defined in qconfig.h. In shared mode, QT_STATIC is implied</a>
<a name="ln339">   for the bootstrapped tools.</a>
<a name="ln340">*/</a>
<a name="ln341"> </a>
<a name="ln342">#ifdef QT_BOOTSTRAPPED</a>
<a name="ln343">#  ifdef QT_SHARED</a>
<a name="ln344">#    error &quot;QT_SHARED and QT_BOOTSTRAPPED together don't make sense. Please fix the build&quot;</a>
<a name="ln345">#  elif !defined(QT_STATIC)</a>
<a name="ln346">#    define QT_STATIC</a>
<a name="ln347">#  endif</a>
<a name="ln348">#endif</a>
<a name="ln349"> </a>
<a name="ln350">#if defined(QT_SHARED) || !defined(QT_STATIC)</a>
<a name="ln351">#  ifdef QT_STATIC</a>
<a name="ln352">#    error &quot;Both QT_SHARED and QT_STATIC defined, please make up your mind&quot;</a>
<a name="ln353">#  endif</a>
<a name="ln354">#  ifndef QT_SHARED</a>
<a name="ln355">#    define QT_SHARED</a>
<a name="ln356">#  endif</a>
<a name="ln357">#  if defined(QT_BUILD_CORE_LIB)</a>
<a name="ln358">#    define Q_CORE_EXPORT Q_DECL_EXPORT</a>
<a name="ln359">#  else</a>
<a name="ln360">#    define Q_CORE_EXPORT Q_DECL_IMPORT</a>
<a name="ln361">#  endif</a>
<a name="ln362">#else</a>
<a name="ln363">#  define Q_CORE_EXPORT</a>
<a name="ln364">#endif</a>
<a name="ln365"> </a>
<a name="ln366">/*</a>
<a name="ln367">   Some classes do not permit copies to be made of an object. These</a>
<a name="ln368">   classes contains a private copy constructor and assignment</a>
<a name="ln369">   operator to disable copying (the compiler gives an error message).</a>
<a name="ln370">*/</a>
<a name="ln371">#define Q_DISABLE_COPY(Class) \</a>
<a name="ln372">    Class(const Class &amp;) Q_DECL_EQ_DELETE;\</a>
<a name="ln373">    Class &amp;operator=(const Class &amp;) Q_DECL_EQ_DELETE;</a>
<a name="ln374"> </a>
<a name="ln375">/*</a>
<a name="ln376">   No, this is not an evil backdoor. QT_BUILD_INTERNAL just exports more symbols</a>
<a name="ln377">   for Qt's internal unit tests. If you want slower loading times and more</a>
<a name="ln378">   symbols that can vanish from version to version, feel free to define QT_BUILD_INTERNAL.</a>
<a name="ln379">*/</a>
<a name="ln380">#if defined(QT_BUILD_INTERNAL) &amp;&amp; defined(QT_BUILDING_QT) &amp;&amp; defined(QT_SHARED)</a>
<a name="ln381">#    define Q_AUTOTEST_EXPORT Q_DECL_EXPORT</a>
<a name="ln382">#elif defined(QT_BUILD_INTERNAL) &amp;&amp; defined(QT_SHARED)</a>
<a name="ln383">#    define Q_AUTOTEST_EXPORT Q_DECL_IMPORT</a>
<a name="ln384">#else</a>
<a name="ln385">#    define Q_AUTOTEST_EXPORT</a>
<a name="ln386">#endif</a>
<a name="ln387"> </a>
<a name="ln388">#define Q_INIT_RESOURCE(name) \</a>
<a name="ln389">    do { extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) ();       \</a>
<a name="ln390">        QT_MANGLE_NAMESPACE(qInitResources_ ## name) (); } while (false)</a>
<a name="ln391">#define Q_CLEANUP_RESOURCE(name) \</a>
<a name="ln392">    do { extern int QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) ();    \</a>
<a name="ln393">        QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) (); } while (false)</a>
<a name="ln394"> </a>
<a name="ln395">/*</a>
<a name="ln396"> * If we're compiling C++ code:</a>
<a name="ln397"> *  - and this is a non-namespace build, declare qVersion as extern &quot;C&quot;</a>
<a name="ln398"> *  - and this is a namespace build, declare it as a regular function</a>
<a name="ln399"> *    (we're already inside QT_BEGIN_NAMESPACE / QT_END_NAMESPACE)</a>
<a name="ln400"> * If we're compiling C code, simply declare the function. If Qt was compiled</a>
<a name="ln401"> * in a namespace, qVersion isn't callable anyway.</a>
<a name="ln402"> */</a>
<a name="ln403">#if !defined(QT_NAMESPACE) &amp;&amp; defined(__cplusplus) &amp;&amp; !defined(Q_QDOC)</a>
<a name="ln404">extern &quot;C&quot;</a>
<a name="ln405">#endif</a>
<a name="ln406">Q_CORE_EXPORT Q_DECL_CONST_FUNCTION const char *qVersion(void) Q_DECL_NOTHROW;</a>
<a name="ln407"> </a>
<a name="ln408">#if defined(__cplusplus)</a>
<a name="ln409"> </a>
<a name="ln410">#ifndef Q_CONSTRUCTOR_FUNCTION</a>
<a name="ln411"># define Q_CONSTRUCTOR_FUNCTION0(AFUNC) \</a>
<a name="ln412">    namespace { \</a>
<a name="ln413">    static const struct AFUNC ## _ctor_class_ { \</a>
<a name="ln414">        inline AFUNC ## _ctor_class_() { AFUNC(); } \</a>
<a name="ln415">    } AFUNC ## _ctor_instance_; \</a>
<a name="ln416">    }</a>
<a name="ln417"> </a>
<a name="ln418"># define Q_CONSTRUCTOR_FUNCTION(AFUNC) Q_CONSTRUCTOR_FUNCTION0(AFUNC)</a>
<a name="ln419">#endif</a>
<a name="ln420"> </a>
<a name="ln421">#ifndef Q_DESTRUCTOR_FUNCTION</a>
<a name="ln422"># define Q_DESTRUCTOR_FUNCTION0(AFUNC) \</a>
<a name="ln423">    namespace { \</a>
<a name="ln424">    static const struct AFUNC ## _dtor_class_ { \</a>
<a name="ln425">        inline AFUNC ## _dtor_class_() { } \</a>
<a name="ln426">        inline ~ AFUNC ## _dtor_class_() { AFUNC(); } \</a>
<a name="ln427">    } AFUNC ## _dtor_instance_; \</a>
<a name="ln428">    }</a>
<a name="ln429"># define Q_DESTRUCTOR_FUNCTION(AFUNC) Q_DESTRUCTOR_FUNCTION0(AFUNC)</a>
<a name="ln430">#endif</a>
<a name="ln431"> </a>
<a name="ln432">namespace QtPrivate {</a>
<a name="ln433">    template &lt;class T&gt;</a>
<a name="ln434">    struct AlignOfHelper</a>
<a name="ln435">    {</a>
<a name="ln436">        char c;</a>
<a name="ln437">        T type;</a>
<a name="ln438"> </a>
<a name="ln439">        AlignOfHelper();</a>
<a name="ln440">        ~AlignOfHelper();</a>
<a name="ln441">    };</a>
<a name="ln442"> </a>
<a name="ln443">    template &lt;class T&gt;</a>
<a name="ln444">    struct AlignOf_Default</a>
<a name="ln445">    {</a>
<a name="ln446">        enum { Value = sizeof(AlignOfHelper&lt;T&gt;) - sizeof(T) };</a>
<a name="ln447">    };</a>
<a name="ln448"> </a>
<a name="ln449">    template &lt;class T&gt; struct AlignOf : AlignOf_Default&lt;T&gt; { };</a>
<a name="ln450">    template &lt;class T&gt; struct AlignOf&lt;T &amp;&gt; : AlignOf&lt;T&gt; {};</a>
<a name="ln451">    template &lt;size_t N, class T&gt; struct AlignOf&lt;T[N]&gt; : AlignOf&lt;T&gt; {};</a>
<a name="ln452"> </a>
<a name="ln453">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln454">    template &lt;class T&gt; struct AlignOf&lt;T &amp;&amp;&gt; : AlignOf&lt;T&gt; {};</a>
<a name="ln455">#endif</a>
<a name="ln456"> </a>
<a name="ln457">#if defined(Q_PROCESSOR_X86_32) &amp;&amp; !defined(Q_OS_WIN)</a>
<a name="ln458">    template &lt;class T&gt; struct AlignOf_WorkaroundForI386Abi { enum { Value = sizeof(T) }; };</a>
<a name="ln459"> </a>
<a name="ln460">    // x86 ABI weirdness</a>
<a name="ln461">    // Alignment of naked type is 8, but inside struct has alignment 4.</a>
<a name="ln462">    template &lt;&gt; struct AlignOf&lt;double&gt;  : AlignOf_WorkaroundForI386Abi&lt;double&gt; {};</a>
<a name="ln463">    template &lt;&gt; struct AlignOf&lt;qint64&gt;  : AlignOf_WorkaroundForI386Abi&lt;qint64&gt; {};</a>
<a name="ln464">    template &lt;&gt; struct AlignOf&lt;quint64&gt; : AlignOf_WorkaroundForI386Abi&lt;quint64&gt; {};</a>
<a name="ln465">#ifdef Q_CC_CLANG</a>
<a name="ln466">    // GCC and Clang seem to disagree wrt to alignment of arrays</a>
<a name="ln467">    template &lt;size_t N&gt; struct AlignOf&lt;double[N]&gt;   : AlignOf_Default&lt;double&gt; {};</a>
<a name="ln468">    template &lt;size_t N&gt; struct AlignOf&lt;qint64[N]&gt;   : AlignOf_Default&lt;qint64&gt; {};</a>
<a name="ln469">    template &lt;size_t N&gt; struct AlignOf&lt;quint64[N]&gt;  : AlignOf_Default&lt;quint64&gt; {};</a>
<a name="ln470">#endif</a>
<a name="ln471">#endif</a>
<a name="ln472">} // namespace QtPrivate</a>
<a name="ln473"> </a>
<a name="ln474">#define QT_EMULATED_ALIGNOF(T) \</a>
<a name="ln475">    (size_t(QT_PREPEND_NAMESPACE(QtPrivate)::AlignOf&lt;T&gt;::Value))</a>
<a name="ln476"> </a>
<a name="ln477">#ifndef Q_ALIGNOF</a>
<a name="ln478">#define Q_ALIGNOF(T) QT_EMULATED_ALIGNOF(T)</a>
<a name="ln479">#endif</a>
<a name="ln480"> </a>
<a name="ln481"> </a>
<a name="ln482">/*</a>
<a name="ln483">  quintptr and qptrdiff is guaranteed to be the same size as a pointer, i.e.</a>
<a name="ln484"> </a>
<a name="ln485">      sizeof(void *) == sizeof(quintptr)</a>
<a name="ln486">      &amp;&amp; sizeof(void *) == sizeof(qptrdiff)</a>
<a name="ln487"> </a>
<a name="ln488">  size_t and qsizetype are not guaranteed to be the same size as a pointer, but</a>
<a name="ln489">  they usually are.</a>
<a name="ln490">*/</a>
<a name="ln491">template &lt;int&gt; struct QIntegerForSize;</a>
<a name="ln492">template &lt;&gt;    struct QIntegerForSize&lt;1&gt; { typedef quint8  Unsigned; typedef qint8  Signed; };</a>
<a name="ln493">template &lt;&gt;    struct QIntegerForSize&lt;2&gt; { typedef quint16 Unsigned; typedef qint16 Signed; };</a>
<a name="ln494">template &lt;&gt;    struct QIntegerForSize&lt;4&gt; { typedef quint32 Unsigned; typedef qint32 Signed; };</a>
<a name="ln495">template &lt;&gt;    struct QIntegerForSize&lt;8&gt; { typedef quint64 Unsigned; typedef qint64 Signed; };</a>
<a name="ln496">#if defined(Q_CC_GNU) &amp;&amp; defined(__SIZEOF_INT128__)</a>
<a name="ln497">template &lt;&gt;    struct QIntegerForSize&lt;16&gt; { __extension__ typedef unsigned __int128 Unsigned; __extension__ typedef __int128 Signed; };</a>
<a name="ln498">#endif</a>
<a name="ln499">template &lt;class T&gt; struct QIntegerForSizeof: QIntegerForSize&lt;sizeof(T)&gt; { };</a>
<a name="ln500">typedef QIntegerForSize&lt;Q_PROCESSOR_WORDSIZE&gt;::Signed qregisterint;</a>
<a name="ln501">typedef QIntegerForSize&lt;Q_PROCESSOR_WORDSIZE&gt;::Unsigned qregisteruint;</a>
<a name="ln502">typedef QIntegerForSizeof&lt;void*&gt;::Unsigned quintptr;</a>
<a name="ln503">typedef QIntegerForSizeof&lt;void*&gt;::Signed qptrdiff;</a>
<a name="ln504">typedef qptrdiff qintptr;</a>
<a name="ln505">using qsizetype = QIntegerForSizeof&lt;std::size_t&gt;::Signed;</a>
<a name="ln506"> </a>
<a name="ln507">/* moc compats (signals/slots) */</a>
<a name="ln508">#ifndef QT_MOC_COMPAT</a>
<a name="ln509">#  define QT_MOC_COMPAT</a>
<a name="ln510">#else</a>
<a name="ln511">#  undef QT_MOC_COMPAT</a>
<a name="ln512">#  define QT_MOC_COMPAT</a>
<a name="ln513">#endif</a>
<a name="ln514"> </a>
<a name="ln515">#ifdef QT_ASCII_CAST_WARNINGS</a>
<a name="ln516">#  define QT_ASCII_CAST_WARN Q_DECL_DEPRECATED_X(&quot;Use fromUtf8, QStringLiteral, or QLatin1String&quot;)</a>
<a name="ln517">#else</a>
<a name="ln518">#  define QT_ASCII_CAST_WARN</a>
<a name="ln519">#endif</a>
<a name="ln520"> </a>
<a name="ln521">#ifdef Q_PROCESSOR_X86_32</a>
<a name="ln522">#  if defined(Q_CC_GNU)</a>
<a name="ln523">#    define QT_FASTCALL __attribute__((regparm(3)))</a>
<a name="ln524">#  elif defined(Q_CC_MSVC)</a>
<a name="ln525">#    define QT_FASTCALL __fastcall</a>
<a name="ln526">#  else</a>
<a name="ln527">#     define QT_FASTCALL</a>
<a name="ln528">#  endif</a>
<a name="ln529">#else</a>
<a name="ln530">#  define QT_FASTCALL</a>
<a name="ln531">#endif</a>
<a name="ln532"> </a>
<a name="ln533">// enable gcc warnings for printf-style functions</a>
<a name="ln534">#if defined(Q_CC_GNU) &amp;&amp; !defined(__INSURE__)</a>
<a name="ln535">#  if defined(Q_CC_MINGW) &amp;&amp; !defined(Q_CC_CLANG)</a>
<a name="ln536">#    define Q_ATTRIBUTE_FORMAT_PRINTF(A, B) \</a>
<a name="ln537">         __attribute__((format(gnu_printf, (A), (B))))</a>
<a name="ln538">#  else</a>
<a name="ln539">#    define Q_ATTRIBUTE_FORMAT_PRINTF(A, B) \</a>
<a name="ln540">         __attribute__((format(printf, (A), (B))))</a>
<a name="ln541">#  endif</a>
<a name="ln542">#else</a>
<a name="ln543">#  define Q_ATTRIBUTE_FORMAT_PRINTF(A, B)</a>
<a name="ln544">#endif</a>
<a name="ln545"> </a>
<a name="ln546">#ifdef Q_CC_MSVC</a>
<a name="ln547">#  define Q_NEVER_INLINE __declspec(noinline)</a>
<a name="ln548">#  define Q_ALWAYS_INLINE __forceinline</a>
<a name="ln549">#elif defined(Q_CC_GNU)</a>
<a name="ln550">#  define Q_NEVER_INLINE __attribute__((noinline))</a>
<a name="ln551">#  define Q_ALWAYS_INLINE inline __attribute__((always_inline))</a>
<a name="ln552">#else</a>
<a name="ln553">#  define Q_NEVER_INLINE</a>
<a name="ln554">#  define Q_ALWAYS_INLINE inline</a>
<a name="ln555">#endif</a>
<a name="ln556"> </a>
<a name="ln557">#if defined(Q_CC_GNU) &amp;&amp; defined(Q_OS_WIN)</a>
<a name="ln558">#  define QT_INIT_METAOBJECT __attribute__((init_priority(101)))</a>
<a name="ln559">#else</a>
<a name="ln560">#  define QT_INIT_METAOBJECT</a>
<a name="ln561">#endif</a>
<a name="ln562"> </a>
<a name="ln563">//defines the type for the WNDPROC on windows</a>
<a name="ln564">//the alignment needs to be forced for sse2 to not crash with mingw</a>
<a name="ln565">#if defined(Q_OS_WIN)</a>
<a name="ln566">#  if defined(Q_CC_MINGW) &amp;&amp; !defined(Q_OS_WIN64)</a>
<a name="ln567">#    define QT_ENSURE_STACK_ALIGNED_FOR_SSE __attribute__ ((force_align_arg_pointer))</a>
<a name="ln568">#  else</a>
<a name="ln569">#    define QT_ENSURE_STACK_ALIGNED_FOR_SSE</a>
<a name="ln570">#  endif</a>
<a name="ln571">#  define QT_WIN_CALLBACK CALLBACK QT_ENSURE_STACK_ALIGNED_FOR_SSE</a>
<a name="ln572">#endif</a>
<a name="ln573"> </a>
<a name="ln574">typedef int QNoImplicitBoolCast;</a>
<a name="ln575"> </a>
<a name="ln576">/*</a>
<a name="ln577">   Utility macros and inline functions</a>
<a name="ln578">*/</a>
<a name="ln579"> </a>
<a name="ln580">template &lt;typename T&gt;</a>
<a name="ln581">Q_DECL_CONSTEXPR inline T qAbs(const T &amp;t) { return t &gt;= 0 ? t : -t; }</a>
<a name="ln582"> </a>
<a name="ln583">Q_DECL_CONSTEXPR inline int qRound(double d)</a>
<a name="ln584">{ return d &gt;= 0.0 ? int(d + 0.5) : int(d - double(int(d-1)) + 0.5) + int(d-1); }</a>
<a name="ln585">Q_DECL_CONSTEXPR inline int qRound(float d)</a>
<a name="ln586">{ return d &gt;= 0.0f ? int(d + 0.5f) : int(d - float(int(d-1)) + 0.5f) + int(d-1); }</a>
<a name="ln587"> </a>
<a name="ln588">Q_DECL_CONSTEXPR inline qint64 qRound64(double d)</a>
<a name="ln589">{ return d &gt;= 0.0 ? qint64(d + 0.5) : qint64(d - double(qint64(d-1)) + 0.5) + qint64(d-1); }</a>
<a name="ln590">Q_DECL_CONSTEXPR inline qint64 qRound64(float d)</a>
<a name="ln591">{ return d &gt;= 0.0f ? qint64(d + 0.5f) : qint64(d - float(qint64(d-1)) + 0.5f) + qint64(d-1); }</a>
<a name="ln592"> </a>
<a name="ln593">template &lt;typename T&gt;</a>
<a name="ln594">Q_DECL_CONSTEXPR inline const T &amp;qMin(const T &amp;a, const T &amp;b) { return (a &lt; b) ? a : b; }</a>
<a name="ln595">template &lt;typename T&gt;</a>
<a name="ln596">Q_DECL_CONSTEXPR inline const T &amp;qMax(const T &amp;a, const T &amp;b) { return (a &lt; b) ? b : a; }</a>
<a name="ln597">template &lt;typename T&gt;</a>
<a name="ln598">Q_DECL_CONSTEXPR inline const T &amp;qBound(const T &amp;min, const T &amp;val, const T &amp;max)</a>
<a name="ln599">{ return qMax(min, qMin(max, val)); }</a>
<a name="ln600"> </a>
<a name="ln601">#ifndef Q_FORWARD_DECLARE_OBJC_CLASS</a>
<a name="ln602">#  ifdef __OBJC__</a>
<a name="ln603">#    define Q_FORWARD_DECLARE_OBJC_CLASS(classname) @class classname</a>
<a name="ln604">#  else</a>
<a name="ln605">#    define Q_FORWARD_DECLARE_OBJC_CLASS(classname) typedef struct objc_object classname</a>
<a name="ln606">#  endif</a>
<a name="ln607">#endif</a>
<a name="ln608">#ifndef Q_FORWARD_DECLARE_CF_TYPE</a>
<a name="ln609">#  define Q_FORWARD_DECLARE_CF_TYPE(type) typedef const struct __ ## type * type ## Ref</a>
<a name="ln610">#endif</a>
<a name="ln611">#ifndef Q_FORWARD_DECLARE_MUTABLE_CF_TYPE</a>
<a name="ln612">#  define Q_FORWARD_DECLARE_MUTABLE_CF_TYPE(type) typedef struct __ ## type * type ## Ref</a>
<a name="ln613">#endif</a>
<a name="ln614">#ifndef Q_FORWARD_DECLARE_CG_TYPE</a>
<a name="ln615">#define Q_FORWARD_DECLARE_CG_TYPE(type) typedef const struct type *type ## Ref;</a>
<a name="ln616">#endif</a>
<a name="ln617">#ifndef Q_FORWARD_DECLARE_MUTABLE_CG_TYPE</a>
<a name="ln618">#define Q_FORWARD_DECLARE_MUTABLE_CG_TYPE(type) typedef struct type *type ## Ref;</a>
<a name="ln619">#endif</a>
<a name="ln620"> </a>
<a name="ln621">#ifdef Q_OS_DARWIN</a>
<a name="ln622">#  define QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios, tvos, watchos) \</a>
<a name="ln623">    ((defined(__MAC_OS_X_VERSION_MAX_ALLOWED) &amp;&amp; macos != __MAC_NA &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= macos) || \</a>
<a name="ln624">     (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; ios != __IPHONE_NA &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= ios) || \</a>
<a name="ln625">     (defined(__TV_OS_VERSION_MAX_ALLOWED) &amp;&amp; tvos != __TVOS_NA &amp;&amp; __TV_OS_VERSION_MAX_ALLOWED &gt;= tvos) || \</a>
<a name="ln626">     (defined(__WATCH_OS_VERSION_MAX_ALLOWED) &amp;&amp; watchos != __WATCHOS_NA &amp;&amp; __WATCH_OS_VERSION_MAX_ALLOWED &gt;= watchos))</a>
<a name="ln627"> </a>
<a name="ln628">#  define QT_DARWIN_DEPLOYMENT_TARGET_BELOW(macos, ios, tvos, watchos) \</a>
<a name="ln629">    ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; macos != __MAC_NA &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &lt; macos) || \</a>
<a name="ln630">     (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; ios != __IPHONE_NA &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &lt; ios) || \</a>
<a name="ln631">     (defined(__TV_OS_VERSION_MIN_REQUIRED) &amp;&amp; tvos != __TVOS_NA &amp;&amp; __TV_OS_VERSION_MIN_REQUIRED &lt; tvos) || \</a>
<a name="ln632">     (defined(__WATCH_OS_VERSION_MIN_REQUIRED) &amp;&amp; watchos != __WATCHOS_NA &amp;&amp; __WATCH_OS_VERSION_MIN_REQUIRED &lt; watchos))</a>
<a name="ln633"> </a>
<a name="ln634">#  define QT_MACOS_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios) \</a>
<a name="ln635">      QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios, __TVOS_NA, __WATCHOS_NA)</a>
<a name="ln636">#  define QT_MACOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos) \</a>
<a name="ln637">      QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, __IPHONE_NA, __TVOS_NA, __WATCHOS_NA)</a>
<a name="ln638">#  define QT_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(ios) \</a>
<a name="ln639">      QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_NA, ios, __TVOS_NA, __WATCHOS_NA)</a>
<a name="ln640">#  define QT_TVOS_PLATFORM_SDK_EQUAL_OR_ABOVE(tvos) \</a>
<a name="ln641">      QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_NA, __IPHONE_NA, tvos, __WATCHOS_NA)</a>
<a name="ln642">#  define QT_WATCHOS_PLATFORM_SDK_EQUAL_OR_ABOVE(watchos) \</a>
<a name="ln643">      QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_NA, __IPHONE_NA, __TVOS_NA, watchos)</a>
<a name="ln644"> </a>
<a name="ln645">#  define QT_MACOS_IOS_DEPLOYMENT_TARGET_BELOW(macos, ios) \</a>
<a name="ln646">      QT_DARWIN_DEPLOYMENT_TARGET_BELOW(macos, ios, __TVOS_NA, __WATCHOS_NA)</a>
<a name="ln647">#  define QT_MACOS_DEPLOYMENT_TARGET_BELOW(macos) \</a>
<a name="ln648">      QT_DARWIN_DEPLOYMENT_TARGET_BELOW(macos, __IPHONE_NA, __TVOS_NA, __WATCHOS_NA)</a>
<a name="ln649">#  define QT_IOS_DEPLOYMENT_TARGET_BELOW(ios) \</a>
<a name="ln650">      QT_DARWIN_DEPLOYMENT_TARGET_BELOW(__MAC_NA, ios, __TVOS_NA, __WATCHOS_NA)</a>
<a name="ln651">#  define QT_TVOS_DEPLOYMENT_TARGET_BELOW(tvos) \</a>
<a name="ln652">      QT_DARWIN_DEPLOYMENT_TARGET_BELOW(__MAC_NA, __IPHONE_NA, tvos, __WATCHOS_NA)</a>
<a name="ln653">#  define QT_WATCHOS_DEPLOYMENT_TARGET_BELOW(watchos) \</a>
<a name="ln654">      QT_DARWIN_DEPLOYMENT_TARGET_BELOW(__MAC_NA, __IPHONE_NA, __TVOS_NA, watchos)</a>
<a name="ln655"> </a>
<a name="ln656">// Compatibility synonyms, do not use</a>
<a name="ln657">#  define QT_MAC_PLATFORM_SDK_EQUAL_OR_ABOVE(osx, ios) QT_MACOS_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(osx, ios)</a>
<a name="ln658">#  define QT_MAC_DEPLOYMENT_TARGET_BELOW(osx, ios) QT_MACOS_IOS_DEPLOYMENT_TARGET_BELOW(osx, ios)</a>
<a name="ln659">#  define QT_OSX_PLATFORM_SDK_EQUAL_OR_ABOVE(osx) QT_MACOS_PLATFORM_SDK_EQUAL_OR_ABOVE(osx)</a>
<a name="ln660">#  define QT_OSX_DEPLOYMENT_TARGET_BELOW(osx) QT_MACOS_DEPLOYMENT_TARGET_BELOW(osx)</a>
<a name="ln661"> </a>
<a name="ln662">// Implemented in qcore_mac_objc.mm</a>
<a name="ln663">class Q_CORE_EXPORT QMacAutoReleasePool</a>
<a name="ln664">{</a>
<a name="ln665">public:</a>
<a name="ln666">    QMacAutoReleasePool();</a>
<a name="ln667">    ~QMacAutoReleasePool();</a>
<a name="ln668">private:</a>
<a name="ln669">    Q_DISABLE_COPY(QMacAutoReleasePool)</a>
<a name="ln670">    void *pool;</a>
<a name="ln671">};</a>
<a name="ln672"> </a>
<a name="ln673">#else</a>
<a name="ln674"> </a>
<a name="ln675">#define QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios, tvos, watchos) (0)</a>
<a name="ln676">#define QT_MACOS_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios) (0)</a>
<a name="ln677">#define QT_MACOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos) (0)</a>
<a name="ln678">#define QT_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(ios) (0)</a>
<a name="ln679">#define QT_TVOS_PLATFORM_SDK_EQUAL_OR_ABOVE(tvos) (0)</a>
<a name="ln680">#define QT_WATCHOS_PLATFORM_SDK_EQUAL_OR_ABOVE(watchos) (0)</a>
<a name="ln681"> </a>
<a name="ln682">#define QT_MAC_PLATFORM_SDK_EQUAL_OR_ABOVE(osx, ios) (0)</a>
<a name="ln683">#define QT_OSX_PLATFORM_SDK_EQUAL_OR_ABOVE(osx) (0)</a>
<a name="ln684"> </a>
<a name="ln685">#endif // Q_OS_DARWIN</a>
<a name="ln686"> </a>
<a name="ln687">/*</a>
<a name="ln688">   Data stream functions are provided by many classes (defined in qdatastream.h)</a>
<a name="ln689">*/</a>
<a name="ln690"> </a>
<a name="ln691">class QDataStream;</a>
<a name="ln692"> </a>
<a name="ln693">inline void qt_noop(void) {}</a>
<a name="ln694"> </a>
<a name="ln695">/* These wrap try/catch so we can switch off exceptions later.</a>
<a name="ln696"> </a>
<a name="ln697">   Beware - do not use more than one QT_CATCH per QT_TRY, and do not use</a>
<a name="ln698">   the exception instance in the catch block.</a>
<a name="ln699">   If you can't live with those constraints, don't use these macros.</a>
<a name="ln700">   Use the QT_NO_EXCEPTIONS macro to protect your code instead.</a>
<a name="ln701">*/</a>
<a name="ln702"> </a>
<a name="ln703">#if !defined(QT_NO_EXCEPTIONS)</a>
<a name="ln704">#  if !defined(Q_MOC_RUN)</a>
<a name="ln705">#    if (defined(Q_CC_CLANG) &amp;&amp; !defined(Q_CC_INTEL) &amp;&amp; !QT_HAS_FEATURE(cxx_exceptions)) || \</a>
<a name="ln706">        (defined(Q_CC_GNU) &amp;&amp; !defined(__EXCEPTIONS))</a>
<a name="ln707">#      define QT_NO_EXCEPTIONS</a>
<a name="ln708">#    endif</a>
<a name="ln709">#  elif defined(QT_BOOTSTRAPPED)</a>
<a name="ln710">#    define QT_NO_EXCEPTIONS</a>
<a name="ln711">#  endif</a>
<a name="ln712">#endif</a>
<a name="ln713"> </a>
<a name="ln714">#ifdef QT_NO_EXCEPTIONS</a>
<a name="ln715">#  define QT_TRY if (true)</a>
<a name="ln716">#  define QT_CATCH(A) else</a>
<a name="ln717">#  define QT_THROW(A) qt_noop()</a>
<a name="ln718">#  define QT_RETHROW qt_noop()</a>
<a name="ln719">#  define QT_TERMINATE_ON_EXCEPTION(expr) do { expr; } while (false)</a>
<a name="ln720">#else</a>
<a name="ln721">#  define QT_TRY try</a>
<a name="ln722">#  define QT_CATCH(A) catch (A)</a>
<a name="ln723">#  define QT_THROW(A) throw A</a>
<a name="ln724">#  define QT_RETHROW throw</a>
<a name="ln725">Q_NORETURN Q_DECL_COLD_FUNCTION Q_CORE_EXPORT void qTerminate() Q_DECL_NOTHROW;</a>
<a name="ln726">#  ifdef Q_COMPILER_NOEXCEPT</a>
<a name="ln727">#    define QT_TERMINATE_ON_EXCEPTION(expr) do { expr; } while (false)</a>
<a name="ln728">#  else</a>
<a name="ln729">#    define QT_TERMINATE_ON_EXCEPTION(expr) do { try { expr; } catch (...) { qTerminate(); } } while (false)</a>
<a name="ln730">#  endif</a>
<a name="ln731">#endif</a>
<a name="ln732"> </a>
<a name="ln733">Q_CORE_EXPORT Q_DECL_CONST_FUNCTION bool qSharedBuild() Q_DECL_NOTHROW;</a>
<a name="ln734"> </a>
<a name="ln735">#ifndef Q_OUTOFLINE_TEMPLATE</a>
<a name="ln736">#  define Q_OUTOFLINE_TEMPLATE</a>
<a name="ln737">#endif</a>
<a name="ln738">#ifndef Q_INLINE_TEMPLATE</a>
<a name="ln739">#  define Q_INLINE_TEMPLATE inline</a>
<a name="ln740">#endif</a>
<a name="ln741"> </a>
<a name="ln742">/*</a>
<a name="ln743">   Debugging and error handling</a>
<a name="ln744">*/</a>
<a name="ln745"> </a>
<a name="ln746">#if !defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_DEBUG)</a>
<a name="ln747">#  define QT_DEBUG</a>
<a name="ln748">#endif</a>
<a name="ln749"> </a>
<a name="ln750">// QtPrivate::asString defined in qstring.h</a>
<a name="ln751">#ifndef qPrintable</a>
<a name="ln752">#  define qPrintable(string) QtPrivate::asString(string).toLocal8Bit().constData()</a>
<a name="ln753">#endif</a>
<a name="ln754"> </a>
<a name="ln755">#ifndef qUtf8Printable</a>
<a name="ln756">#  define qUtf8Printable(string) QtPrivate::asString(string).toUtf8().constData()</a>
<a name="ln757">#endif</a>
<a name="ln758"> </a>
<a name="ln759">/*</a>
<a name="ln760">    Wrap QString::utf16() with enough casts to allow passing it</a>
<a name="ln761">    to QString::asprintf(&quot;%ls&quot;) without warnings.</a>
<a name="ln762">*/</a>
<a name="ln763">#ifndef qUtf16Printable</a>
<a name="ln764">#  define qUtf16Printable(string) \</a>
<a name="ln765">    static_cast&lt;const wchar_t*&gt;(static_cast&lt;const void*&gt;(QString(string).utf16()))</a>
<a name="ln766">#endif</a>
<a name="ln767"> </a>
<a name="ln768">class QString;</a>
<a name="ln769">Q_DECL_COLD_FUNCTION</a>
<a name="ln770">Q_CORE_EXPORT QString qt_error_string(int errorCode = -1);</a>
<a name="ln771"> </a>
<a name="ln772">#ifndef Q_CC_MSVC</a>
<a name="ln773">Q_NORETURN</a>
<a name="ln774">#endif</a>
<a name="ln775">Q_DECL_COLD_FUNCTION</a>
<a name="ln776">Q_CORE_EXPORT void qt_assert(const char *assertion, const char *file, int line) Q_DECL_NOTHROW;</a>
<a name="ln777"> </a>
<a name="ln778">#if !defined(Q_ASSERT)</a>
<a name="ln779">#  if defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_FORCE_ASSERTS)</a>
<a name="ln780">#    define Q_ASSERT(cond) static_cast&lt;void&gt;(false &amp;&amp; (cond))</a>
<a name="ln781">#  else</a>
<a name="ln782">#    define Q_ASSERT(cond) ((cond) ? static_cast&lt;void&gt;(0) : qt_assert(#cond, __FILE__, __LINE__))</a>
<a name="ln783">#  endif</a>
<a name="ln784">#endif</a>
<a name="ln785"> </a>
<a name="ln786">#if defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_PAINT_DEBUG)</a>
<a name="ln787">#define QT_NO_PAINT_DEBUG</a>
<a name="ln788">#endif</a>
<a name="ln789"> </a>
<a name="ln790">#ifndef Q_CC_MSVC</a>
<a name="ln791">Q_NORETURN</a>
<a name="ln792">#endif</a>
<a name="ln793">Q_DECL_COLD_FUNCTION</a>
<a name="ln794">Q_CORE_EXPORT void qt_assert_x(const char *where, const char *what, const char *file, int line) Q_DECL_NOTHROW;</a>
<a name="ln795"> </a>
<a name="ln796">#if !defined(Q_ASSERT_X)</a>
<a name="ln797">#  if defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_FORCE_ASSERTS)</a>
<a name="ln798">#    define Q_ASSERT_X(cond, where, what) static_cast&lt;void&gt;(false &amp;&amp; (cond))</a>
<a name="ln799">#  else</a>
<a name="ln800">#    define Q_ASSERT_X(cond, where, what) ((cond) ? static_cast&lt;void&gt;(0) : qt_assert_x(where, what, __FILE__, __LINE__))</a>
<a name="ln801">#  endif</a>
<a name="ln802">#endif</a>
<a name="ln803"> </a>
<a name="ln804">Q_NORETURN Q_CORE_EXPORT void qt_check_pointer(const char *, int) Q_DECL_NOTHROW;</a>
<a name="ln805">Q_DECL_COLD_FUNCTION</a>
<a name="ln806">Q_CORE_EXPORT void qBadAlloc();</a>
<a name="ln807"> </a>
<a name="ln808">#ifdef QT_NO_EXCEPTIONS</a>
<a name="ln809">#  if defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_FORCE_ASSERTS)</a>
<a name="ln810">#    define Q_CHECK_PTR(p) qt_noop()</a>
<a name="ln811">#  else</a>
<a name="ln812">#    define Q_CHECK_PTR(p) do {if (!(p)) qt_check_pointer(__FILE__,__LINE__);} while (false)</a>
<a name="ln813">#  endif</a>
<a name="ln814">#else</a>
<a name="ln815">#  define Q_CHECK_PTR(p) do { if (!(p)) qBadAlloc(); } while (false)</a>
<a name="ln816">#endif</a>
<a name="ln817"> </a>
<a name="ln818">template &lt;typename T&gt;</a>
<a name="ln819">inline T *q_check_ptr(T *p) { Q_CHECK_PTR(p); return p; }</a>
<a name="ln820"> </a>
<a name="ln821">typedef void (*QFunctionPointer)();</a>
<a name="ln822"> </a>
<a name="ln823">#if !defined(Q_UNIMPLEMENTED)</a>
<a name="ln824">#  define Q_UNIMPLEMENTED() qWarning(&quot;Unimplemented code.&quot;)</a>
<a name="ln825">#endif</a>
<a name="ln826"> </a>
<a name="ln827">Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qFuzzyCompare(double p1, double p2)</a>
<a name="ln828">{</a>
<a name="ln829">    return (qAbs(p1 - p2) * 1000000000000. &lt;= qMin(qAbs(p1), qAbs(p2)));</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qFuzzyCompare(float p1, float p2)</a>
<a name="ln833">{</a>
<a name="ln834">    return (qAbs(p1 - p2) * 100000.f &lt;= qMin(qAbs(p1), qAbs(p2)));</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qFuzzyIsNull(double d)</a>
<a name="ln838">{</a>
<a name="ln839">    return qAbs(d) &lt;= 0.000000000001;</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED  bool qFuzzyIsNull(float f)</a>
<a name="ln843">{</a>
<a name="ln844">    return qAbs(f) &lt;= 0.00001f;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">/*</a>
<a name="ln848">   This function tests a double for a null value. It doesn't</a>
<a name="ln849">   check whether the actual value is 0 or close to 0, but whether</a>
<a name="ln850">   it is binary 0, disregarding sign.</a>
<a name="ln851">*/</a>
<a name="ln852">Q_REQUIRED_RESULT static inline Q_DECL_UNUSED bool qIsNull(double d)</a>
<a name="ln853">{</a>
<a name="ln854">    union U {</a>
<a name="ln855">        double d;</a>
<a name="ln856">        quint64 u;</a>
<a name="ln857">    };</a>
<a name="ln858">    U val;</a>
<a name="ln859">    val.d = d;</a>
<a name="ln860">    return (val.u &amp; Q_UINT64_C(0x7fffffffffffffff)) == 0;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">/*</a>
<a name="ln864">   This function tests a float for a null value. It doesn't</a>
<a name="ln865">   check whether the actual value is 0 or close to 0, but whether</a>
<a name="ln866">   it is binary 0, disregarding sign.</a>
<a name="ln867">*/</a>
<a name="ln868">Q_REQUIRED_RESULT static inline Q_DECL_UNUSED bool qIsNull(float f)</a>
<a name="ln869">{</a>
<a name="ln870">    union U {</a>
<a name="ln871">        float f;</a>
<a name="ln872">        quint32 u;</a>
<a name="ln873">    };</a>
<a name="ln874">    U val;</a>
<a name="ln875">    val.f = f;</a>
<a name="ln876">    return (val.u &amp; 0x7fffffff) == 0;</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">/*</a>
<a name="ln880">   Compilers which follow outdated template instantiation rules</a>
<a name="ln881">   require a class to have a comparison operator to exist when</a>
<a name="ln882">   a QList of this type is instantiated. It's not actually</a>
<a name="ln883">   used in the list, though. Hence the dummy implementation.</a>
<a name="ln884">   Just in case other code relies on it we better trigger a warning</a>
<a name="ln885">   mandating a real implementation.</a>
<a name="ln886">*/</a>
<a name="ln887"> </a>
<a name="ln888">#ifdef Q_FULL_TEMPLATE_INSTANTIATION</a>
<a name="ln889">#  define Q_DUMMY_COMPARISON_OPERATOR(C) \</a>
<a name="ln890">    bool operator==(const C&amp;) const { \</a>
<a name="ln891">        qWarning(#C&quot;::operator==(const &quot;#C&quot;&amp;) was called&quot;); \</a>
<a name="ln892">        return false; \</a>
<a name="ln893">    }</a>
<a name="ln894">#else</a>
<a name="ln895"> </a>
<a name="ln896">#  define Q_DUMMY_COMPARISON_OPERATOR(C)</a>
<a name="ln897">#endif</a>
<a name="ln898"> </a>
<a name="ln899">namespace QtPrivate</a>
<a name="ln900">{</a>
<a name="ln901">namespace SwapExceptionTester { // insulate users from the &quot;using std::swap&quot; below</a>
<a name="ln902">    using std::swap; // import std::swap</a>
<a name="ln903">    template &lt;typename T&gt;</a>
<a name="ln904">    void checkSwap(T &amp;t)</a>
<a name="ln905">        Q_DECL_NOEXCEPT_EXPR(noexcept(swap(t, t)));</a>
<a name="ln906">    // declared, but not implemented (only to be used in unevaluated contexts (noexcept operator))</a>
<a name="ln907">}</a>
<a name="ln908">} // namespace QtPrivate</a>
<a name="ln909"> </a>
<a name="ln910">template &lt;typename T&gt;</a>
<a name="ln911">inline void qSwap(T &amp;value1, T &amp;value2)</a>
<a name="ln912">    Q_DECL_NOEXCEPT_EXPR(noexcept(QtPrivate::SwapExceptionTester::checkSwap(value1)))</a>
<a name="ln913">{</a>
<a name="ln914">    using std::swap;</a>
<a name="ln915">    swap(value1, value2);</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">#if QT_DEPRECATED_SINCE(5, 0)</a>
<a name="ln919">Q_CORE_EXPORT QT_DEPRECATED void *qMalloc(size_t size) Q_ALLOC_SIZE(1);</a>
<a name="ln920">Q_CORE_EXPORT QT_DEPRECATED void qFree(void *ptr);</a>
<a name="ln921">Q_CORE_EXPORT QT_DEPRECATED void *qRealloc(void *ptr, size_t size) Q_ALLOC_SIZE(2);</a>
<a name="ln922">Q_CORE_EXPORT QT_DEPRECATED void *qMemCopy(void *dest, const void *src, size_t n);</a>
<a name="ln923">Q_CORE_EXPORT QT_DEPRECATED void *qMemSet(void *dest, int c, size_t n);</a>
<a name="ln924">#endif</a>
<a name="ln925">Q_CORE_EXPORT void *qMallocAligned(size_t size, size_t alignment) Q_ALLOC_SIZE(1);</a>
<a name="ln926">Q_CORE_EXPORT void *qReallocAligned(void *ptr, size_t size, size_t oldsize, size_t alignment) Q_ALLOC_SIZE(2);</a>
<a name="ln927">Q_CORE_EXPORT void qFreeAligned(void *ptr);</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">/*</a>
<a name="ln931">   Avoid some particularly useless warnings from some stupid compilers.</a>
<a name="ln932">   To get ALL C++ compiler warnings, define QT_CC_WARNINGS or comment out</a>
<a name="ln933">   the line &quot;#define QT_NO_WARNINGS&quot;.</a>
<a name="ln934">*/</a>
<a name="ln935">#if !defined(QT_CC_WARNINGS)</a>
<a name="ln936">#  define QT_NO_WARNINGS</a>
<a name="ln937">#endif</a>
<a name="ln938">#if defined(QT_NO_WARNINGS)</a>
<a name="ln939">#  if defined(Q_CC_MSVC)</a>
<a name="ln940">QT_WARNING_DISABLE_MSVC(4251) /* class 'type' needs to have dll-interface to be used by clients of class 'type2' */</a>
<a name="ln941">QT_WARNING_DISABLE_MSVC(4244) /* conversion from 'type1' to 'type2', possible loss of data */</a>
<a name="ln942">QT_WARNING_DISABLE_MSVC(4275) /* non - DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier' */</a>
<a name="ln943">QT_WARNING_DISABLE_MSVC(4514) /* unreferenced inline function has been removed */</a>
<a name="ln944">QT_WARNING_DISABLE_MSVC(4800) /* 'type' : forcing value to bool 'true' or 'false' (performance warning) */</a>
<a name="ln945">QT_WARNING_DISABLE_MSVC(4097) /* typedef-name 'identifier1' used as synonym for class-name 'identifier2' */</a>
<a name="ln946">QT_WARNING_DISABLE_MSVC(4706) /* assignment within conditional expression */</a>
<a name="ln947">QT_WARNING_DISABLE_MSVC(4355) /* 'this' : used in base member initializer list */</a>
<a name="ln948">QT_WARNING_DISABLE_MSVC(4710) /* function not inlined */</a>
<a name="ln949">QT_WARNING_DISABLE_MSVC(4530) /* C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc */</a>
<a name="ln950">#  elif defined(Q_CC_BOR)</a>
<a name="ln951">#    pragma option -w-inl</a>
<a name="ln952">#    pragma option -w-aus</a>
<a name="ln953">#    pragma warn -inl</a>
<a name="ln954">#    pragma warn -pia</a>
<a name="ln955">#    pragma warn -ccc</a>
<a name="ln956">#    pragma warn -rch</a>
<a name="ln957">#    pragma warn -sig</a>
<a name="ln958">#  endif</a>
<a name="ln959">#endif</a>
<a name="ln960"> </a>
<a name="ln961">// this adds const to non-const objects (like std::as_const)</a>
<a name="ln962">template &lt;typename T&gt;</a>
<a name="ln963">Q_DECL_CONSTEXPR typename std::add_const&lt;T&gt;::type &amp;qAsConst(T &amp;t) Q_DECL_NOTHROW { return t; }</a>
<a name="ln964">// prevent rvalue arguments:</a>
<a name="ln965">template &lt;typename T&gt;</a>
<a name="ln966">void qAsConst(const T &amp;&amp;) Q_DECL_EQ_DELETE;</a>
<a name="ln967"> </a>
<a name="ln968">#ifndef QT_NO_FOREACH</a>
<a name="ln969"> </a>
<a name="ln970">namespace QtPrivate {</a>
<a name="ln971"> </a>
<a name="ln972">template &lt;typename T&gt;</a>
<a name="ln973">class QForeachContainer {</a>
<a name="ln974">    Q_DISABLE_COPY(QForeachContainer)</a>
<a name="ln975">public:</a>
<a name="ln976">    QForeachContainer(const T &amp;t) : c(t), i(qAsConst(c).begin()), e(qAsConst(c).end()) {}</a>
<a name="ln977">    QForeachContainer(T &amp;&amp;t) : c(std::move(t)), i(qAsConst(c).begin()), e(qAsConst(c).end())  {}</a>
<a name="ln978"> </a>
<a name="ln979">    QForeachContainer(QForeachContainer &amp;&amp;other)</a>
<a name="ln980">        : c(std::move(other.c)),</a>
<a name="ln981">          i(qAsConst(c).begin()),</a>
<a name="ln982">          e(qAsConst(c).end()),</a>
<a name="ln983">          control(std::move(other.control))</a>
<a name="ln984">    {</a>
<a name="ln985">    }</a>
<a name="ln986"> </a>
<a name="ln987">    QForeachContainer &amp;operator=(QForeachContainer &amp;&amp;other)</a>
<a name="ln988">    {</a>
<a name="ln989">        c = std::move(other.c);</a>
<a name="ln990">        i = qAsConst(c).begin();</a>
<a name="ln991">        e = qAsConst(c).end();</a>
<a name="ln992">        control = std::move(other.control);</a>
<a name="ln993">        return *this;</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996">    T c;</a>
<a name="ln997">    typename T::const_iterator i, e;</a>
<a name="ln998">    int control = 1;</a>
<a name="ln999">};</a>
<a name="ln1000"> </a>
<a name="ln1001">template&lt;typename T&gt;</a>
<a name="ln1002">QForeachContainer&lt;typename std::decay&lt;T&gt;::type&gt; qMakeForeachContainer(T &amp;&amp;t)</a>
<a name="ln1003">{</a>
<a name="ln1004">    return QForeachContainer&lt;typename std::decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(t));</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">}</a>
<a name="ln1008">// Explanation of the control word:</a>
<a name="ln1009">//  - it's initialized to 1</a>
<a name="ln1010">//  - that means both the inner and outer loops start</a>
<a name="ln1011">//  - if there were no breaks, at the end of the inner loop, it's set to 0, which</a>
<a name="ln1012">//    causes it to exit (the inner loop is run exactly once)</a>
<a name="ln1013">//  - at the end of the outer loop, it's inverted, so it becomes 1 again, allowing</a>
<a name="ln1014">//    the outer loop to continue executing</a>
<a name="ln1015">//  - if there was a break inside the inner loop, it will exit with control still</a>
<a name="ln1016">//    set to 1; in that case, the outer loop will invert it to 0 and will exit too</a>
<a name="ln1017">#define Q_FOREACH(variable, container)                                \</a>
<a name="ln1018">for (auto _container_ = QtPrivate::qMakeForeachContainer(container); \</a>
<a name="ln1019">     _container_.control &amp;&amp; _container_.i != _container_.e;         \</a>
<a name="ln1020">     ++_container_.i, _container_.control ^= 1)                     \</a>
<a name="ln1021">    for (variable = *_container_.i; _container_.control; _container_.control = 0)</a>
<a name="ln1022"> </a>
<a name="ln1023">#endif // QT_NO_FOREACH</a>
<a name="ln1024"> </a>
<a name="ln1025">#define Q_FOREVER for(;;)</a>
<a name="ln1026">#ifndef QT_NO_KEYWORDS</a>
<a name="ln1027"># ifndef QT_NO_FOREACH</a>
<a name="ln1028">#  ifndef foreach</a>
<a name="ln1029">#    define foreach Q_FOREACH</a>
<a name="ln1030">#  endif</a>
<a name="ln1031"># endif // QT_NO_FOREACH</a>
<a name="ln1032">#  ifndef forever</a>
<a name="ln1033">#    define forever Q_FOREVER</a>
<a name="ln1034">#  endif</a>
<a name="ln1035">#endif</a>
<a name="ln1036"> </a>
<a name="ln1037">template &lt;typename T&gt; static inline T *qGetPtrHelper(T *ptr) { return ptr; }</a>
<a name="ln1038">template &lt;typename Wrapper&gt; static inline typename Wrapper::pointer qGetPtrHelper(const Wrapper &amp;p) { return p.data(); }</a>
<a name="ln1039"> </a>
<a name="ln1040">#define Q_DECLARE_PRIVATE(Class) \</a>
<a name="ln1041">    inline Class##Private* d_func() { return reinterpret_cast&lt;Class##Private *&gt;(qGetPtrHelper(d_ptr)); } \</a>
<a name="ln1042">    inline const Class##Private* d_func() const { return reinterpret_cast&lt;const Class##Private *&gt;(qGetPtrHelper(d_ptr)); } \</a>
<a name="ln1043">    friend class Class##Private;</a>
<a name="ln1044"> </a>
<a name="ln1045">#define Q_DECLARE_PRIVATE_D(Dptr, Class) \</a>
<a name="ln1046">    inline Class##Private* d_func() { return reinterpret_cast&lt;Class##Private *&gt;(qGetPtrHelper(Dptr)); } \</a>
<a name="ln1047">    inline const Class##Private* d_func() const { return reinterpret_cast&lt;const Class##Private *&gt;(qGetPtrHelper(Dptr)); } \</a>
<a name="ln1048">    friend class Class##Private;</a>
<a name="ln1049"> </a>
<a name="ln1050">#define Q_DECLARE_PUBLIC(Class)                                    \</a>
<a name="ln1051">    inline Class* q_func() { return static_cast&lt;Class *&gt;(q_ptr); } \</a>
<a name="ln1052">    inline const Class* q_func() const { return static_cast&lt;const Class *&gt;(q_ptr); } \</a>
<a name="ln1053">    friend class Class;</a>
<a name="ln1054"> </a>
<a name="ln1055">#define Q_D(Class) Class##Private * const d = d_func()</a>
<a name="ln1056">#define Q_Q(Class) Class * const q = q_func()</a>
<a name="ln1057"> </a>
<a name="ln1058">#define QT_TR_NOOP(x) x</a>
<a name="ln1059">#define QT_TR_NOOP_UTF8(x) x</a>
<a name="ln1060">#define QT_TRANSLATE_NOOP(scope, x) x</a>
<a name="ln1061">#define QT_TRANSLATE_NOOP_UTF8(scope, x) x</a>
<a name="ln1062">#define QT_TRANSLATE_NOOP3(scope, x, comment) {x, comment}</a>
<a name="ln1063">#define QT_TRANSLATE_NOOP3_UTF8(scope, x, comment) {x, comment}</a>
<a name="ln1064"> </a>
<a name="ln1065">#ifndef QT_NO_TRANSLATION // ### This should enclose the NOOPs above</a>
<a name="ln1066"> </a>
<a name="ln1067">// Defined in qcoreapplication.cpp</a>
<a name="ln1068">// The better name qTrId() is reserved for an upcoming function which would</a>
<a name="ln1069">// return a much more powerful QStringFormatter instead of a QString.</a>
<a name="ln1070">Q_CORE_EXPORT QString qtTrId(const char *id, int n = -1);</a>
<a name="ln1071"> </a>
<a name="ln1072">#define QT_TRID_NOOP(id) id</a>
<a name="ln1073"> </a>
<a name="ln1074">#endif // QT_NO_TRANSLATION</a>
<a name="ln1075"> </a>
<a name="ln1076">/*</a>
<a name="ln1077">   When RTTI is not available, define this macro to force any uses of</a>
<a name="ln1078">   dynamic_cast to cause a compile failure.</a>
<a name="ln1079">*/</a>
<a name="ln1080"> </a>
<a name="ln1081">#if defined(QT_NO_DYNAMIC_CAST) &amp;&amp; !defined(dynamic_cast)</a>
<a name="ln1082">#  define dynamic_cast QT_PREPEND_NAMESPACE(qt_dynamic_cast_check)</a>
<a name="ln1083"> </a>
<a name="ln1084">  template&lt;typename T, typename X&gt;</a>
<a name="ln1085">  T qt_dynamic_cast_check(X, T* = 0)</a>
<a name="ln1086">  { return T::dynamic_cast_will_always_fail_because_rtti_is_disabled; }</a>
<a name="ln1087">#endif</a>
<a name="ln1088"> </a>
<a name="ln1089"> </a>
<a name="ln1090">#ifdef Q_QDOC</a>
<a name="ln1091"> </a>
<a name="ln1092">// Just for documentation generation</a>
<a name="ln1093">template&lt;typename T&gt;</a>
<a name="ln1094">auto qOverload(T functionPointer);</a>
<a name="ln1095">template&lt;typename T&gt;</a>
<a name="ln1096">auto qConstOverload(T memberFunctionPointer);</a>
<a name="ln1097">template&lt;typename T&gt;</a>
<a name="ln1098">auto qNonConstOverload(T memberFunctionPointer);</a>
<a name="ln1099"> </a>
<a name="ln1100">#elif defined(Q_COMPILER_VARIADIC_TEMPLATES)</a>
<a name="ln1101"> </a>
<a name="ln1102">template &lt;typename... Args&gt;</a>
<a name="ln1103">struct QNonConstOverload</a>
<a name="ln1104">{</a>
<a name="ln1105">    template &lt;typename R, typename T&gt;</a>
<a name="ln1106">    Q_DECL_CONSTEXPR auto operator()(R (T::*ptr)(Args...)) const Q_DECL_NOTHROW -&gt; decltype(ptr)</a>
<a name="ln1107">    { return ptr; }</a>
<a name="ln1108"> </a>
<a name="ln1109">    template &lt;typename R, typename T&gt;</a>
<a name="ln1110">    static Q_DECL_CONSTEXPR auto of(R (T::*ptr)(Args...)) Q_DECL_NOTHROW -&gt; decltype(ptr)</a>
<a name="ln1111">    { return ptr; }</a>
<a name="ln1112">};</a>
<a name="ln1113"> </a>
<a name="ln1114">template &lt;typename... Args&gt;</a>
<a name="ln1115">struct QConstOverload</a>
<a name="ln1116">{</a>
<a name="ln1117">    template &lt;typename R, typename T&gt;</a>
<a name="ln1118">    Q_DECL_CONSTEXPR auto operator()(R (T::*ptr)(Args...) const) const Q_DECL_NOTHROW -&gt; decltype(ptr)</a>
<a name="ln1119">    { return ptr; }</a>
<a name="ln1120"> </a>
<a name="ln1121">    template &lt;typename R, typename T&gt;</a>
<a name="ln1122">    static Q_DECL_CONSTEXPR auto of(R (T::*ptr)(Args...) const) Q_DECL_NOTHROW -&gt; decltype(ptr)</a>
<a name="ln1123">    { return ptr; }</a>
<a name="ln1124">};</a>
<a name="ln1125"> </a>
<a name="ln1126">template &lt;typename... Args&gt;</a>
<a name="ln1127">struct QOverload : QConstOverload&lt;Args...&gt;, QNonConstOverload&lt;Args...&gt;</a>
<a name="ln1128">{</a>
<a name="ln1129">    using QConstOverload&lt;Args...&gt;::of;</a>
<a name="ln1130">    using QConstOverload&lt;Args...&gt;::operator();</a>
<a name="ln1131">    using QNonConstOverload&lt;Args...&gt;::of;</a>
<a name="ln1132">    using QNonConstOverload&lt;Args...&gt;::operator();</a>
<a name="ln1133"> </a>
<a name="ln1134">    template &lt;typename R&gt;</a>
<a name="ln1135">    Q_DECL_CONSTEXPR auto operator()(R (*ptr)(Args...)) const Q_DECL_NOTHROW -&gt; decltype(ptr)</a>
<a name="ln1136">    { return ptr; }</a>
<a name="ln1137"> </a>
<a name="ln1138">    template &lt;typename R&gt;</a>
<a name="ln1139">    static Q_DECL_CONSTEXPR auto of(R (*ptr)(Args...)) Q_DECL_NOTHROW -&gt; decltype(ptr)</a>
<a name="ln1140">    { return ptr; }</a>
<a name="ln1141">};</a>
<a name="ln1142"> </a>
<a name="ln1143">#if defined(__cpp_variable_templates) &amp;&amp; __cpp_variable_templates &gt;= 201304 // C++14</a>
<a name="ln1144">template &lt;typename... Args&gt; Q_CONSTEXPR Q_DECL_UNUSED QOverload&lt;Args...&gt; qOverload = {};</a>
<a name="ln1145">template &lt;typename... Args&gt; Q_CONSTEXPR Q_DECL_UNUSED QConstOverload&lt;Args...&gt; qConstOverload = {};</a>
<a name="ln1146">template &lt;typename... Args&gt; Q_CONSTEXPR Q_DECL_UNUSED QNonConstOverload&lt;Args...&gt; qNonConstOverload = {};</a>
<a name="ln1147">#endif</a>
<a name="ln1148"> </a>
<a name="ln1149">#endif</a>
<a name="ln1150"> </a>
<a name="ln1151"> </a>
<a name="ln1152">class QByteArray;</a>
<a name="ln1153">Q_CORE_EXPORT QByteArray qgetenv(const char *varName);</a>
<a name="ln1154">// need it as two functions because QString is only forward-declared here</a>
<a name="ln1155">Q_CORE_EXPORT QString qEnvironmentVariable(const char *varName);</a>
<a name="ln1156">Q_CORE_EXPORT QString qEnvironmentVariable(const char *varName, const QString &amp;defaultValue);</a>
<a name="ln1157">Q_CORE_EXPORT bool qputenv(const char *varName, const QByteArray&amp; value);</a>
<a name="ln1158">Q_CORE_EXPORT bool qunsetenv(const char *varName);</a>
<a name="ln1159"> </a>
<a name="ln1160">Q_CORE_EXPORT bool qEnvironmentVariableIsEmpty(const char *varName) Q_DECL_NOEXCEPT;</a>
<a name="ln1161">Q_CORE_EXPORT bool qEnvironmentVariableIsSet(const char *varName) Q_DECL_NOEXCEPT;</a>
<a name="ln1162">Q_CORE_EXPORT int  qEnvironmentVariableIntValue(const char *varName, bool *ok=nullptr) Q_DECL_NOEXCEPT;</a>
<a name="ln1163"> </a>
<a name="ln1164">inline int qIntCast(double f) { return int(f); }</a>
<a name="ln1165">inline int qIntCast(float f) { return int(f); }</a>
<a name="ln1166"> </a>
<a name="ln1167">/*</a>
<a name="ln1168">  Reentrant versions of basic rand() functions for random number generation</a>
<a name="ln1169">*/</a>
<a name="ln1170">Q_CORE_EXPORT void qsrand(uint seed);</a>
<a name="ln1171">Q_CORE_EXPORT int qrand();</a>
<a name="ln1172"> </a>
<a name="ln1173">#define QT_MODULE(x)</a>
<a name="ln1174"> </a>
<a name="ln1175">#if !defined(QT_BOOTSTRAPPED) &amp;&amp; defined(QT_REDUCE_RELOCATIONS) &amp;&amp; defined(__ELF__) &amp;&amp; \</a>
<a name="ln1176">    (!defined(__PIC__) || (defined(__PIE__) &amp;&amp; defined(Q_CC_GNU) &amp;&amp; Q_CC_GNU &gt;= 500))</a>
<a name="ln1177">#  error &quot;You must build your code with position independent code if Qt was built with -reduce-relocations. &quot;\</a>
<a name="ln1178">         &quot;Compile your code with -fPIC (-fPIE is not enough).&quot;</a>
<a name="ln1179">#endif</a>
<a name="ln1180"> </a>
<a name="ln1181">namespace QtPrivate {</a>
<a name="ln1182">//like std::enable_if</a>
<a name="ln1183">template &lt;bool B, typename T = void&gt; struct QEnableIf;</a>
<a name="ln1184">template &lt;typename T&gt; struct QEnableIf&lt;true, T&gt; { typedef T Type; };</a>
<a name="ln1185"> </a>
<a name="ln1186">template &lt;bool B, typename T, typename F&gt; struct QConditional { typedef T Type; };</a>
<a name="ln1187">template &lt;typename T, typename F&gt; struct QConditional&lt;false, T, F&gt; { typedef F Type; };</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190">QT_END_NAMESPACE</a>
<a name="ln1191"> </a>
<a name="ln1192">// We need to keep QTypeInfo, QSysInfo, QFlags, qDebug &amp; family in qglobal.h for compatibility with Qt 4.</a>
<a name="ln1193">// Be careful when changing the order of these files.</a>
<a name="ln1194">#include &lt;QtCore/qtypeinfo.h&gt;</a>
<a name="ln1195">#include &lt;QtCore/qsysinfo.h&gt;</a>
<a name="ln1196">#include &lt;QtCore/qlogging.h&gt;</a>
<a name="ln1197"> </a>
<a name="ln1198">#include &lt;QtCore/qflags.h&gt;</a>
<a name="ln1199"> </a>
<a name="ln1200">#include &lt;QtCore/qatomic.h&gt;</a>
<a name="ln1201">#include &lt;QtCore/qglobalstatic.h&gt;</a>
<a name="ln1202">#include &lt;QtCore/qnumeric.h&gt;</a>
<a name="ln1203">#include &lt;QtCore/qversiontagging.h&gt;</a>
<a name="ln1204"> </a>
<a name="ln1205">#endif /* __cplusplus */</a>
<a name="ln1206">#endif /* !__ASSEMBLER__ */</a>
<a name="ln1207"> </a>
<a name="ln1208">#endif /* QGLOBAL_H */</a>

</code></pre>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'ushort' type. The declaration from system header files should be used instead.</p></div>
<div class="balloon" rel="275"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'uint' type. The declaration from system header files should be used instead.</p></div>
<div class="balloon" rel="276"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v677/" target="_blank">V677</a> Custom declaration of a standard 'ulong' type. The declaration from system header files should be used instead.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
