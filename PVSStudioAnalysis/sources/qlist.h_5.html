
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qlist.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Contact: https://www.qt.io/licensing/</a>
<a name="ln5">**</a>
<a name="ln6">** This file is part of the QtCore module of the Qt Toolkit.</a>
<a name="ln7">**</a>
<a name="ln8">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln9">** Commercial License Usage</a>
<a name="ln10">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln11">** accordance with the commercial license agreement provided with the</a>
<a name="ln12">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln13">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln14">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln15">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln16">**</a>
<a name="ln17">** GNU Lesser General Public License Usage</a>
<a name="ln18">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln19">** General Public License version 3 as published by the Free Software</a>
<a name="ln20">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln21">** packaging of this file. Please review the following information to</a>
<a name="ln22">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln23">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln24">**</a>
<a name="ln25">** GNU General Public License Usage</a>
<a name="ln26">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln27">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln28">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln29">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln30">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln31">** included in the packaging of this file. Please review the following</a>
<a name="ln32">** information to ensure the GNU General Public License requirements will</a>
<a name="ln33">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln34">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln35">**</a>
<a name="ln36">** $QT_END_LICENSE$</a>
<a name="ln37">**</a>
<a name="ln38">****************************************************************************/</a>
<a name="ln39"> </a>
<a name="ln40">#ifndef QLIST_H</a>
<a name="ln41">#define QLIST_H</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;QtCore/qalgorithms.h&gt;</a>
<a name="ln44">#include &lt;QtCore/qiterator.h&gt;</a>
<a name="ln45">#include &lt;QtCore/qrefcount.h&gt;</a>
<a name="ln46">#include &lt;QtCore/qarraydata.h&gt;</a>
<a name="ln47">#include &lt;QtCore/qhashfunctions.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;iterator&gt;</a>
<a name="ln50">#include &lt;list&gt;</a>
<a name="ln51">#include &lt;algorithm&gt;</a>
<a name="ln52">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln53">#include &lt;initializer_list&gt;</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;stdlib.h&gt;</a>
<a name="ln57">#include &lt;new&gt;</a>
<a name="ln58">#include &lt;limits.h&gt;</a>
<a name="ln59">#include &lt;string.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#ifdef Q_CC_MSVC</a>
<a name="ln62">#pragma warning( push )</a>
<a name="ln63">#pragma warning( disable : 4127 ) // &quot;conditional expression is constant&quot;</a>
<a name="ln64">#endif</a>
<a name="ln65"> </a>
<a name="ln66">QT_BEGIN_NAMESPACE</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">template &lt;typename T&gt; class QVector;</a>
<a name="ln70">template &lt;typename T&gt; class QSet;</a>
<a name="ln71"> </a>
<a name="ln72">template &lt;typename T&gt; struct QListSpecialMethods</a>
<a name="ln73">{</a>
<a name="ln74">protected:</a>
<a name="ln75">    ~QListSpecialMethods() {}</a>
<a name="ln76">};</a>
<a name="ln77">template &lt;&gt; struct QListSpecialMethods&lt;QByteArray&gt;;</a>
<a name="ln78">template &lt;&gt; struct QListSpecialMethods&lt;QString&gt;;</a>
<a name="ln79"> </a>
<a name="ln80">struct Q_CORE_EXPORT QListData {</a>
<a name="ln81">    // tags for tag-dispatching of QList implementations,</a>
<a name="ln82">    // based on QList's three different memory layouts:</a>
<a name="ln83">    struct NotArrayCompatibleLayout {};</a>
<a name="ln84">    struct NotIndirectLayout {};</a>
<a name="ln85">    struct ArrayCompatibleLayout   : NotIndirectLayout {};                           // data laid out like a C array</a>
<a name="ln86">    struct InlineWithPaddingLayout : NotArrayCompatibleLayout, NotIndirectLayout {}; // data laid out like a C array with padding</a>
<a name="ln87">    struct IndirectLayout          : NotArrayCompatibleLayout {};                    // data allocated on the heap</a>
<a name="ln88"> </a>
<a name="ln89">    struct Data {</a>
<a name="ln90">        QtPrivate::RefCount ref;</a>
<a name="ln91">        int alloc, begin, end;</a>
<a name="ln92">        void *array[1];</a>
<a name="ln93">    };</a>
<a name="ln94">    enum { DataHeaderSize = sizeof(Data) - sizeof(void *) };</a>
<a name="ln95"> </a>
<a name="ln96">    Data *detach(int alloc);</a>
<a name="ln97">    Data *detach_grow(int *i, int n);</a>
<a name="ln98">    void realloc(int alloc);</a>
<a name="ln99">    void realloc_grow(int growth);</a>
<a name="ln100">    inline void dispose() { dispose(d); }</a>
<a name="ln101">    static void dispose(Data *d);</a>
<a name="ln102">    static const Data shared_null;</a>
<a name="ln103">    Data *d;</a>
<a name="ln104">    void **erase(void **xi);</a>
<a name="ln105">    void **append(int n);</a>
<a name="ln106">    void **append();</a>
<a name="ln107">    void **append(const QListData &amp;l);</a>
<a name="ln108">    void **prepend();</a>
<a name="ln109">    void **insert(int i);</a>
<a name="ln110">    void remove(int i);</a>
<a name="ln111">    void remove(int i, int n);</a>
<a name="ln112">    void move(int from, int to);</a>
<a name="ln113">    inline int size() const Q_DECL_NOTHROW { return d-&gt;end - d-&gt;begin; }</a>
<a name="ln114">    inline bool isEmpty() const Q_DECL_NOTHROW { return d-&gt;end  == d-&gt;begin; }</a>
<a name="ln115">    inline void **at(int i) const Q_DECL_NOTHROW { return d-&gt;array + d-&gt;begin + i; }</a>
<a name="ln116">    inline void **begin() const Q_DECL_NOTHROW { return d-&gt;array + d-&gt;begin; }</a>
<a name="ln117">    inline void **end() const Q_DECL_NOTHROW { return d-&gt;array + d-&gt;end; }</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">template &lt;typename T&gt;</a>
<a name="ln121">class QList</a>
<a name="ln122">#ifndef Q_QDOC</a>
<a name="ln123">    : public QListSpecialMethods&lt;T&gt;</a>
<a name="ln124">#endif</a>
<a name="ln125">{</a>
<a name="ln126">public:</a>
<a name="ln127">    struct MemoryLayout</a>
<a name="ln128">        : std::conditional&lt;</a>
<a name="ln129">            // must stay isStatic until ### Qt 6 for BC reasons (don't use !isRelocatable)!</a>
<a name="ln130">            QTypeInfo&lt;T&gt;::isStatic || QTypeInfo&lt;T&gt;::isLarge,</a>
<a name="ln131">            QListData::IndirectLayout,</a>
<a name="ln132">            typename std::conditional&lt;</a>
<a name="ln133">                sizeof(T) == sizeof(void*),</a>
<a name="ln134">                QListData::ArrayCompatibleLayout,</a>
<a name="ln135">                QListData::InlineWithPaddingLayout</a>
<a name="ln136">             &gt;::type&gt;::type {};</a>
<a name="ln137">private:</a>
<a name="ln138">    struct Node { void *v;</a>
<a name="ln139">#if defined(Q_CC_BOR)</a>
<a name="ln140">        Q_INLINE_TEMPLATE T &amp;t();</a>
<a name="ln141">#else</a>
<a name="ln142">        Q_INLINE_TEMPLATE T &amp;t()</a>
<a name="ln143">        { return *reinterpret_cast&lt;T*&gt;(QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic</a>
<a name="ln144">                                       ? v : this); }</a>
<a name="ln145">#endif</a>
<a name="ln146">    };</a>
<a name="ln147"> </a>
<a name="ln148">    union { QListData p; QListData::Data *d; };</a>
<a name="ln149"> </a>
<a name="ln150">public:</a>
<a name="ln151">    inline QList() Q_DECL_NOTHROW : d(const_cast&lt;QListData::Data *&gt;(&amp;QListData::shared_null)) { }</a>
<a name="ln152">    QList(const QList&lt;T&gt; &amp;l);</a>
<a name="ln153">    ~QList();</a>
<a name="ln154">    QList&lt;T&gt; &amp;operator=(const QList&lt;T&gt; &amp;l);</a>
<a name="ln155">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln156">    inline QList(QList&lt;T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln157">        : d(other.d) { other.d = const_cast&lt;QListData::Data *&gt;(&amp;QListData::shared_null); }</a>
<a name="ln158">    inline QList &amp;operator=(QList&lt;T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln159">    { QList moved(std::move(other)); swap(moved); return *this; }</a>
<a name="ln160">#endif</a>
<a name="ln161">    inline void swap(QList&lt;T&gt; &amp;other) Q_DECL_NOTHROW { qSwap(d, other.d); }</a>
<a name="ln162">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln163">    inline QList(std::initializer_list&lt;T&gt; args)</a>
<a name="ln164">        : d(const_cast&lt;QListData::Data *&gt;(&amp;QListData::shared_null))</a>
<a name="ln165">    { reserve(int(args.size())); std::copy(args.begin(), args.end(), std::back_inserter(*this)); }</a>
<a name="ln166">#endif</a>
<a name="ln167">    bool operator==(const QList&lt;T&gt; &amp;l) const;</a>
<a name="ln168">    inline bool operator!=(const QList&lt;T&gt; &amp;l) const { return !(*this == l); }</a>
<a name="ln169"> </a>
<a name="ln170">    inline int size() const Q_DECL_NOTHROW { return p.size(); }</a>
<a name="ln171"> </a>
<a name="ln172">    inline void detach() { if (d-&gt;ref.isShared()) detach_helper(); }</a>
<a name="ln173"> </a>
<a name="ln174">    inline void detachShared()</a>
<a name="ln175">    {</a>
<a name="ln176">        // The &quot;this-&gt;&quot; qualification is needed for GCCE.</a>
<a name="ln177">        if (d-&gt;ref.isShared() &amp;&amp; this-&gt;d != &amp;QListData::shared_null)</a>
<a name="ln178">            detach_helper();</a>
<a name="ln179">    }</a>
<a name="ln180"> </a>
<a name="ln181">    inline bool isDetached() const { return !d-&gt;ref.isShared(); }</a>
<a name="ln182">#if !defined(QT_NO_UNSHARABLE_CONTAINERS)</a>
<a name="ln183">    inline void setSharable(bool sharable)</a>
<a name="ln184">    {</a>
<a name="ln185">        if (sharable == d-&gt;ref.isSharable())</a>
<a name="ln186">            return;</a>
<a name="ln187">        if (!sharable)</a>
<a name="ln188">            detach();</a>
<a name="ln189">        if (d != &amp;QListData::shared_null)</a>
<a name="ln190">            d-&gt;ref.setSharable(sharable);</a>
<a name="ln191">    }</a>
<a name="ln192">#endif</a>
<a name="ln193">    inline bool isSharedWith(const QList&lt;T&gt; &amp;other) const Q_DECL_NOTHROW { return d == other.d; }</a>
<a name="ln194"> </a>
<a name="ln195">    inline bool isEmpty() const Q_DECL_NOTHROW { return p.isEmpty(); }</a>
<a name="ln196"> </a>
<a name="ln197">    void clear();</a>
<a name="ln198"> </a>
<a name="ln199">    const T &amp;at(int i) const;</a>
<a name="ln200">    const T &amp;operator[](int i) const;</a>
<a name="ln201">    T &amp;operator[](int i);</a>
<a name="ln202"> </a>
<a name="ln203">    void reserve(int size);</a>
<a name="ln204">    void append(const T &amp;t);</a>
<a name="ln205">    void append(const QList&lt;T&gt; &amp;t);</a>
<a name="ln206">    void prepend(const T &amp;t);</a>
<a name="ln207">    void insert(int i, const T &amp;t);</a>
<a name="ln208">    void replace(int i, const T &amp;t);</a>
<a name="ln209">    void removeAt(int i);</a>
<a name="ln210">    int removeAll(const T &amp;t);</a>
<a name="ln211">    bool removeOne(const T &amp;t);</a>
<a name="ln212">    T takeAt(int i);</a>
<a name="ln213">    T takeFirst();</a>
<a name="ln214">    T takeLast();</a>
<a name="ln215">    void move(int from, int to);</a>
<a name="ln216">    void swap(int i, int j);</a>
<a name="ln217">    int indexOf(const T &amp;t, int from = 0) const;</a>
<a name="ln218">    int lastIndexOf(const T &amp;t, int from = -1) const;</a>
<a name="ln219">    bool contains(const T &amp;t) const;</a>
<a name="ln220">    int count(const T &amp;t) const;</a>
<a name="ln221"> </a>
<a name="ln222">    class const_iterator;</a>
<a name="ln223"> </a>
<a name="ln224">    class iterator {</a>
<a name="ln225">    public:</a>
<a name="ln226">        Node *i;</a>
<a name="ln227">        typedef std::random_access_iterator_tag  iterator_category;</a>
<a name="ln228">        // ### Qt6: use int</a>
<a name="ln229">        typedef qptrdiff difference_type;</a>
<a name="ln230">        typedef T value_type;</a>
<a name="ln231">        typedef T *pointer;</a>
<a name="ln232">        typedef T &amp;reference;</a>
<a name="ln233"> </a>
<a name="ln234">        inline iterator() Q_DECL_NOTHROW : i(nullptr) {}</a>
<a name="ln235">        inline iterator(Node *n) Q_DECL_NOTHROW : i(n) {}</a>
<a name="ln236">#if QT_VERSION &lt; QT_VERSION_CHECK(6,0,0)</a>
<a name="ln237">        // can't remove it in Qt 5, since doing so would make the type trivial,</a>
<a name="ln238">        // which changes the way it's passed to functions by value.</a>
<a name="ln239">        inline iterator(const iterator &amp;o) Q_DECL_NOTHROW : i(o.i){}</a>
<a name="ln240">#endif</a>
<a name="ln241">        inline T &amp;operator*() const { return i-&gt;t(); }</a>
<a name="ln242">        inline T *operator-&gt;() const { return &amp;i-&gt;t(); }</a>
<a name="ln243">        inline T &amp;operator[](difference_type j) const { return i[j].t(); }</a>
<a name="ln244">        inline bool operator==(const iterator &amp;o) const Q_DECL_NOTHROW { return i == o.i; }</a>
<a name="ln245">        inline bool operator!=(const iterator &amp;o) const Q_DECL_NOTHROW { return i != o.i; }</a>
<a name="ln246">        inline bool operator&lt;(const iterator&amp; other) const Q_DECL_NOTHROW { return i &lt; other.i; }</a>
<a name="ln247">        inline bool operator&lt;=(const iterator&amp; other) const Q_DECL_NOTHROW { return i &lt;= other.i; }</a>
<a name="ln248">        inline bool operator&gt;(const iterator&amp; other) const Q_DECL_NOTHROW { return i &gt; other.i; }</a>
<a name="ln249">        inline bool operator&gt;=(const iterator&amp; other) const Q_DECL_NOTHROW { return i &gt;= other.i; }</a>
<a name="ln250">#ifndef QT_STRICT_ITERATORS</a>
<a name="ln251">        inline bool operator==(const const_iterator &amp;o) const Q_DECL_NOTHROW</a>
<a name="ln252">            { return i == o.i; }</a>
<a name="ln253">        inline bool operator!=(const const_iterator &amp;o) const Q_DECL_NOTHROW</a>
<a name="ln254">            { return i != o.i; }</a>
<a name="ln255">        inline bool operator&lt;(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln256">            { return i &lt; other.i; }</a>
<a name="ln257">        inline bool operator&lt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln258">            { return i &lt;= other.i; }</a>
<a name="ln259">        inline bool operator&gt;(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln260">            { return i &gt; other.i; }</a>
<a name="ln261">        inline bool operator&gt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln262">            { return i &gt;= other.i; }</a>
<a name="ln263">#endif</a>
<a name="ln264">        inline iterator &amp;operator++() { ++i; return *this; }</a>
<a name="ln265">        inline iterator operator++(int) { Node *n = i; ++i; return n; }</a>
<a name="ln266">        inline iterator &amp;operator--() { i--; return *this; }</a>
<a name="ln267">        inline iterator operator--(int) { Node *n = i; i--; return n; }</a>
<a name="ln268">        inline iterator &amp;operator+=(difference_type j) { i+=j; return *this; }</a>
<a name="ln269">        inline iterator &amp;operator-=(difference_type j) { i-=j; return *this; }</a>
<a name="ln270">        inline iterator operator+(difference_type j) const { return iterator(i+j); }</a>
<a name="ln271">        inline iterator operator-(difference_type j) const { return iterator(i-j); }</a>
<a name="ln272">        inline int operator-(iterator j) const { return int(i - j.i); }</a>
<a name="ln273">    };</a>
<a name="ln274">    friend class iterator;</a>
<a name="ln275"> </a>
<a name="ln276">    class const_iterator {</a>
<a name="ln277">    public:</a>
<a name="ln278">        Node *i;</a>
<a name="ln279">        typedef std::random_access_iterator_tag  iterator_category;</a>
<a name="ln280">        // ### Qt6: use int</a>
<a name="ln281">        typedef qptrdiff difference_type;</a>
<a name="ln282">        typedef T value_type;</a>
<a name="ln283">        typedef const T *pointer;</a>
<a name="ln284">        typedef const T &amp;reference;</a>
<a name="ln285"> </a>
<a name="ln286">        inline const_iterator() Q_DECL_NOTHROW : i(nullptr) {}</a>
<a name="ln287">        inline const_iterator(Node *n) Q_DECL_NOTHROW : i(n) {}</a>
<a name="ln288">#if QT_VERSION &lt; QT_VERSION_CHECK(6,0,0)</a>
<a name="ln289">        // can't remove it in Qt 5, since doing so would make the type trivial,</a>
<a name="ln290">        // which changes the way it's passed to functions by value.</a>
<a name="ln291">        inline const_iterator(const const_iterator &amp;o) Q_DECL_NOTHROW : i(o.i) {}</a>
<a name="ln292">#endif</a>
<a name="ln293">#ifdef QT_STRICT_ITERATORS</a>
<a name="ln294">        inline explicit const_iterator(const iterator &amp;o) Q_DECL_NOTHROW : i(o.i) {}</a>
<a name="ln295">#else</a>
<a name="ln296">        inline const_iterator(const iterator &amp;o) Q_DECL_NOTHROW : i(o.i) {}</a>
<a name="ln297">#endif</a>
<a name="ln298">        inline const T &amp;operator*() const { return i-&gt;t(); }</a>
<a name="ln299">        inline const T *operator-&gt;() const { return &amp;i-&gt;t(); }</a>
<a name="ln300">        inline const T &amp;operator[](difference_type j) const { return i[j].t(); }</a>
<a name="ln301">        inline bool operator==(const const_iterator &amp;o) const Q_DECL_NOTHROW { return i == o.i; }</a>
<a name="ln302">        inline bool operator!=(const const_iterator &amp;o) const Q_DECL_NOTHROW { return i != o.i; }</a>
<a name="ln303">        inline bool operator&lt;(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &lt; other.i; }</a>
<a name="ln304">        inline bool operator&lt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &lt;= other.i; }</a>
<a name="ln305">        inline bool operator&gt;(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &gt; other.i; }</a>
<a name="ln306">        inline bool operator&gt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &gt;= other.i; }</a>
<a name="ln307">        inline const_iterator &amp;operator++() { ++i; return *this; }</a>
<a name="ln308">        inline const_iterator operator++(int) { Node *n = i; ++i; return n; }</a>
<a name="ln309">        inline const_iterator &amp;operator--() { i--; return *this; }</a>
<a name="ln310">        inline const_iterator operator--(int) { Node *n = i; i--; return n; }</a>
<a name="ln311">        inline const_iterator &amp;operator+=(difference_type j) { i+=j; return *this; }</a>
<a name="ln312">        inline const_iterator &amp;operator-=(difference_type j) { i-=j; return *this; }</a>
<a name="ln313">        inline const_iterator operator+(difference_type j) const { return const_iterator(i+j); }</a>
<a name="ln314">        inline const_iterator operator-(difference_type j) const { return const_iterator(i-j); }</a>
<a name="ln315">        inline int operator-(const_iterator j) const { return int(i - j.i); }</a>
<a name="ln316">    };</a>
<a name="ln317">    friend class const_iterator;</a>
<a name="ln318"> </a>
<a name="ln319">    // stl style</a>
<a name="ln320">    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;</a>
<a name="ln321">    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</a>
<a name="ln322">    inline iterator begin() { detach(); return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln323">    inline const_iterator begin() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln324">    inline const_iterator cbegin() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln325">    inline const_iterator constBegin() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln326">    inline iterator end() { detach(); return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln327">    inline const_iterator end() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln328">    inline const_iterator cend() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln329">    inline const_iterator constEnd() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln330">    reverse_iterator rbegin() { return reverse_iterator(end()); }</a>
<a name="ln331">    reverse_iterator rend() { return reverse_iterator(begin()); }</a>
<a name="ln332">    const_reverse_iterator rbegin() const Q_DECL_NOTHROW { return const_reverse_iterator(end()); }</a>
<a name="ln333">    const_reverse_iterator rend() const Q_DECL_NOTHROW { return const_reverse_iterator(begin()); }</a>
<a name="ln334">    const_reverse_iterator crbegin() const Q_DECL_NOTHROW { return const_reverse_iterator(end()); }</a>
<a name="ln335">    const_reverse_iterator crend() const Q_DECL_NOTHROW { return const_reverse_iterator(begin()); }</a>
<a name="ln336">    iterator insert(iterator before, const T &amp;t);</a>
<a name="ln337">    iterator erase(iterator pos);</a>
<a name="ln338">    iterator erase(iterator first, iterator last);</a>
<a name="ln339"> </a>
<a name="ln340">    // more Qt</a>
<a name="ln341">    typedef iterator Iterator;</a>
<a name="ln342">    typedef const_iterator ConstIterator;</a>
<a name="ln343">    inline int count() const { return p.size(); }</a>
<a name="ln344">    inline int length() const { return p.size(); } // Same as count()</a>
<a name="ln345">    inline T&amp; first() { Q_ASSERT(!isEmpty()); return *begin(); }</a>
<a name="ln346">    inline const T&amp; constFirst() const { return first(); }</a>
<a name="ln347">    inline const T&amp; first() const { Q_ASSERT(!isEmpty()); return at(0); }</a>
<a name="ln348">    T&amp; last() { Q_ASSERT(!isEmpty()); return *(--end()); }</a>
<a name="ln349">    const T&amp; last() const { Q_ASSERT(!isEmpty()); return at(count() - 1); }</a>
<a name="ln350">    inline const T&amp; constLast() const { return last(); }</a>
<a name="ln351">    inline void removeFirst() { Q_ASSERT(!isEmpty()); erase(begin()); }</a>
<a name="ln352">    inline void removeLast() { Q_ASSERT(!isEmpty()); erase(--end()); }</a>
<a name="ln353">    inline bool startsWith(const T &amp;t) const { return !isEmpty() &amp;&amp; first() == t; }</a>
<a name="ln354">    inline bool endsWith(const T &amp;t) const { return !isEmpty() &amp;&amp; last() == t; }</a>
<a name="ln355">    QList&lt;T&gt; mid(int pos, int length = -1) const;</a>
<a name="ln356"> </a>
<a name="ln357">    T value(int i) const;</a>
<a name="ln358">    T value(int i, const T &amp;defaultValue) const;</a>
<a name="ln359"> </a>
<a name="ln360">    // stl compatibility</a>
<a name="ln361">    inline void push_back(const T &amp;t) { append(t); }</a>
<a name="ln362">    inline void push_front(const T &amp;t) { prepend(t); }</a>
<a name="ln363">    inline T&amp; front() { return first(); }</a>
<a name="ln364">    inline const T&amp; front() const { return first(); }</a>
<a name="ln365">    inline T&amp; back() { return last(); }</a>
<a name="ln366">    inline const T&amp; back() const { return last(); }</a>
<a name="ln367">    inline void pop_front() { removeFirst(); }</a>
<a name="ln368">    inline void pop_back() { removeLast(); }</a>
<a name="ln369">    inline bool empty() const { return isEmpty(); }</a>
<a name="ln370">    typedef int size_type;</a>
<a name="ln371">    typedef T value_type;</a>
<a name="ln372">    typedef value_type *pointer;</a>
<a name="ln373">    typedef const value_type *const_pointer;</a>
<a name="ln374">    typedef value_type &amp;reference;</a>
<a name="ln375">    typedef const value_type &amp;const_reference;</a>
<a name="ln376">    // ### Qt6: use int</a>
<a name="ln377">    typedef qptrdiff difference_type;</a>
<a name="ln378"> </a>
<a name="ln379">    // comfort</a>
<a name="ln380">    QList&lt;T&gt; &amp;operator+=(const QList&lt;T&gt; &amp;l);</a>
<a name="ln381">    inline QList&lt;T&gt; operator+(const QList&lt;T&gt; &amp;l) const</a>
<a name="ln382">    { QList n = *this; n += l; return n; }</a>
<a name="ln383">    inline QList&lt;T&gt; &amp;operator+=(const T &amp;t)</a>
<a name="ln384">    { append(t); return *this; }</a>
<a name="ln385">    inline QList&lt;T&gt; &amp;operator&lt;&lt; (const T &amp;t)</a>
<a name="ln386">    { append(t); return *this; }</a>
<a name="ln387">    inline QList&lt;T&gt; &amp;operator&lt;&lt;(const QList&lt;T&gt; &amp;l)</a>
<a name="ln388">    { *this += l; return *this; }</a>
<a name="ln389"> </a>
<a name="ln390">    QVector&lt;T&gt; toVector() const;</a>
<a name="ln391">    QSet&lt;T&gt; toSet() const;</a>
<a name="ln392"> </a>
<a name="ln393">    static QList&lt;T&gt; fromVector(const QVector&lt;T&gt; &amp;vector);</a>
<a name="ln394">    static QList&lt;T&gt; fromSet(const QSet&lt;T&gt; &amp;set);</a>
<a name="ln395"> </a>
<a name="ln396">    static inline QList&lt;T&gt; fromStdList(const std::list&lt;T&gt; &amp;list)</a>
<a name="ln397">    { QList&lt;T&gt; tmp; std::copy(list.begin(), list.end(), std::back_inserter(tmp)); return tmp; }</a>
<a name="ln398">    inline std::list&lt;T&gt; toStdList() const</a>
<a name="ln399">    { std::list&lt;T&gt; tmp; std::copy(constBegin(), constEnd(), std::back_inserter(tmp)); return tmp; }</a>
<a name="ln400"> </a>
<a name="ln401">private:</a>
<a name="ln402">    Node *detach_helper_grow(int i, int n);</a>
<a name="ln403">    void detach_helper(int alloc);</a>
<a name="ln404">    void detach_helper();</a>
<a name="ln405">    void dealloc(QListData::Data *d);</a>
<a name="ln406"> </a>
<a name="ln407">    void node_construct(Node *n, const T &amp;t);</a>
<a name="ln408">    void node_destruct(Node *n);</a>
<a name="ln409">    void node_copy(Node *from, Node *to, Node *src);</a>
<a name="ln410">    void node_destruct(Node *from, Node *to);</a>
<a name="ln411"> </a>
<a name="ln412">    bool isValidIterator(const iterator &amp;i) const Q_DECL_NOTHROW</a>
<a name="ln413">    {</a>
<a name="ln414">        return (constBegin().i &lt;= i.i) &amp;&amp; (i.i &lt;= constEnd().i);</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">private:</a>
<a name="ln418">    inline bool op_eq_impl(const QList &amp;other, QListData::NotArrayCompatibleLayout) const;</a>
<a name="ln419">    inline bool op_eq_impl(const QList &amp;other, QListData::ArrayCompatibleLayout) const;</a>
<a name="ln420">    inline bool contains_impl(const T &amp;, QListData::NotArrayCompatibleLayout) const;</a>
<a name="ln421">    inline bool contains_impl(const T &amp;, QListData::ArrayCompatibleLayout) const;</a>
<a name="ln422">    inline int count_impl(const T &amp;, QListData::NotArrayCompatibleLayout) const;</a>
<a name="ln423">    inline int count_impl(const T &amp;, QListData::ArrayCompatibleLayout) const;</a>
<a name="ln424">};</a>
<a name="ln425"> </a>
<a name="ln426">#if defined(Q_CC_BOR)</a>
<a name="ln427">template &lt;typename T&gt;</a>
<a name="ln428">Q_INLINE_TEMPLATE T &amp;QList&lt;T&gt;::Node::t()</a>
<a name="ln429">{ return QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic ? *(T*)v:*(T*)this; }</a>
<a name="ln430">#endif</a>
<a name="ln431"> </a>
<a name="ln432">template &lt;typename T&gt;</a>
<a name="ln433">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_construct(Node *n, const T &amp;t)</a>
<a name="ln434">{</a>
<a name="ln435">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) n-&gt;v = new T(t);</a>
<a name="ln436">    else if (QTypeInfo&lt;T&gt;::isComplex) new (n) T(t);</a>
<a name="ln437">#if (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__IBMCPP__)) &amp;&amp; !defined(__OPTIMIZE__)</a>
<a name="ln438">    // This violates pointer aliasing rules, but it is known to be safe (and silent)</a>
<a name="ln439">    // in unoptimized GCC builds (-fno-strict-aliasing). The other compilers which</a>
<a name="ln440">    // set the same define are assumed to be safe.</a>
<a name="ln441">    else *reinterpret_cast&lt;T*&gt;(n) = t;</a>
<a name="ln442">#else</a>
<a name="ln443">    // This is always safe, but penaltizes unoptimized builds a lot.</a>
<a name="ln444">    else ::memcpy(n, static_cast&lt;const void *&gt;(&amp;t), sizeof(T));</a>
<a name="ln445">#endif</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">template &lt;typename T&gt;</a>
<a name="ln449">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_destruct(Node *n)</a>
<a name="ln450">{</a>
<a name="ln451">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) delete reinterpret_cast&lt;T*&gt;(n-&gt;v);</a>
<a name="ln452">    else if (QTypeInfo&lt;T&gt;::isComplex) reinterpret_cast&lt;T*&gt;(n)-&gt;~T();</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">template &lt;typename T&gt;</a>
<a name="ln456">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_copy(Node *from, Node *to, Node *src)</a>
<a name="ln457">{</a>
<a name="ln458">    Node *current = from;</a>
<a name="ln459">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln460">        QT_TRY {</a>
<a name="ln461">            while(current != to) {</a>
<a name="ln462">                current-&gt;v = new T(*reinterpret_cast&lt;T*&gt;(src-&gt;v));</a>
<a name="ln463">                ++current;</a>
<a name="ln464">                ++src;</a>
<a name="ln465">            }</a>
<a name="ln466">        } QT_CATCH(...) {</a>
<a name="ln467">            while (current-- != from)</a>
<a name="ln468">                delete reinterpret_cast&lt;T*&gt;(current-&gt;v);</a>
<a name="ln469">            QT_RETHROW;</a>
<a name="ln470">        }</a>
<a name="ln471"> </a>
<a name="ln472">    } else if (QTypeInfo&lt;T&gt;::isComplex) {</a>
<a name="ln473">        QT_TRY {</a>
<a name="ln474">            while(current != to) {</a>
<a name="ln475">                new (current) T(*reinterpret_cast&lt;T*&gt;(src));</a>
<a name="ln476">                ++current;</a>
<a name="ln477">                ++src;</a>
<a name="ln478">            }</a>
<a name="ln479">        } QT_CATCH(...) {</a>
<a name="ln480">            while (current-- != from)</a>
<a name="ln481">                (reinterpret_cast&lt;T*&gt;(current))-&gt;~T();</a>
<a name="ln482">            QT_RETHROW;</a>
<a name="ln483">        }</a>
<a name="ln484">    } else {</a>
<a name="ln485">        if (src != from &amp;&amp; to - from &gt; 0)</a>
<a name="ln486">            memcpy(from, src, (to - from) * sizeof(Node));</a>
<a name="ln487">    }</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">template &lt;typename T&gt;</a>
<a name="ln491">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_destruct(Node *from, Node *to)</a>
<a name="ln492">{</a>
<a name="ln493">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic)</a>
<a name="ln494">        while(from != to) --to, delete reinterpret_cast&lt;T*&gt;(to-&gt;v);</a>
<a name="ln495">    else if (QTypeInfo&lt;T&gt;::isComplex)</a>
<a name="ln496">        while (from != to) --to, reinterpret_cast&lt;T*&gt;(to)-&gt;~T();</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">template &lt;typename T&gt;</a>
<a name="ln500">Q_INLINE_TEMPLATE QList&lt;T&gt; &amp;QList&lt;T&gt;::operator=(const QList&lt;T&gt; &amp;l)</a>
<a name="ln501">{</a>
<a name="ln502">    if (d != l.d) {</a>
<a name="ln503">        QList&lt;T&gt; tmp(l);</a>
<a name="ln504">        tmp.swap(*this);</a>
<a name="ln505">    }</a>
<a name="ln506">    return *this;</a>
<a name="ln507">}</a>
<a name="ln508">template &lt;typename T&gt;</a>
<a name="ln509">inline typename QList&lt;T&gt;::iterator QList&lt;T&gt;::insert(iterator before, const T &amp;t)</a>
<a name="ln510">{</a>
<a name="ln511">    Q_ASSERT_X(isValidIterator(before), &quot;QList::insert&quot;, &quot;The specified iterator argument 'before' is invalid&quot;);</a>
<a name="ln512"> </a>
<a name="ln513">    int iBefore = int(before.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln514">    Node *n = 0;</a>
<a name="ln515">    if (d-&gt;ref.isShared())</a>
<a name="ln516">        n = detach_helper_grow(iBefore, 1);</a>
<a name="ln517">    else</a>
<a name="ln518">        n = reinterpret_cast&lt;Node *&gt;(p.insert(iBefore));</a>
<a name="ln519">    QT_TRY {</a>
<a name="ln520">        node_construct(n, t);</a>
<a name="ln521">    } QT_CATCH(...) {</a>
<a name="ln522">        p.remove(iBefore);</a>
<a name="ln523">        QT_RETHROW;</a>
<a name="ln524">    }</a>
<a name="ln525">    return n;</a>
<a name="ln526">}</a>
<a name="ln527">template &lt;typename T&gt;</a>
<a name="ln528">inline typename QList&lt;T&gt;::iterator QList&lt;T&gt;::erase(iterator it)</a>
<a name="ln529">{</a>
<a name="ln530">    Q_ASSERT_X(isValidIterator(it), &quot;QList::erase&quot;, &quot;The specified iterator argument 'it' is invalid&quot;);</a>
<a name="ln531">    if (d-&gt;ref.isShared()) {</a>
<a name="ln532">        int offset = int(it.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln533">        it = begin(); // implies detach()</a>
<a name="ln534">        it += offset;</a>
<a name="ln535">    }</a>
<a name="ln536">    node_destruct(it.i);</a>
<a name="ln537">    return reinterpret_cast&lt;Node *&gt;(p.erase(reinterpret_cast&lt;void**&gt;(it.i)));</a>
<a name="ln538">}</a>
<a name="ln539">template &lt;typename T&gt;</a>
<a name="ln540">inline const T &amp;QList&lt;T&gt;::at(int i) const</a>
<a name="ln541">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::at&quot;, &quot;index out of range&quot;);</a>
<a name="ln542"> return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t(); }</a>
<a name="ln543">template &lt;typename T&gt;</a>
<a name="ln544">inline const T &amp;QList&lt;T&gt;::operator[](int i) const</a>
<a name="ln545">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::operator[]&quot;, &quot;index out of range&quot;);</a>
<a name="ln546"> return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t(); }</a>
<a name="ln547">template &lt;typename T&gt;</a>
<a name="ln548">inline T &amp;QList&lt;T&gt;::operator[](int i)</a>
<a name="ln549">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::operator[]&quot;, &quot;index out of range&quot;);</a>
<a name="ln550">  detach(); return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t(); }</a>
<a name="ln551">template &lt;typename T&gt;</a>
<a name="ln552">inline void QList&lt;T&gt;::removeAt(int i)</a>
<a name="ln553">{ if(i &gt;= 0 &amp;&amp; i &lt; p.size()) { detach();</a>
<a name="ln554"> node_destruct(reinterpret_cast&lt;Node *&gt;(p.at(i))); p.remove(i); } }</a>
<a name="ln555">template &lt;typename T&gt;</a>
<a name="ln556">inline T QList&lt;T&gt;::takeAt(int i)</a>
<a name="ln557">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::take&quot;, &quot;index out of range&quot;);</a>
<a name="ln558"> detach(); Node *n = reinterpret_cast&lt;Node *&gt;(p.at(i)); T t = std::move(n-&gt;t()); node_destruct(n);</a>
<a name="ln559"> p.remove(i); return t; }</a>
<a name="ln560">template &lt;typename T&gt;</a>
<a name="ln561">inline T QList&lt;T&gt;::takeFirst()</a>
<a name="ln562">{ T t = std::move(first()); removeFirst(); return t; }</a>
<a name="ln563">template &lt;typename T&gt;</a>
<a name="ln564">inline T QList&lt;T&gt;::takeLast()</a>
<a name="ln565">{ T t = std::move(last()); removeLast(); return t; }</a>
<a name="ln566"> </a>
<a name="ln567">template &lt;typename T&gt;</a>
<a name="ln568">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::reserve(int alloc)</a>
<a name="ln569">{</a>
<a name="ln570">    if (d-&gt;alloc &lt; alloc) {</a>
<a name="ln571">        if (d-&gt;ref.isShared())</a>
<a name="ln572">            detach_helper(alloc);</a>
<a name="ln573">        else</a>
<a name="ln574">            p.realloc(alloc);</a>
<a name="ln575">    }</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">template &lt;typename T&gt;</a>
<a name="ln579">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::append(const T &amp;t)</a>
<a name="ln580">{</a>
<a name="ln581">    if (d-&gt;ref.isShared()) {</a>
<a name="ln582">        Node *n = detach_helper_grow(INT_MAX, 1);</a>
<a name="ln583">        QT_TRY {</a>
<a name="ln584">            node_construct(n, t);</a>
<a name="ln585">        } QT_CATCH(...) {</a>
<a name="ln586">            --d-&gt;end;</a>
<a name="ln587">            QT_RETHROW;</a>
<a name="ln588">        }</a>
<a name="ln589">    } else {</a>
<a name="ln590">        if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln591">            Node *n = reinterpret_cast&lt;Node *&gt;(p.append());</a>
<a name="ln592">            QT_TRY {</a>
<a name="ln593">                node_construct(n, t);</a>
<a name="ln594">            } QT_CATCH(...) {</a>
<a name="ln595">                --d-&gt;end;</a>
<a name="ln596">                QT_RETHROW;</a>
<a name="ln597">            }</a>
<a name="ln598">        } else {</a>
<a name="ln599">            Node *n, copy;</a>
<a name="ln600">            node_construct(&amp;copy, t); // t might be a reference to an object in the array</a>
<a name="ln601">            QT_TRY {</a>
<a name="ln602">                n = reinterpret_cast&lt;Node *&gt;(p.append());;</a>
<a name="ln603">            } QT_CATCH(...) {</a>
<a name="ln604">                node_destruct(&amp;copy);</a>
<a name="ln605">                QT_RETHROW;</a>
<a name="ln606">            }</a>
<a name="ln607">            *n = copy;</a>
<a name="ln608">        }</a>
<a name="ln609">    }</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">template &lt;typename T&gt;</a>
<a name="ln613">inline void QList&lt;T&gt;::prepend(const T &amp;t)</a>
<a name="ln614">{</a>
<a name="ln615">    if (d-&gt;ref.isShared()) {</a>
<a name="ln616">        Node *n = detach_helper_grow(0, 1);</a>
<a name="ln617">        QT_TRY {</a>
<a name="ln618">            node_construct(n, t);</a>
<a name="ln619">        } QT_CATCH(...) {</a>
<a name="ln620">            ++d-&gt;begin;</a>
<a name="ln621">            QT_RETHROW;</a>
<a name="ln622">        }</a>
<a name="ln623">    } else {</a>
<a name="ln624">        if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln625">            Node *n = reinterpret_cast&lt;Node *&gt;(p.prepend());</a>
<a name="ln626">            QT_TRY {</a>
<a name="ln627">                node_construct(n, t);</a>
<a name="ln628">            } QT_CATCH(...) {</a>
<a name="ln629">                ++d-&gt;begin;</a>
<a name="ln630">                QT_RETHROW;</a>
<a name="ln631">            }</a>
<a name="ln632">        } else {</a>
<a name="ln633">            Node *n, copy;</a>
<a name="ln634">            node_construct(&amp;copy, t); // t might be a reference to an object in the array</a>
<a name="ln635">            QT_TRY {</a>
<a name="ln636">                n = reinterpret_cast&lt;Node *&gt;(p.prepend());;</a>
<a name="ln637">            } QT_CATCH(...) {</a>
<a name="ln638">                node_destruct(&amp;copy);</a>
<a name="ln639">                QT_RETHROW;</a>
<a name="ln640">            }</a>
<a name="ln641">            *n = copy;</a>
<a name="ln642">        }</a>
<a name="ln643">    }</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">template &lt;typename T&gt;</a>
<a name="ln647">inline void QList&lt;T&gt;::insert(int i, const T &amp;t)</a>
<a name="ln648">{</a>
<a name="ln649">    if (d-&gt;ref.isShared()) {</a>
<a name="ln650">        Node *n = detach_helper_grow(i, 1);</a>
<a name="ln651">        QT_TRY {</a>
<a name="ln652">            node_construct(n, t);</a>
<a name="ln653">        } QT_CATCH(...) {</a>
<a name="ln654">            p.remove(i);</a>
<a name="ln655">            QT_RETHROW;</a>
<a name="ln656">        }</a>
<a name="ln657">    } else {</a>
<a name="ln658">        if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln659">            Node *n = reinterpret_cast&lt;Node *&gt;(p.insert(i));</a>
<a name="ln660">            QT_TRY {</a>
<a name="ln661">                node_construct(n, t);</a>
<a name="ln662">            } QT_CATCH(...) {</a>
<a name="ln663">                p.remove(i);</a>
<a name="ln664">                QT_RETHROW;</a>
<a name="ln665">            }</a>
<a name="ln666">        } else {</a>
<a name="ln667">            Node *n, copy;</a>
<a name="ln668">            node_construct(&amp;copy, t); // t might be a reference to an object in the array</a>
<a name="ln669">            QT_TRY {</a>
<a name="ln670">                n = reinterpret_cast&lt;Node *&gt;(p.insert(i));;</a>
<a name="ln671">            } QT_CATCH(...) {</a>
<a name="ln672">                node_destruct(&amp;copy);</a>
<a name="ln673">                QT_RETHROW;</a>
<a name="ln674">            }</a>
<a name="ln675">            *n = copy;</a>
<a name="ln676">        }</a>
<a name="ln677">    }</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">template &lt;typename T&gt;</a>
<a name="ln681">inline void QList&lt;T&gt;::replace(int i, const T &amp;t)</a>
<a name="ln682">{</a>
<a name="ln683">    Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::replace&quot;, &quot;index out of range&quot;);</a>
<a name="ln684">    detach();</a>
<a name="ln685">    reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t() = t;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">template &lt;typename T&gt;</a>
<a name="ln689">inline void QList&lt;T&gt;::swap(int i, int j)</a>
<a name="ln690">{</a>
<a name="ln691">    Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; p.size(),</a>
<a name="ln692">                &quot;QList&lt;T&gt;::swap&quot;, &quot;index out of range&quot;);</a>
<a name="ln693">    detach();</a>
<a name="ln694">    std::swap(d-&gt;array[d-&gt;begin + i], d-&gt;array[d-&gt;begin + j]);</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">template &lt;typename T&gt;</a>
<a name="ln698">inline void QList&lt;T&gt;::move(int from, int to)</a>
<a name="ln699">{</a>
<a name="ln700">    Q_ASSERT_X(from &gt;= 0 &amp;&amp; from &lt; p.size() &amp;&amp; to &gt;= 0 &amp;&amp; to &lt; p.size(),</a>
<a name="ln701">               &quot;QList&lt;T&gt;::move&quot;, &quot;index out of range&quot;);</a>
<a name="ln702">    detach();</a>
<a name="ln703">    p.move(from, to);</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">template&lt;typename T&gt;</a>
<a name="ln707">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; QList&lt;T&gt;::mid(int pos, int alength) const</a>
<a name="ln708">{</a>
<a name="ln709">    using namespace QtPrivate;</a>
<a name="ln710">    switch (QContainerImplHelper::mid(size(), &amp;pos, &amp;alength)) {</a>
<a name="ln711">    case QContainerImplHelper::Null:</a>
<a name="ln712">    case QContainerImplHelper::Empty:</a>
<a name="ln713">        return QList&lt;T&gt;();</a>
<a name="ln714">    case QContainerImplHelper::Full:</a>
<a name="ln715">        return *this;</a>
<a name="ln716">    case QContainerImplHelper::Subset:</a>
<a name="ln717">        break;</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">    QList&lt;T&gt; cpy;</a>
<a name="ln721">    if (alength &lt;= 0)</a>
<a name="ln722">        return cpy;</a>
<a name="ln723">    cpy.reserve(alength);</a>
<a name="ln724">    cpy.d-&gt;end = alength;</a>
<a name="ln725">    QT_TRY {</a>
<a name="ln726">        cpy.node_copy(reinterpret_cast&lt;Node *&gt;(cpy.p.begin()),</a>
<a name="ln727">                      reinterpret_cast&lt;Node *&gt;(cpy.p.end()),</a>
<a name="ln728">                      reinterpret_cast&lt;Node *&gt;(p.begin() + pos));</a>
<a name="ln729">    } QT_CATCH(...) {</a>
<a name="ln730">        // restore the old end</a>
<a name="ln731">        cpy.d-&gt;end = 0;</a>
<a name="ln732">        QT_RETHROW;</a>
<a name="ln733">    }</a>
<a name="ln734">    return cpy;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">template&lt;typename T&gt;</a>
<a name="ln738">Q_OUTOFLINE_TEMPLATE T QList&lt;T&gt;::value(int i) const</a>
<a name="ln739">{</a>
<a name="ln740">    if (i &lt; 0 || i &gt;= p.size()) {</a>
<a name="ln741">        return T();</a>
<a name="ln742">    }</a>
<a name="ln743">    return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t();</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">template&lt;typename T&gt;</a>
<a name="ln747">Q_OUTOFLINE_TEMPLATE T QList&lt;T&gt;::value(int i, const T&amp; defaultValue) const</a>
<a name="ln748">{</a>
<a name="ln749">    return ((i &lt; 0 || i &gt;= p.size()) ? defaultValue : reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t());</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">template &lt;typename T&gt;</a>
<a name="ln753">Q_OUTOFLINE_TEMPLATE typename QList&lt;T&gt;::Node *QList&lt;T&gt;::detach_helper_grow(int i, int c)</a>
<a name="ln754">{</a>
<a name="ln755">    Node *n = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln756">    QListData::Data *x = p.detach_grow(&amp;i, c);</a>
<a name="ln757">    QT_TRY {</a>
<a name="ln758">        node_copy(reinterpret_cast&lt;Node *&gt;(p.begin()),</a>
<a name="ln759">                  reinterpret_cast&lt;Node *&gt;(p.begin() + i), n);</a>
<a name="ln760">    } QT_CATCH(...) {</a>
<a name="ln761">        p.dispose();</a>
<a name="ln762">        d = x;</a>
<a name="ln763">        QT_RETHROW;</a>
<a name="ln764">    }</a>
<a name="ln765">    QT_TRY {</a>
<a name="ln766">        node_copy(reinterpret_cast&lt;Node *&gt;(p.begin() + i + c),</a>
<a name="ln767">                  reinterpret_cast&lt;Node *&gt;(p.end()), n + i);</a>
<a name="ln768">    } QT_CATCH(...) {</a>
<a name="ln769">        node_destruct(reinterpret_cast&lt;Node *&gt;(p.begin()),</a>
<a name="ln770">                      reinterpret_cast&lt;Node *&gt;(p.begin() + i));</a>
<a name="ln771">        p.dispose();</a>
<a name="ln772">        d = x;</a>
<a name="ln773">        QT_RETHROW;</a>
<a name="ln774">    }</a>
<a name="ln775"> </a>
<a name="ln776">    if (!x-&gt;ref.deref())</a>
<a name="ln777">        dealloc(x);</a>
<a name="ln778"> </a>
<a name="ln779">    return reinterpret_cast&lt;Node *&gt;(p.begin() + i);</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">template &lt;typename T&gt;</a>
<a name="ln783">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::detach_helper(int alloc)</a>
<a name="ln784">{</a>
<a name="ln785">    Node *n = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln786">    QListData::Data *x = p.detach(alloc);</a>
<a name="ln787">    QT_TRY {</a>
<a name="ln788">        node_copy(reinterpret_cast&lt;Node *&gt;(p.begin()), reinterpret_cast&lt;Node *&gt;(p.end()), n);</a>
<a name="ln789">    } QT_CATCH(...) {</a>
<a name="ln790">        p.dispose();</a>
<a name="ln791">        d = x;</a>
<a name="ln792">        QT_RETHROW;</a>
<a name="ln793">    }</a>
<a name="ln794"> </a>
<a name="ln795">    if (!x-&gt;ref.deref())</a>
<a name="ln796">        dealloc(x);</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">template &lt;typename T&gt;</a>
<a name="ln800">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::detach_helper()</a>
<a name="ln801">{</a>
<a name="ln802">    detach_helper(d-&gt;alloc);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">template &lt;typename T&gt;</a>
<a name="ln806">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt;::QList(const QList&lt;T&gt; &amp;l)</a>
<a name="ln807">    : QListSpecialMethods&lt;T&gt;(l), d(l.d)</a>
<a name="ln808">{</a>
<a name="ln809">    if (!d-&gt;ref.ref()) {</a>
<a name="ln810">        p.detach(d-&gt;alloc);</a>
<a name="ln811"> </a>
<a name="ln812">        QT_TRY {</a>
<a name="ln813">            node_copy(reinterpret_cast&lt;Node *&gt;(p.begin()),</a>
<a name="ln814">                    reinterpret_cast&lt;Node *&gt;(p.end()),</a>
<a name="ln815">                    reinterpret_cast&lt;Node *&gt;(l.p.begin()));</a>
<a name="ln816">        } QT_CATCH(...) {</a>
<a name="ln817">            QListData::dispose(d);</a>
<a name="ln818">            QT_RETHROW;</a>
<a name="ln819">        }</a>
<a name="ln820">    }</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">template &lt;typename T&gt;</a>
<a name="ln824">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt;::~QList()</a>
<a name="ln825">{</a>
<a name="ln826">    if (!d-&gt;ref.deref())</a>
<a name="ln827">        dealloc(d);</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">template &lt;typename T&gt;</a>
<a name="ln831">Q_OUTOFLINE_TEMPLATE bool QList&lt;T&gt;::operator==(const QList&lt;T&gt; &amp;l) const</a>
<a name="ln832">{</a>
<a name="ln833">    if (d == l.d)</a>
<a name="ln834">        return true;</a>
<a name="ln835">    if (p.size() != l.p.size())</a>
<a name="ln836">        return false;</a>
<a name="ln837">    return this-&gt;op_eq_impl(l, MemoryLayout());</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">template &lt;typename T&gt;</a>
<a name="ln841">inline bool QList&lt;T&gt;::op_eq_impl(const QList &amp;l, QListData::NotArrayCompatibleLayout) const</a>
<a name="ln842">{</a>
<a name="ln843">    Node *i = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln844">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln845">    Node *li = reinterpret_cast&lt;Node *&gt;(l.p.begin());</a>
<a name="ln846">    for (; i != e; ++i, ++li) {</a>
<a name="ln847">        if (!(i-&gt;t() == li-&gt;t()))</a>
<a name="ln848">            return false;</a>
<a name="ln849">    }</a>
<a name="ln850">    return true;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">template &lt;typename T&gt;</a>
<a name="ln854">inline bool QList&lt;T&gt;::op_eq_impl(const QList &amp;l, QListData::ArrayCompatibleLayout) const</a>
<a name="ln855">{</a>
<a name="ln856">    const T *lb = reinterpret_cast&lt;const T*&gt;(l.p.begin());</a>
<a name="ln857">    const T *b  = reinterpret_cast&lt;const T*&gt;(p.begin());</a>
<a name="ln858">    const T *e  = reinterpret_cast&lt;const T*&gt;(p.end());</a>
<a name="ln859">    return std::equal(b, e, QT_MAKE_CHECKED_ARRAY_ITERATOR(lb, l.p.size()));</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">template &lt;typename T&gt;</a>
<a name="ln863">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::dealloc(QListData::Data *data)</a>
<a name="ln864">{</a>
<a name="ln865">    node_destruct(reinterpret_cast&lt;Node *&gt;(data-&gt;array + data-&gt;begin),</a>
<a name="ln866">                  reinterpret_cast&lt;Node *&gt;(data-&gt;array + data-&gt;end));</a>
<a name="ln867">    QListData::dispose(data);</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870"> </a>
<a name="ln871">template &lt;typename T&gt;</a>
<a name="ln872">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::clear()</a>
<a name="ln873">{</a>
<a name="ln874">    *this = QList&lt;T&gt;();</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">template &lt;typename T&gt;</a>
<a name="ln878">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::removeAll(const T &amp;_t)</a>
<a name="ln879">{</a>
<a name="ln880">    int index = indexOf(_t);</a>
<a name="ln881">    if (index == -1)</a>
<a name="ln882">        return 0;</a>
<a name="ln883"> </a>
<a name="ln884">    const T t = _t;</a>
<a name="ln885">    detach();</a>
<a name="ln886"> </a>
<a name="ln887">    Node *i = reinterpret_cast&lt;Node *&gt;(p.at(index));</a>
<a name="ln888">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln889">    Node *n = i;</a>
<a name="ln890">    node_destruct(i);</a>
<a name="ln891">    while (++i != e) {</a>
<a name="ln892">        if (i-&gt;t() == t)</a>
<a name="ln893">            node_destruct(i);</a>
<a name="ln894">        else</a>
<a name="ln895">            *n++ = *i;</a>
<a name="ln896">    }</a>
<a name="ln897"> </a>
<a name="ln898">    int removedCount = int(e - n);</a>
<a name="ln899">    d-&gt;end -= removedCount;</a>
<a name="ln900">    return removedCount;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">template &lt;typename T&gt;</a>
<a name="ln904">Q_OUTOFLINE_TEMPLATE bool QList&lt;T&gt;::removeOne(const T &amp;_t)</a>
<a name="ln905">{</a>
<a name="ln906">    int index = indexOf(_t);</a>
<a name="ln907">    if (index != -1) {</a>
<a name="ln908">        removeAt(index);</a>
<a name="ln909">        return true;</a>
<a name="ln910">    }</a>
<a name="ln911">    return false;</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">template &lt;typename T&gt;</a>
<a name="ln915">Q_OUTOFLINE_TEMPLATE typename QList&lt;T&gt;::iterator QList&lt;T&gt;::erase(typename QList&lt;T&gt;::iterator afirst,</a>
<a name="ln916">                                                                 typename QList&lt;T&gt;::iterator alast)</a>
<a name="ln917">{</a>
<a name="ln918">    Q_ASSERT_X(isValidIterator(afirst), &quot;QList::erase&quot;, &quot;The specified iterator argument 'afirst' is invalid&quot;);</a>
<a name="ln919">    Q_ASSERT_X(isValidIterator(alast), &quot;QList::erase&quot;, &quot;The specified iterator argument 'alast' is invalid&quot;);</a>
<a name="ln920"> </a>
<a name="ln921">    if (d-&gt;ref.isShared()) {</a>
<a name="ln922">        // ### A block is erased and a detach is needed. We should shrink and only copy relevant items.</a>
<a name="ln923">        int offsetfirst = int(afirst.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln924">        int offsetlast = int(alast.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln925">        afirst = begin(); // implies detach()</a>
<a name="ln926">        alast = afirst;</a>
<a name="ln927">        afirst += offsetfirst;</a>
<a name="ln928">        alast += offsetlast;</a>
<a name="ln929">    }</a>
<a name="ln930"> </a>
<a name="ln931">    for (Node *n = afirst.i; n &lt; alast.i; ++n)</a>
<a name="ln932">        node_destruct(n);</a>
<a name="ln933">    int idx = afirst - begin();</a>
<a name="ln934">    p.remove(idx, alast - afirst);</a>
<a name="ln935">    return begin() + idx;</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">template &lt;typename T&gt;</a>
<a name="ln939">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; &amp;QList&lt;T&gt;::operator+=(const QList&lt;T&gt; &amp;l)</a>
<a name="ln940">{</a>
<a name="ln941">    if (!l.isEmpty()) {</a>
<a name="ln942">        if (d == &amp;QListData::shared_null) {</a>
<a name="ln943">            *this = l;</a>
<a name="ln944">        } else {</a>
<a name="ln945">            Node *n = (d-&gt;ref.isShared())</a>
<a name="ln946">                      ? detach_helper_grow(INT_MAX, l.size())</a>
<a name="ln947">                      : reinterpret_cast&lt;Node *&gt;(p.append(l.p));</a>
<a name="ln948">            QT_TRY {</a>
<a name="ln949">                node_copy(n, reinterpret_cast&lt;Node *&gt;(p.end()),</a>
<a name="ln950">                          reinterpret_cast&lt;Node *&gt;(l.p.begin()));</a>
<a name="ln951">            } QT_CATCH(...) {</a>
<a name="ln952">                // restore the old end</a>
<a name="ln953">                d-&gt;end -= int(reinterpret_cast&lt;Node *&gt;(p.end()) - n);</a>
<a name="ln954">                QT_RETHROW;</a>
<a name="ln955">            }</a>
<a name="ln956">        }</a>
<a name="ln957">    }</a>
<a name="ln958">    return *this;</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">template &lt;typename T&gt;</a>
<a name="ln962">inline void QList&lt;T&gt;::append(const QList&lt;T&gt; &amp;t)</a>
<a name="ln963">{</a>
<a name="ln964">    *this += t;</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">template &lt;typename T&gt;</a>
<a name="ln968">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::indexOf(const T &amp;t, int from) const</a>
<a name="ln969">{</a>
<a name="ln970">    if (from &lt; 0)</a>
<a name="ln971">        from = qMax(from + p.size(), 0);</a>
<a name="ln972">    if (from &lt; p.size()) {</a>
<a name="ln973">        Node *n = reinterpret_cast&lt;Node *&gt;(p.at(from -1));</a>
<a name="ln974">        Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln975">        while (++n != e)</a>
<a name="ln976">            if (n-&gt;t() == t)</a>
<a name="ln977">                return int(n - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln978">    }</a>
<a name="ln979">    return -1;</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">template &lt;typename T&gt;</a>
<a name="ln983">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::lastIndexOf(const T &amp;t, int from) const</a>
<a name="ln984">{</a>
<a name="ln985">    if (from &lt; 0)</a>
<a name="ln986">        from += p.size();</a>
<a name="ln987">    else if (from &gt;= p.size())</a>
<a name="ln988">        from = p.size()-1;</a>
<a name="ln989">    if (from &gt;= 0) {</a>
<a name="ln990">        Node *b = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln991">        Node *n = reinterpret_cast&lt;Node *&gt;(p.at(from + 1));</a>
<a name="ln992">        while (n-- != b) {</a>
<a name="ln993">            if (n-&gt;t() == t)</a>
<a name="ln994">                return n - b;</a>
<a name="ln995">        }</a>
<a name="ln996">    }</a>
<a name="ln997">    return -1;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">template &lt;typename T&gt;</a>
<a name="ln1001">Q_OUTOFLINE_TEMPLATE bool QList&lt;T&gt;::contains(const T &amp;t) const</a>
<a name="ln1002">{</a>
<a name="ln1003">    return contains_impl(t, MemoryLayout());</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">template &lt;typename T&gt;</a>
<a name="ln1007">inline bool QList&lt;T&gt;::contains_impl(const T &amp;t, QListData::NotArrayCompatibleLayout) const</a>
<a name="ln1008">{</a>
<a name="ln1009">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln1010">    Node *i = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln1011">    for (; i != e; ++i)</a>
<a name="ln1012">        if (i-&gt;t() == t)</a>
<a name="ln1013">            return true;</a>
<a name="ln1014">    return false;</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">template &lt;typename T&gt;</a>
<a name="ln1018">inline bool QList&lt;T&gt;::contains_impl(const T &amp;t, QListData::ArrayCompatibleLayout) const</a>
<a name="ln1019">{</a>
<a name="ln1020">    const T *b = reinterpret_cast&lt;const T*&gt;(p.begin());</a>
<a name="ln1021">    const T *e = reinterpret_cast&lt;const T*&gt;(p.end());</a>
<a name="ln1022">    return std::find(b, e, t) != e;</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">template &lt;typename T&gt;</a>
<a name="ln1026">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::count(const T &amp;t) const</a>
<a name="ln1027">{</a>
<a name="ln1028">    return this-&gt;count_impl(t, MemoryLayout());</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">template &lt;typename T&gt;</a>
<a name="ln1032">inline int QList&lt;T&gt;::count_impl(const T &amp;t, QListData::NotArrayCompatibleLayout) const</a>
<a name="ln1033">{</a>
<a name="ln1034">    int c = 0;</a>
<a name="ln1035">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln1036">    Node *i = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln1037">    for (; i != e; ++i)</a>
<a name="ln1038">        if (i-&gt;t() == t)</a>
<a name="ln1039">            ++c;</a>
<a name="ln1040">    return c;</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">template &lt;typename T&gt;</a>
<a name="ln1044">inline int QList&lt;T&gt;::count_impl(const T &amp;t, QListData::ArrayCompatibleLayout) const</a>
<a name="ln1045">{</a>
<a name="ln1046">    return int(std::count(reinterpret_cast&lt;const T*&gt;(p.begin()),</a>
<a name="ln1047">                          reinterpret_cast&lt;const T*&gt;(p.end()),</a>
<a name="ln1048">                          t));</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">Q_DECLARE_SEQUENTIAL_ITERATOR(List)</a>
<a name="ln1052">Q_DECLARE_MUTABLE_SEQUENTIAL_ITERATOR(List)</a>
<a name="ln1053"> </a>
<a name="ln1054">template &lt;typename T&gt;</a>
<a name="ln1055">uint qHash(const QList&lt;T&gt; &amp;key, uint seed = 0)</a>
<a name="ln1056">    Q_DECL_NOEXCEPT_EXPR(noexcept(qHashRange(key.cbegin(), key.cend(), seed)))</a>
<a name="ln1057">{</a>
<a name="ln1058">    return qHashRange(key.cbegin(), key.cend(), seed);</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">template &lt;typename T&gt;</a>
<a name="ln1062">bool operator&lt;(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1063">    Q_DECL_NOEXCEPT_EXPR(noexcept(std::lexicographical_compare(lhs.begin(), lhs.end(),</a>
<a name="ln1064">                                                               rhs.begin(), rhs.end())))</a>
<a name="ln1065">{</a>
<a name="ln1066">    return std::lexicographical_compare(lhs.begin(), lhs.end(),</a>
<a name="ln1067">                                        rhs.begin(), rhs.end());</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">template &lt;typename T&gt;</a>
<a name="ln1071">inline bool operator&gt;(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1072">    Q_DECL_NOEXCEPT_EXPR(noexcept(lhs &lt; rhs))</a>
<a name="ln1073">{</a>
<a name="ln1074">    return rhs &lt; lhs;</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">template &lt;typename T&gt;</a>
<a name="ln1078">inline bool operator&lt;=(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1079">    Q_DECL_NOEXCEPT_EXPR(noexcept(lhs &lt; rhs))</a>
<a name="ln1080">{</a>
<a name="ln1081">    return !(lhs &gt; rhs);</a>
<a name="ln1082">}</a>
<a name="ln1083"> </a>
<a name="ln1084">template &lt;typename T&gt;</a>
<a name="ln1085">inline bool operator&gt;=(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1086">    Q_DECL_NOEXCEPT_EXPR(noexcept(lhs &lt; rhs))</a>
<a name="ln1087">{</a>
<a name="ln1088">    return !(lhs &lt; rhs);</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">QT_END_NAMESPACE</a>
<a name="ln1092"> </a>
<a name="ln1093">#include &lt;QtCore/qbytearraylist.h&gt;</a>
<a name="ln1094">#include &lt;QtCore/qstringlist.h&gt;</a>
<a name="ln1095"> </a>
<a name="ln1096">#ifdef Q_CC_MSVC</a>
<a name="ln1097">#pragma warning( pop )</a>
<a name="ln1098">#endif</a>
<a name="ln1099"> </a>
<a name="ln1100">#endif // QLIST_H</a>

</code></pre>
<div class="balloon" rel="224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'iterator' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>
<div class="balloon" rel="276"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'const_iterator' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
