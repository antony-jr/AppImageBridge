
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qobjectdefs.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Copyright (C) 2016 Intel Corporation.</a>
<a name="ln5">** Contact: https://www.qt.io/licensing/</a>
<a name="ln6">**</a>
<a name="ln7">** This file is part of the QtCore module of the Qt Toolkit.</a>
<a name="ln8">**</a>
<a name="ln9">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln10">** Commercial License Usage</a>
<a name="ln11">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln12">** accordance with the commercial license agreement provided with the</a>
<a name="ln13">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln14">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln15">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln16">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln17">**</a>
<a name="ln18">** GNU Lesser General Public License Usage</a>
<a name="ln19">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln20">** General Public License version 3 as published by the Free Software</a>
<a name="ln21">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln22">** packaging of this file. Please review the following information to</a>
<a name="ln23">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln24">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln25">**</a>
<a name="ln26">** GNU General Public License Usage</a>
<a name="ln27">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln28">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln29">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln30">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln31">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln32">** included in the packaging of this file. Please review the following</a>
<a name="ln33">** information to ensure the GNU General Public License requirements will</a>
<a name="ln34">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln35">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln36">**</a>
<a name="ln37">** $QT_END_LICENSE$</a>
<a name="ln38">**</a>
<a name="ln39">****************************************************************************/</a>
<a name="ln40"> </a>
<a name="ln41">#ifndef QOBJECTDEFS_H</a>
<a name="ln42">#define QOBJECTDEFS_H</a>
<a name="ln43"> </a>
<a name="ln44">#if defined(__OBJC__) &amp;&amp; !defined(__cplusplus)</a>
<a name="ln45">#  warning &quot;File built in Objective-C mode (.m), but using Qt requires Objective-C++ (.mm)&quot;</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;QtCore/qnamespace.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;QtCore/qobjectdefs_impl.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">QT_BEGIN_NAMESPACE</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">class QByteArray;</a>
<a name="ln56">struct QArrayData;</a>
<a name="ln57">typedef QArrayData QByteArrayData;</a>
<a name="ln58"> </a>
<a name="ln59">class QString;</a>
<a name="ln60">#ifndef Q_MOC_OUTPUT_REVISION</a>
<a name="ln61">#define Q_MOC_OUTPUT_REVISION 67</a>
<a name="ln62">#endif</a>
<a name="ln63"> </a>
<a name="ln64">// The following macros can be defined by tools that understand Qt</a>
<a name="ln65">// to have the information from the macro.</a>
<a name="ln66">#ifndef QT_ANNOTATE_CLASS</a>
<a name="ln67"># ifndef Q_COMPILER_VARIADIC_MACROS</a>
<a name="ln68">#  define QT_ANNOTATE_CLASS(type, x)</a>
<a name="ln69"># else</a>
<a name="ln70">#  define QT_ANNOTATE_CLASS(type, ...)</a>
<a name="ln71"># endif</a>
<a name="ln72">#endif</a>
<a name="ln73">#ifndef QT_ANNOTATE_CLASS2</a>
<a name="ln74"># define QT_ANNOTATE_CLASS2(type, a1, a2)</a>
<a name="ln75">#endif</a>
<a name="ln76">#ifndef QT_ANNOTATE_FUNCTION</a>
<a name="ln77"># define QT_ANNOTATE_FUNCTION(x)</a>
<a name="ln78">#endif</a>
<a name="ln79">#ifndef QT_ANNOTATE_ACCESS_SPECIFIER</a>
<a name="ln80"># define QT_ANNOTATE_ACCESS_SPECIFIER(x)</a>
<a name="ln81">#endif</a>
<a name="ln82"> </a>
<a name="ln83">// The following macros are our &quot;extensions&quot; to C++</a>
<a name="ln84">// They are used, strictly speaking, only by the moc.</a>
<a name="ln85"> </a>
<a name="ln86">#ifndef Q_MOC_RUN</a>
<a name="ln87">#ifndef QT_NO_META_MACROS</a>
<a name="ln88"># if defined(QT_NO_KEYWORDS)</a>
<a name="ln89">#  define QT_NO_EMIT</a>
<a name="ln90"># else</a>
<a name="ln91">#   ifndef QT_NO_SIGNALS_SLOTS_KEYWORDS</a>
<a name="ln92">#     define slots Q_SLOTS</a>
<a name="ln93">#     define signals Q_SIGNALS</a>
<a name="ln94">#   endif</a>
<a name="ln95"># endif</a>
<a name="ln96"># define Q_SLOTS QT_ANNOTATE_ACCESS_SPECIFIER(qt_slot)</a>
<a name="ln97"># define Q_SIGNALS public QT_ANNOTATE_ACCESS_SPECIFIER(qt_signal)</a>
<a name="ln98"># define Q_PRIVATE_SLOT(d, signature) QT_ANNOTATE_CLASS2(qt_private_slot, d, signature)</a>
<a name="ln99"># define Q_EMIT</a>
<a name="ln100">#ifndef QT_NO_EMIT</a>
<a name="ln101"># define emit</a>
<a name="ln102">#endif</a>
<a name="ln103">#ifndef Q_CLASSINFO</a>
<a name="ln104"># define Q_CLASSINFO(name, value)</a>
<a name="ln105">#endif</a>
<a name="ln106">#define Q_PLUGIN_METADATA(x) QT_ANNOTATE_CLASS(qt_plugin_metadata, x)</a>
<a name="ln107">#define Q_INTERFACES(x) QT_ANNOTATE_CLASS(qt_interfaces, x)</a>
<a name="ln108">#ifdef Q_COMPILER_VARIADIC_MACROS</a>
<a name="ln109"># define Q_PROPERTY(...) QT_ANNOTATE_CLASS(qt_property, __VA_ARGS__)</a>
<a name="ln110">#else</a>
<a name="ln111"># define Q_PROPERTY(text) QT_ANNOTATE_CLASS(qt_property, text)</a>
<a name="ln112">#endif</a>
<a name="ln113">#define Q_PRIVATE_PROPERTY(d, text) QT_ANNOTATE_CLASS2(qt_private_property, d, text)</a>
<a name="ln114">#ifndef Q_REVISION</a>
<a name="ln115"># define Q_REVISION(v)</a>
<a name="ln116">#endif</a>
<a name="ln117">#define Q_OVERRIDE(text) QT_ANNOTATE_CLASS(qt_override, text)</a>
<a name="ln118">#define QDOC_PROPERTY(text) QT_ANNOTATE_CLASS(qt_qdoc_property, text)</a>
<a name="ln119">#define Q_ENUMS(x) QT_ANNOTATE_CLASS(qt_enums, x)</a>
<a name="ln120">#define Q_FLAGS(x) QT_ANNOTATE_CLASS(qt_enums, x)</a>
<a name="ln121">#define Q_ENUM_IMPL(ENUM) \</a>
<a name="ln122">    friend Q_DECL_CONSTEXPR const QMetaObject *qt_getEnumMetaObject(ENUM) Q_DECL_NOEXCEPT { return &amp;staticMetaObject; } \</a>
<a name="ln123">    friend Q_DECL_CONSTEXPR const char *qt_getEnumName(ENUM) Q_DECL_NOEXCEPT { return #ENUM; }</a>
<a name="ln124">#define Q_ENUM(x) Q_ENUMS(x) Q_ENUM_IMPL(x)</a>
<a name="ln125">#define Q_FLAG(x) Q_FLAGS(x) Q_ENUM_IMPL(x)</a>
<a name="ln126">#define Q_ENUM_NS_IMPL(ENUM) \</a>
<a name="ln127">    inline Q_DECL_CONSTEXPR const QMetaObject *qt_getEnumMetaObject(ENUM) Q_DECL_NOEXCEPT { return &amp;staticMetaObject; } \</a>
<a name="ln128">    inline Q_DECL_CONSTEXPR const char *qt_getEnumName(ENUM) Q_DECL_NOEXCEPT { return #ENUM; }</a>
<a name="ln129">#define Q_ENUM_NS(x) Q_ENUMS(x) Q_ENUM_NS_IMPL(x)</a>
<a name="ln130">#define Q_FLAG_NS(x) Q_FLAGS(x) Q_ENUM_NS_IMPL(x)</a>
<a name="ln131">#define Q_SCRIPTABLE QT_ANNOTATE_FUNCTION(qt_scriptable)</a>
<a name="ln132">#define Q_INVOKABLE  QT_ANNOTATE_FUNCTION(qt_invokable)</a>
<a name="ln133">#define Q_SIGNAL QT_ANNOTATE_FUNCTION(qt_signal)</a>
<a name="ln134">#define Q_SLOT QT_ANNOTATE_FUNCTION(qt_slot)</a>
<a name="ln135">#endif // QT_NO_META_MACROS</a>
<a name="ln136"> </a>
<a name="ln137">#ifndef QT_NO_TRANSLATION</a>
<a name="ln138">// full set of tr functions</a>
<a name="ln139">#  define QT_TR_FUNCTIONS \</a>
<a name="ln140">    static inline QString tr(const char *s, const char *c = nullptr, int n = -1) \</a>
<a name="ln141">        { return staticMetaObject.tr(s, c, n); } \</a>
<a name="ln142">    QT_DEPRECATED static inline QString trUtf8(const char *s, const char *c = nullptr, int n = -1) \</a>
<a name="ln143">        { return staticMetaObject.tr(s, c, n); }</a>
<a name="ln144">#else</a>
<a name="ln145">// inherit the ones from QObject</a>
<a name="ln146"># define QT_TR_FUNCTIONS</a>
<a name="ln147">#endif</a>
<a name="ln148"> </a>
<a name="ln149">// ### Qt6: remove</a>
<a name="ln150">#define Q_OBJECT_CHECK  /* empty, unused since Qt 5.2 */</a>
<a name="ln151"> </a>
<a name="ln152">#if defined(Q_CC_INTEL)</a>
<a name="ln153">// Cannot redefine the visibility of a method in an exported class</a>
<a name="ln154"># define Q_DECL_HIDDEN_STATIC_METACALL</a>
<a name="ln155">#else</a>
<a name="ln156"># define Q_DECL_HIDDEN_STATIC_METACALL Q_DECL_HIDDEN</a>
<a name="ln157">#endif</a>
<a name="ln158"> </a>
<a name="ln159">#if defined(Q_CC_CLANG) &amp;&amp; Q_CC_CLANG &gt;= 306</a>
<a name="ln160">#  define Q_OBJECT_NO_OVERRIDE_WARNING      QT_WARNING_DISABLE_CLANG(&quot;-Winconsistent-missing-override&quot;)</a>
<a name="ln161">#elif defined(Q_CC_GNU) &amp;&amp; !defined(Q_CC_INTEL) &amp;&amp; Q_CC_GNU &gt;= 501</a>
<a name="ln162">#  define Q_OBJECT_NO_OVERRIDE_WARNING      QT_WARNING_DISABLE_GCC(&quot;-Wsuggest-override&quot;)</a>
<a name="ln163">#else</a>
<a name="ln164">#  define Q_OBJECT_NO_OVERRIDE_WARNING</a>
<a name="ln165">#endif</a>
<a name="ln166"> </a>
<a name="ln167">#if defined(Q_CC_GNU) &amp;&amp; !defined(Q_CC_INTEL) &amp;&amp; Q_CC_GNU &gt;= 600</a>
<a name="ln168">#  define Q_OBJECT_NO_ATTRIBUTES_WARNING    QT_WARNING_DISABLE_GCC(&quot;-Wattributes&quot;)</a>
<a name="ln169">#else</a>
<a name="ln170">#  define Q_OBJECT_NO_ATTRIBUTES_WARNING</a>
<a name="ln171">#endif</a>
<a name="ln172"> </a>
<a name="ln173">/* qmake ignore Q_OBJECT */</a>
<a name="ln174">#define Q_OBJECT \</a>
<a name="ln175">public: \</a>
<a name="ln176">    QT_WARNING_PUSH \</a>
<a name="ln177">    Q_OBJECT_NO_OVERRIDE_WARNING \</a>
<a name="ln178">    static const QMetaObject staticMetaObject; \</a>
<a name="ln179">    virtual const QMetaObject *metaObject() const; \</a>
<a name="ln180">    virtual void *qt_metacast(const char *); \</a>
<a name="ln181">    virtual int qt_metacall(QMetaObject::Call, int, void **); \</a>
<a name="ln182">    QT_TR_FUNCTIONS \</a>
<a name="ln183">private: \</a>
<a name="ln184">    Q_OBJECT_NO_ATTRIBUTES_WARNING \</a>
<a name="ln185">    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \</a>
<a name="ln186">    QT_WARNING_POP \</a>
<a name="ln187">    struct QPrivateSignal {}; \</a>
<a name="ln188">    QT_ANNOTATE_CLASS(qt_qobject, &quot;&quot;)</a>
<a name="ln189"> </a>
<a name="ln190">/* qmake ignore Q_OBJECT */</a>
<a name="ln191">#define Q_OBJECT_FAKE Q_OBJECT QT_ANNOTATE_CLASS(qt_fake, &quot;&quot;)</a>
<a name="ln192"> </a>
<a name="ln193">#ifndef QT_NO_META_MACROS</a>
<a name="ln194">/* qmake ignore Q_GADGET */</a>
<a name="ln195">#define Q_GADGET \</a>
<a name="ln196">public: \</a>
<a name="ln197">    static const QMetaObject staticMetaObject; \</a>
<a name="ln198">    void qt_check_for_QGADGET_macro(); \</a>
<a name="ln199">    typedef void QtGadgetHelper; \</a>
<a name="ln200">private: \</a>
<a name="ln201">    QT_WARNING_PUSH \</a>
<a name="ln202">    Q_OBJECT_NO_ATTRIBUTES_WARNING \</a>
<a name="ln203">    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \</a>
<a name="ln204">    QT_WARNING_POP \</a>
<a name="ln205">    QT_ANNOTATE_CLASS(qt_qgadget, &quot;&quot;) \</a>
<a name="ln206">    /*end*/</a>
<a name="ln207"> </a>
<a name="ln208">/* qmake ignore Q_NAMESPACE */</a>
<a name="ln209">#define Q_NAMESPACE \</a>
<a name="ln210">    extern const QMetaObject staticMetaObject; \</a>
<a name="ln211">    QT_ANNOTATE_CLASS(qt_qnamespace, &quot;&quot;) \</a>
<a name="ln212">    /*end*/</a>
<a name="ln213"> </a>
<a name="ln214">#endif // QT_NO_META_MACROS</a>
<a name="ln215"> </a>
<a name="ln216">#else // Q_MOC_RUN</a>
<a name="ln217">#define slots slots</a>
<a name="ln218">#define signals signals</a>
<a name="ln219">#define Q_SLOTS Q_SLOTS</a>
<a name="ln220">#define Q_SIGNALS Q_SIGNALS</a>
<a name="ln221">#define Q_CLASSINFO(name, value) Q_CLASSINFO(name, value)</a>
<a name="ln222">#define Q_INTERFACES(x) Q_INTERFACES(x)</a>
<a name="ln223">#define Q_PROPERTY(text) Q_PROPERTY(text)</a>
<a name="ln224">#define Q_PRIVATE_PROPERTY(d, text) Q_PRIVATE_PROPERTY(d, text)</a>
<a name="ln225">#define Q_REVISION(v) Q_REVISION(v)</a>
<a name="ln226">#define Q_OVERRIDE(text) Q_OVERRIDE(text)</a>
<a name="ln227">#define Q_ENUMS(x) Q_ENUMS(x)</a>
<a name="ln228">#define Q_FLAGS(x) Q_FLAGS(x)</a>
<a name="ln229">#define Q_ENUM(x) Q_ENUM(x)</a>
<a name="ln230">#define Q_FLAGS(x) Q_FLAGS(x)</a>
<a name="ln231"> /* qmake ignore Q_OBJECT */</a>
<a name="ln232">#define Q_OBJECT Q_OBJECT</a>
<a name="ln233"> /* qmake ignore Q_OBJECT */</a>
<a name="ln234">#define Q_OBJECT_FAKE Q_OBJECT_FAKE</a>
<a name="ln235"> /* qmake ignore Q_GADGET */</a>
<a name="ln236">#define Q_GADGET Q_GADGET</a>
<a name="ln237">#define Q_SCRIPTABLE Q_SCRIPTABLE</a>
<a name="ln238">#define Q_INVOKABLE Q_INVOKABLE</a>
<a name="ln239">#define Q_SIGNAL Q_SIGNAL</a>
<a name="ln240">#define Q_SLOT Q_SLOT</a>
<a name="ln241">#endif //Q_MOC_RUN</a>
<a name="ln242"> </a>
<a name="ln243">#ifndef QT_NO_META_MACROS</a>
<a name="ln244">// macro for onaming members</a>
<a name="ln245">#ifdef METHOD</a>
<a name="ln246">#undef METHOD</a>
<a name="ln247">#endif</a>
<a name="ln248">#ifdef SLOT</a>
<a name="ln249">#undef SLOT</a>
<a name="ln250">#endif</a>
<a name="ln251">#ifdef SIGNAL</a>
<a name="ln252">#undef SIGNAL</a>
<a name="ln253">#endif</a>
<a name="ln254">#endif // QT_NO_META_MACROS</a>
<a name="ln255"> </a>
<a name="ln256">Q_CORE_EXPORT const char *qFlagLocation(const char *method);</a>
<a name="ln257"> </a>
<a name="ln258">#ifndef QT_NO_META_MACROS</a>
<a name="ln259">#ifndef QT_NO_DEBUG</a>
<a name="ln260"># define QLOCATION &quot;\0&quot; __FILE__ &quot;:&quot; QT_STRINGIFY(__LINE__)</a>
<a name="ln261"># ifndef QT_NO_KEYWORDS</a>
<a name="ln262">#  define METHOD(a)   qFlagLocation(&quot;0&quot;#a QLOCATION)</a>
<a name="ln263"># endif</a>
<a name="ln264"># define SLOT(a)     qFlagLocation(&quot;1&quot;#a QLOCATION)</a>
<a name="ln265"># define SIGNAL(a)   qFlagLocation(&quot;2&quot;#a QLOCATION)</a>
<a name="ln266">#else</a>
<a name="ln267"># ifndef QT_NO_KEYWORDS</a>
<a name="ln268">#  define METHOD(a)   &quot;0&quot;#a</a>
<a name="ln269"># endif</a>
<a name="ln270"># define SLOT(a)     &quot;1&quot;#a</a>
<a name="ln271"># define SIGNAL(a)   &quot;2&quot;#a</a>
<a name="ln272">#endif</a>
<a name="ln273"> </a>
<a name="ln274">#define QMETHOD_CODE  0                        // member type codes</a>
<a name="ln275">#define QSLOT_CODE    1</a>
<a name="ln276">#define QSIGNAL_CODE  2</a>
<a name="ln277">#endif // QT_NO_META_MACROS</a>
<a name="ln278"> </a>
<a name="ln279">#define Q_ARG(type, data) QArgument&lt;type &gt;(#type, data)</a>
<a name="ln280">#define Q_RETURN_ARG(type, data) QReturnArgument&lt;type &gt;(#type, data)</a>
<a name="ln281"> </a>
<a name="ln282">class QObject;</a>
<a name="ln283">class QMetaMethod;</a>
<a name="ln284">class QMetaEnum;</a>
<a name="ln285">class QMetaProperty;</a>
<a name="ln286">class QMetaClassInfo;</a>
<a name="ln287"> </a>
<a name="ln288"> </a>
<a name="ln289">class Q_CORE_EXPORT QGenericArgument</a>
<a name="ln290">{</a>
<a name="ln291">public:</a>
<a name="ln292">    inline QGenericArgument(const char *aName = nullptr, const void *aData = nullptr)</a>
<a name="ln293">        : _data(aData), _name(aName) {}</a>
<a name="ln294">    inline void *data() const { return const_cast&lt;void *&gt;(_data); }</a>
<a name="ln295">    inline const char *name() const { return _name; }</a>
<a name="ln296"> </a>
<a name="ln297">private:</a>
<a name="ln298">    const void *_data;</a>
<a name="ln299">    const char *_name;</a>
<a name="ln300">};</a>
<a name="ln301"> </a>
<a name="ln302">class Q_CORE_EXPORT QGenericReturnArgument: public QGenericArgument</a>
<a name="ln303">{</a>
<a name="ln304">public:</a>
<a name="ln305">    inline QGenericReturnArgument(const char *aName = nullptr, void *aData = nullptr)</a>
<a name="ln306">        : QGenericArgument(aName, aData)</a>
<a name="ln307">        {}</a>
<a name="ln308">};</a>
<a name="ln309"> </a>
<a name="ln310">template &lt;class T&gt;</a>
<a name="ln311">class QArgument: public QGenericArgument</a>
<a name="ln312">{</a>
<a name="ln313">public:</a>
<a name="ln314">    inline QArgument(const char *aName, const T &amp;aData)</a>
<a name="ln315">        : QGenericArgument(aName, static_cast&lt;const void *&gt;(&amp;aData))</a>
<a name="ln316">        {}</a>
<a name="ln317">};</a>
<a name="ln318">template &lt;class T&gt;</a>
<a name="ln319">class QArgument&lt;T &amp;&gt;: public QGenericArgument</a>
<a name="ln320">{</a>
<a name="ln321">public:</a>
<a name="ln322">    inline QArgument(const char *aName, T &amp;aData)</a>
<a name="ln323">        : QGenericArgument(aName, static_cast&lt;const void *&gt;(&amp;aData))</a>
<a name="ln324">        {}</a>
<a name="ln325">};</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">template &lt;typename T&gt;</a>
<a name="ln329">class QReturnArgument: public QGenericReturnArgument</a>
<a name="ln330">{</a>
<a name="ln331">public:</a>
<a name="ln332">    inline QReturnArgument(const char *aName, T &amp;aData)</a>
<a name="ln333">        : QGenericReturnArgument(aName, static_cast&lt;void *&gt;(&amp;aData))</a>
<a name="ln334">        {}</a>
<a name="ln335">};</a>
<a name="ln336"> </a>
<a name="ln337">struct Q_CORE_EXPORT QMetaObject</a>
<a name="ln338">{</a>
<a name="ln339">    class Connection;</a>
<a name="ln340">    const char *className() const;</a>
<a name="ln341">    const QMetaObject *superClass() const;</a>
<a name="ln342"> </a>
<a name="ln343">    bool inherits(const QMetaObject *metaObject) const Q_DECL_NOEXCEPT;</a>
<a name="ln344">    QObject *cast(QObject *obj) const;</a>
<a name="ln345">    const QObject *cast(const QObject *obj) const;</a>
<a name="ln346"> </a>
<a name="ln347">#if !defined(QT_NO_TRANSLATION) || defined(Q_CLANG_QDOC)</a>
<a name="ln348">    QString tr(const char *s, const char *c, int n = -1) const;</a>
<a name="ln349">#endif // QT_NO_TRANSLATION</a>
<a name="ln350"> </a>
<a name="ln351">    int methodOffset() const;</a>
<a name="ln352">    int enumeratorOffset() const;</a>
<a name="ln353">    int propertyOffset() const;</a>
<a name="ln354">    int classInfoOffset() const;</a>
<a name="ln355"> </a>
<a name="ln356">    int constructorCount() const;</a>
<a name="ln357">    int methodCount() const;</a>
<a name="ln358">    int enumeratorCount() const;</a>
<a name="ln359">    int propertyCount() const;</a>
<a name="ln360">    int classInfoCount() const;</a>
<a name="ln361"> </a>
<a name="ln362">    int indexOfConstructor(const char *constructor) const;</a>
<a name="ln363">    int indexOfMethod(const char *method) const;</a>
<a name="ln364">    int indexOfSignal(const char *signal) const;</a>
<a name="ln365">    int indexOfSlot(const char *slot) const;</a>
<a name="ln366">    int indexOfEnumerator(const char *name) const;</a>
<a name="ln367">    int indexOfProperty(const char *name) const;</a>
<a name="ln368">    int indexOfClassInfo(const char *name) const;</a>
<a name="ln369"> </a>
<a name="ln370">    QMetaMethod constructor(int index) const;</a>
<a name="ln371">    QMetaMethod method(int index) const;</a>
<a name="ln372">    QMetaEnum enumerator(int index) const;</a>
<a name="ln373">    QMetaProperty property(int index) const;</a>
<a name="ln374">    QMetaClassInfo classInfo(int index) const;</a>
<a name="ln375">    QMetaProperty userProperty() const;</a>
<a name="ln376"> </a>
<a name="ln377">    static bool checkConnectArgs(const char *signal, const char *method);</a>
<a name="ln378">    static bool checkConnectArgs(const QMetaMethod &amp;signal,</a>
<a name="ln379">                                 const QMetaMethod &amp;method);</a>
<a name="ln380">    static QByteArray normalizedSignature(const char *method);</a>
<a name="ln381">    static QByteArray normalizedType(const char *type);</a>
<a name="ln382"> </a>
<a name="ln383">    // internal index-based connect</a>
<a name="ln384">    static Connection connect(const QObject *sender, int signal_index,</a>
<a name="ln385">                        const QObject *receiver, int method_index,</a>
<a name="ln386">                        int type = 0, int *types = nullptr);</a>
<a name="ln387">    // internal index-based disconnect</a>
<a name="ln388">    static bool disconnect(const QObject *sender, int signal_index,</a>
<a name="ln389">                           const QObject *receiver, int method_index);</a>
<a name="ln390">    static bool disconnectOne(const QObject *sender, int signal_index,</a>
<a name="ln391">                              const QObject *receiver, int method_index);</a>
<a name="ln392">    // internal slot-name based connect</a>
<a name="ln393">    static void connectSlotsByName(QObject *o);</a>
<a name="ln394"> </a>
<a name="ln395">    // internal index-based signal activation</a>
<a name="ln396">    static void activate(QObject *sender, int signal_index, void **argv);</a>
<a name="ln397">    static void activate(QObject *sender, const QMetaObject *, int local_signal_index, void **argv);</a>
<a name="ln398">    static void activate(QObject *sender, int signal_offset, int local_signal_index, void **argv);</a>
<a name="ln399"> </a>
<a name="ln400">    static bool invokeMethod(QObject *obj, const char *member,</a>
<a name="ln401">                             Qt::ConnectionType,</a>
<a name="ln402">                             QGenericReturnArgument ret,</a>
<a name="ln403">                             QGenericArgument val0 = QGenericArgument(nullptr),</a>
<a name="ln404">                             QGenericArgument val1 = QGenericArgument(),</a>
<a name="ln405">                             QGenericArgument val2 = QGenericArgument(),</a>
<a name="ln406">                             QGenericArgument val3 = QGenericArgument(),</a>
<a name="ln407">                             QGenericArgument val4 = QGenericArgument(),</a>
<a name="ln408">                             QGenericArgument val5 = QGenericArgument(),</a>
<a name="ln409">                             QGenericArgument val6 = QGenericArgument(),</a>
<a name="ln410">                             QGenericArgument val7 = QGenericArgument(),</a>
<a name="ln411">                             QGenericArgument val8 = QGenericArgument(),</a>
<a name="ln412">                             QGenericArgument val9 = QGenericArgument());</a>
<a name="ln413"> </a>
<a name="ln414">    static inline bool invokeMethod(QObject *obj, const char *member,</a>
<a name="ln415">                             QGenericReturnArgument ret,</a>
<a name="ln416">                             QGenericArgument val0 = QGenericArgument(nullptr),</a>
<a name="ln417">                             QGenericArgument val1 = QGenericArgument(),</a>
<a name="ln418">                             QGenericArgument val2 = QGenericArgument(),</a>
<a name="ln419">                             QGenericArgument val3 = QGenericArgument(),</a>
<a name="ln420">                             QGenericArgument val4 = QGenericArgument(),</a>
<a name="ln421">                             QGenericArgument val5 = QGenericArgument(),</a>
<a name="ln422">                             QGenericArgument val6 = QGenericArgument(),</a>
<a name="ln423">                             QGenericArgument val7 = QGenericArgument(),</a>
<a name="ln424">                             QGenericArgument val8 = QGenericArgument(),</a>
<a name="ln425">                             QGenericArgument val9 = QGenericArgument())</a>
<a name="ln426">    {</a>
<a name="ln427">        return invokeMethod(obj, member, Qt::AutoConnection, ret, val0, val1, val2, val3,</a>
<a name="ln428">                val4, val5, val6, val7, val8, val9);</a>
<a name="ln429">    }</a>
<a name="ln430"> </a>
<a name="ln431">    static inline bool invokeMethod(QObject *obj, const char *member,</a>
<a name="ln432">                             Qt::ConnectionType type,</a>
<a name="ln433">                             QGenericArgument val0 = QGenericArgument(nullptr),</a>
<a name="ln434">                             QGenericArgument val1 = QGenericArgument(),</a>
<a name="ln435">                             QGenericArgument val2 = QGenericArgument(),</a>
<a name="ln436">                             QGenericArgument val3 = QGenericArgument(),</a>
<a name="ln437">                             QGenericArgument val4 = QGenericArgument(),</a>
<a name="ln438">                             QGenericArgument val5 = QGenericArgument(),</a>
<a name="ln439">                             QGenericArgument val6 = QGenericArgument(),</a>
<a name="ln440">                             QGenericArgument val7 = QGenericArgument(),</a>
<a name="ln441">                             QGenericArgument val8 = QGenericArgument(),</a>
<a name="ln442">                             QGenericArgument val9 = QGenericArgument())</a>
<a name="ln443">    {</a>
<a name="ln444">        return invokeMethod(obj, member, type, QGenericReturnArgument(), val0, val1, val2,</a>
<a name="ln445">                                 val3, val4, val5, val6, val7, val8, val9);</a>
<a name="ln446">    }</a>
<a name="ln447"> </a>
<a name="ln448">    static inline bool invokeMethod(QObject *obj, const char *member,</a>
<a name="ln449">                             QGenericArgument val0 = QGenericArgument(nullptr),</a>
<a name="ln450">                             QGenericArgument val1 = QGenericArgument(),</a>
<a name="ln451">                             QGenericArgument val2 = QGenericArgument(),</a>
<a name="ln452">                             QGenericArgument val3 = QGenericArgument(),</a>
<a name="ln453">                             QGenericArgument val4 = QGenericArgument(),</a>
<a name="ln454">                             QGenericArgument val5 = QGenericArgument(),</a>
<a name="ln455">                             QGenericArgument val6 = QGenericArgument(),</a>
<a name="ln456">                             QGenericArgument val7 = QGenericArgument(),</a>
<a name="ln457">                             QGenericArgument val8 = QGenericArgument(),</a>
<a name="ln458">                             QGenericArgument val9 = QGenericArgument())</a>
<a name="ln459">    {</a>
<a name="ln460">        return invokeMethod(obj, member, Qt::AutoConnection, QGenericReturnArgument(), val0,</a>
<a name="ln461">                val1, val2, val3, val4, val5, val6, val7, val8, val9);</a>
<a name="ln462">    }</a>
<a name="ln463"> </a>
<a name="ln464">#ifdef Q_CLANG_QDOC</a>
<a name="ln465">    template&lt;typename Functor, typename FunctorReturnType&gt;</a>
<a name="ln466">    static bool invokeMethod(QObject *context, Functor function, Qt::ConnectionType type = Qt::AutoConnection, FunctorReturnType *ret = nullptr);</a>
<a name="ln467">    template&lt;typename Functor, typename FunctorReturnType&gt;</a>
<a name="ln468">    static bool invokeMethod(QObject *context, Functor function, FunctorReturnType *ret);</a>
<a name="ln469">#else</a>
<a name="ln470"> </a>
<a name="ln471">    // invokeMethod() for member function pointer</a>
<a name="ln472">    template &lt;typename Func&gt;</a>
<a name="ln473">    static typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func&gt;::IsPointerToMemberFunction</a>
<a name="ln474">                                   &amp;&amp; !std::is_convertible&lt;Func, const char*&gt;::value</a>
<a name="ln475">                                   &amp;&amp; QtPrivate::FunctionPointer&lt;Func&gt;::ArgumentCount == 0, bool&gt;::type</a>
<a name="ln476">    invokeMethod(typename QtPrivate::FunctionPointer&lt;Func&gt;::Object *object,</a>
<a name="ln477">                 Func function,</a>
<a name="ln478">                 Qt::ConnectionType type = Qt::AutoConnection,</a>
<a name="ln479">                 typename QtPrivate::FunctionPointer&lt;Func&gt;::ReturnType *ret = nullptr)</a>
<a name="ln480">    {</a>
<a name="ln481">        return invokeMethodImpl(object, new QtPrivate::QSlotObjectWithNoArgs&lt;Func&gt;(function), type, ret);</a>
<a name="ln482">    }</a>
<a name="ln483"> </a>
<a name="ln484">    template &lt;typename Func&gt;</a>
<a name="ln485">    static typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func&gt;::IsPointerToMemberFunction</a>
<a name="ln486">                                   &amp;&amp; !std::is_convertible&lt;Func, const char*&gt;::value</a>
<a name="ln487">                                   &amp;&amp; QtPrivate::FunctionPointer&lt;Func&gt;::ArgumentCount == 0, bool&gt;::type</a>
<a name="ln488">    invokeMethod(typename QtPrivate::FunctionPointer&lt;Func&gt;::Object *object,</a>
<a name="ln489">                 Func function,</a>
<a name="ln490">                 typename QtPrivate::FunctionPointer&lt;Func&gt;::ReturnType *ret)</a>
<a name="ln491">    {</a>
<a name="ln492">        return invokeMethodImpl(object, new QtPrivate::QSlotObjectWithNoArgs&lt;Func&gt;(function), Qt::AutoConnection, ret);</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">    // invokeMethod() for function pointer (not member)</a>
<a name="ln496">    template &lt;typename Func&gt;</a>
<a name="ln497">    static typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Func&gt;::IsPointerToMemberFunction</a>
<a name="ln498">                                   &amp;&amp; !std::is_convertible&lt;Func, const char*&gt;::value</a>
<a name="ln499">                                   &amp;&amp; QtPrivate::FunctionPointer&lt;Func&gt;::ArgumentCount == 0, bool&gt;::type</a>
<a name="ln500">    invokeMethod(QObject *context, Func function,</a>
<a name="ln501">                 Qt::ConnectionType type = Qt::AutoConnection,</a>
<a name="ln502">                 typename QtPrivate::FunctionPointer&lt;Func&gt;::ReturnType *ret = nullptr)</a>
<a name="ln503">    {</a>
<a name="ln504">        return invokeMethodImpl(context, new QtPrivate::QFunctorSlotObjectWithNoArgsImplicitReturn&lt;Func&gt;(function), type, ret);</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">    template &lt;typename Func&gt;</a>
<a name="ln508">    static typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Func&gt;::IsPointerToMemberFunction</a>
<a name="ln509">                                   &amp;&amp; !std::is_convertible&lt;Func, const char*&gt;::value</a>
<a name="ln510">                                   &amp;&amp; QtPrivate::FunctionPointer&lt;Func&gt;::ArgumentCount == 0, bool&gt;::type</a>
<a name="ln511">    invokeMethod(QObject *context, Func function,</a>
<a name="ln512">                 typename QtPrivate::FunctionPointer&lt;Func&gt;::ReturnType *ret)</a>
<a name="ln513">    {</a>
<a name="ln514">        return invokeMethodImpl(context, new QtPrivate::QFunctorSlotObjectWithNoArgsImplicitReturn&lt;Func&gt;(function), Qt::AutoConnection, ret);</a>
<a name="ln515">    }</a>
<a name="ln516"> </a>
<a name="ln517">    // invokeMethod() for Functor</a>
<a name="ln518">    template &lt;typename Func&gt;</a>
<a name="ln519">    static typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Func&gt;::IsPointerToMemberFunction</a>
<a name="ln520">                                   &amp;&amp; QtPrivate::FunctionPointer&lt;Func&gt;::ArgumentCount == -1</a>
<a name="ln521">                                   &amp;&amp; !std::is_convertible&lt;Func, const char*&gt;::value, bool&gt;::type</a>
<a name="ln522">    invokeMethod(QObject *context, Func function,</a>
<a name="ln523">                 Qt::ConnectionType type = Qt::AutoConnection, decltype(function()) *ret = nullptr)</a>
<a name="ln524">    {</a>
<a name="ln525">        return invokeMethodImpl(context,</a>
<a name="ln526">                                new QtPrivate::QFunctorSlotObjectWithNoArgs&lt;Func, decltype(function())&gt;(function),</a>
<a name="ln527">                                type,</a>
<a name="ln528">                                ret);</a>
<a name="ln529">    }</a>
<a name="ln530"> </a>
<a name="ln531">    template &lt;typename Func&gt;</a>
<a name="ln532">    static typename std::enable_if&lt;!QtPrivate::FunctionPointer&lt;Func&gt;::IsPointerToMemberFunction</a>
<a name="ln533">                                   &amp;&amp; QtPrivate::FunctionPointer&lt;Func&gt;::ArgumentCount == -1</a>
<a name="ln534">                                   &amp;&amp; !std::is_convertible&lt;Func, const char*&gt;::value, bool&gt;::type</a>
<a name="ln535">    invokeMethod(QObject *context, Func function, typename std::result_of&lt;Func()&gt;::type *ret)</a>
<a name="ln536">    {</a>
<a name="ln537">        return invokeMethodImpl(context,</a>
<a name="ln538">                                new QtPrivate::QFunctorSlotObjectWithNoArgs&lt;Func, decltype(function())&gt;(function),</a>
<a name="ln539">                                Qt::AutoConnection,</a>
<a name="ln540">                                ret);</a>
<a name="ln541">    }</a>
<a name="ln542"> </a>
<a name="ln543">#endif</a>
<a name="ln544"> </a>
<a name="ln545">    QObject *newInstance(QGenericArgument val0 = QGenericArgument(nullptr),</a>
<a name="ln546">                         QGenericArgument val1 = QGenericArgument(),</a>
<a name="ln547">                         QGenericArgument val2 = QGenericArgument(),</a>
<a name="ln548">                         QGenericArgument val3 = QGenericArgument(),</a>
<a name="ln549">                         QGenericArgument val4 = QGenericArgument(),</a>
<a name="ln550">                         QGenericArgument val5 = QGenericArgument(),</a>
<a name="ln551">                         QGenericArgument val6 = QGenericArgument(),</a>
<a name="ln552">                         QGenericArgument val7 = QGenericArgument(),</a>
<a name="ln553">                         QGenericArgument val8 = QGenericArgument(),</a>
<a name="ln554">                         QGenericArgument val9 = QGenericArgument()) const;</a>
<a name="ln555"> </a>
<a name="ln556">    enum Call {</a>
<a name="ln557">        InvokeMetaMethod,</a>
<a name="ln558">        ReadProperty,</a>
<a name="ln559">        WriteProperty,</a>
<a name="ln560">        ResetProperty,</a>
<a name="ln561">        QueryPropertyDesignable,</a>
<a name="ln562">        QueryPropertyScriptable,</a>
<a name="ln563">        QueryPropertyStored,</a>
<a name="ln564">        QueryPropertyEditable,</a>
<a name="ln565">        QueryPropertyUser,</a>
<a name="ln566">        CreateInstance,</a>
<a name="ln567">        IndexOfMethod,</a>
<a name="ln568">        RegisterPropertyMetaType,</a>
<a name="ln569">        RegisterMethodArgumentMetaType</a>
<a name="ln570">    };</a>
<a name="ln571"> </a>
<a name="ln572">    int static_metacall(Call, int, void **) const;</a>
<a name="ln573">    static int metacall(QObject *, Call, int, void **);</a>
<a name="ln574"> </a>
<a name="ln575">    struct { // private data</a>
<a name="ln576">        const QMetaObject *superdata;</a>
<a name="ln577">        const QByteArrayData *stringdata;</a>
<a name="ln578">        const uint *data;</a>
<a name="ln579">        typedef void (*StaticMetacallFunction)(QObject *, QMetaObject::Call, int, void **);</a>
<a name="ln580">        StaticMetacallFunction static_metacall;</a>
<a name="ln581">        const QMetaObject * const *relatedMetaObjects;</a>
<a name="ln582">        void *extradata; //reserved for future use</a>
<a name="ln583">    } d;</a>
<a name="ln584"> </a>
<a name="ln585">private:</a>
<a name="ln586">    static bool invokeMethodImpl(QObject *object, QtPrivate::QSlotObjectBase *slot, Qt::ConnectionType type, void *ret);</a>
<a name="ln587">};</a>
<a name="ln588"> </a>
<a name="ln589">class Q_CORE_EXPORT QMetaObject::Connection {</a>
<a name="ln590">    void *d_ptr; //QObjectPrivate::Connection*</a>
<a name="ln591">    explicit Connection(void *data) : d_ptr(data) {  }</a>
<a name="ln592">    friend class QObject;</a>
<a name="ln593">    friend class QObjectPrivate;</a>
<a name="ln594">    friend struct QMetaObject;</a>
<a name="ln595">    bool isConnected_helper() const;</a>
<a name="ln596">public:</a>
<a name="ln597">    ~Connection();</a>
<a name="ln598">    Connection();</a>
<a name="ln599">    Connection(const Connection &amp;other);</a>
<a name="ln600">    Connection &amp;operator=(const Connection &amp;other);</a>
<a name="ln601">#ifdef Q_QDOC</a>
<a name="ln602">    operator bool() const;</a>
<a name="ln603">#else</a>
<a name="ln604">    typedef void *Connection::*RestrictedBool;</a>
<a name="ln605">    operator RestrictedBool() const { return d_ptr &amp;&amp; isConnected_helper() ? &amp;Connection::d_ptr : nullptr; }</a>
<a name="ln606">#endif</a>
<a name="ln607"> </a>
<a name="ln608">    Connection(Connection &amp;&amp;o) Q_DECL_NOTHROW : d_ptr(o.d_ptr) { o.d_ptr = nullptr; }</a>
<a name="ln609">    Connection &amp;operator=(Connection &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln610">    { qSwap(d_ptr, other.d_ptr); return *this; }</a>
<a name="ln611">};</a>
<a name="ln612"> </a>
<a name="ln613">inline const QMetaObject *QMetaObject::superClass() const</a>
<a name="ln614">{ return d.superdata; }</a>
<a name="ln615"> </a>
<a name="ln616">namespace QtPrivate {</a>
<a name="ln617">    /* Trait that tells is a the Object has a Q_OBJECT macro */</a>
<a name="ln618">    template &lt;typename Object&gt; struct HasQ_OBJECT_Macro {</a>
<a name="ln619">        template &lt;typename T&gt;</a>
<a name="ln620">        static char test(int (T::*)(QMetaObject::Call, int, void **));</a>
<a name="ln621">        static int test(int (Object::*)(QMetaObject::Call, int, void **));</a>
<a name="ln622">        enum { Value =  sizeof(test(&amp;Object::qt_metacall)) == sizeof(int) };</a>
<a name="ln623">    };</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">QT_END_NAMESPACE</a>
<a name="ln627"> </a>
<a name="ln628">#endif // QOBJECTDEFS_H</a>

</code></pre>
<div class="balloon" rel="589"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'QMetaObject::Connection' class implements the copy assignment operator, but lacks a copy constructor. It is dangerous to use such a class.</p></div>
<div class="balloon" rel="589"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'QMetaObject::Connection' class implements the move assignment operator, but lacks a move constructor. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
