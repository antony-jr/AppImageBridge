
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qmap.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Contact: https://www.qt.io/licensing/</a>
<a name="ln5">**</a>
<a name="ln6">** This file is part of the QtCore module of the Qt Toolkit.</a>
<a name="ln7">**</a>
<a name="ln8">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln9">** Commercial License Usage</a>
<a name="ln10">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln11">** accordance with the commercial license agreement provided with the</a>
<a name="ln12">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln13">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln14">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln15">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln16">**</a>
<a name="ln17">** GNU Lesser General Public License Usage</a>
<a name="ln18">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln19">** General Public License version 3 as published by the Free Software</a>
<a name="ln20">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln21">** packaging of this file. Please review the following information to</a>
<a name="ln22">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln23">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln24">**</a>
<a name="ln25">** GNU General Public License Usage</a>
<a name="ln26">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln27">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln28">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln29">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln30">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln31">** included in the packaging of this file. Please review the following</a>
<a name="ln32">** information to ensure the GNU General Public License requirements will</a>
<a name="ln33">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln34">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln35">**</a>
<a name="ln36">** $QT_END_LICENSE$</a>
<a name="ln37">**</a>
<a name="ln38">****************************************************************************/</a>
<a name="ln39"> </a>
<a name="ln40">#ifndef QMAP_H</a>
<a name="ln41">#define QMAP_H</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;QtCore/qiterator.h&gt;</a>
<a name="ln44">#include &lt;QtCore/qlist.h&gt;</a>
<a name="ln45">#include &lt;QtCore/qrefcount.h&gt;</a>
<a name="ln46">#include &lt;QtCore/qpair.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#ifdef Q_MAP_DEBUG</a>
<a name="ln49">#include &lt;QtCore/qdebug.h&gt;</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;map&gt;</a>
<a name="ln53">#include &lt;new&gt;</a>
<a name="ln54">#include &lt;functional&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln57">#include &lt;initializer_list&gt;</a>
<a name="ln58">#endif</a>
<a name="ln59"> </a>
<a name="ln60">QT_BEGIN_NAMESPACE</a>
<a name="ln61"> </a>
<a name="ln62">/*</a>
<a name="ln63">    QMap uses qMapLessThanKey() to compare keys. The default</a>
<a name="ln64">    implementation uses operator&lt;(). For pointer types,</a>
<a name="ln65">    qMapLessThanKey() uses std::less (because operator&lt;() on</a>
<a name="ln66">    pointers can be used only between pointers in the same array).</a>
<a name="ln67">*/</a>
<a name="ln68"> </a>
<a name="ln69">template &lt;class Key&gt; inline bool qMapLessThanKey(const Key &amp;key1, const Key &amp;key2)</a>
<a name="ln70">{</a>
<a name="ln71">    return key1 &lt; key2;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">template &lt;class Ptr&gt; inline bool qMapLessThanKey(const Ptr *key1, const Ptr *key2)</a>
<a name="ln75">{</a>
<a name="ln76">    return std::less&lt;const Ptr *&gt;()(key1, key2);</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">struct QMapDataBase;</a>
<a name="ln80">template &lt;class Key, class T&gt; struct QMapData;</a>
<a name="ln81"> </a>
<a name="ln82">struct Q_CORE_EXPORT QMapNodeBase</a>
<a name="ln83">{</a>
<a name="ln84">    quintptr p;</a>
<a name="ln85">    QMapNodeBase *left;</a>
<a name="ln86">    QMapNodeBase *right;</a>
<a name="ln87"> </a>
<a name="ln88">    enum Color { Red = 0, Black = 1 };</a>
<a name="ln89">    enum { Mask = 3 }; // reserve the second bit as well</a>
<a name="ln90"> </a>
<a name="ln91">    const QMapNodeBase *nextNode() const;</a>
<a name="ln92">    QMapNodeBase *nextNode() { return const_cast&lt;QMapNodeBase *&gt;(const_cast&lt;const QMapNodeBase *&gt;(this)-&gt;nextNode()); }</a>
<a name="ln93">    const QMapNodeBase *previousNode() const;</a>
<a name="ln94">    QMapNodeBase *previousNode() { return const_cast&lt;QMapNodeBase *&gt;(const_cast&lt;const QMapNodeBase *&gt;(this)-&gt;previousNode()); }</a>
<a name="ln95"> </a>
<a name="ln96">    Color color() const { return Color(p &amp; 1); }</a>
<a name="ln97">    void setColor(Color c) { if (c == Black) p |= Black; else p &amp;= ~Black; }</a>
<a name="ln98">    QMapNodeBase *parent() const { return reinterpret_cast&lt;QMapNodeBase *&gt;(p &amp; ~Mask); }</a>
<a name="ln99">    void setParent(QMapNodeBase *pp) { p = (p &amp; Mask) | quintptr(pp); }</a>
<a name="ln100"> </a>
<a name="ln101">    template &lt;typename T&gt;</a>
<a name="ln102">    static typename std::enable_if&lt;QTypeInfo&lt;T&gt;::isComplex&gt;::type</a>
<a name="ln103">    callDestructorIfNecessary(T &amp;t) Q_DECL_NOTHROW { Q_UNUSED(t); t.~T(); } // Q_UNUSED: silence MSVC unused 't' warning</a>
<a name="ln104">    template &lt;typename T&gt;</a>
<a name="ln105">    static typename std::enable_if&lt;!QTypeInfo&lt;T&gt;::isComplex&gt;::type</a>
<a name="ln106">    callDestructorIfNecessary(T &amp;) Q_DECL_NOTHROW {}</a>
<a name="ln107">};</a>
<a name="ln108"> </a>
<a name="ln109">template &lt;class Key, class T&gt;</a>
<a name="ln110">struct QMapNode : public QMapNodeBase</a>
<a name="ln111">{</a>
<a name="ln112">    Key key;</a>
<a name="ln113">    T value;</a>
<a name="ln114"> </a>
<a name="ln115">    inline QMapNode *leftNode() const { return static_cast&lt;QMapNode *&gt;(left); }</a>
<a name="ln116">    inline QMapNode *rightNode() const { return static_cast&lt;QMapNode *&gt;(right); }</a>
<a name="ln117"> </a>
<a name="ln118">    inline const QMapNode *nextNode() const { return reinterpret_cast&lt;const QMapNode *&gt;(QMapNodeBase::nextNode()); }</a>
<a name="ln119">    inline const QMapNode *previousNode() const { return static_cast&lt;const QMapNode *&gt;(QMapNodeBase::previousNode()); }</a>
<a name="ln120">    inline QMapNode *nextNode() { return reinterpret_cast&lt;QMapNode *&gt;(QMapNodeBase::nextNode()); }</a>
<a name="ln121">    inline QMapNode *previousNode() { return static_cast&lt;QMapNode *&gt;(QMapNodeBase::previousNode()); }</a>
<a name="ln122"> </a>
<a name="ln123">    QMapNode&lt;Key, T&gt; *copy(QMapData&lt;Key, T&gt; *d) const;</a>
<a name="ln124"> </a>
<a name="ln125">    void destroySubTree()</a>
<a name="ln126">    {</a>
<a name="ln127">        callDestructorIfNecessary(key);</a>
<a name="ln128">        callDestructorIfNecessary(value);</a>
<a name="ln129">        doDestroySubTree(std::integral_constant&lt;bool, QTypeInfo&lt;T&gt;::isComplex || QTypeInfo&lt;Key&gt;::isComplex&gt;());</a>
<a name="ln130">    }</a>
<a name="ln131"> </a>
<a name="ln132">    QMapNode&lt;Key, T&gt; *lowerBound(const Key &amp;key);</a>
<a name="ln133">    QMapNode&lt;Key, T&gt; *upperBound(const Key &amp;key);</a>
<a name="ln134"> </a>
<a name="ln135">private:</a>
<a name="ln136">    void doDestroySubTree(std::false_type) {}</a>
<a name="ln137">    void doDestroySubTree(std::true_type)</a>
<a name="ln138">    {</a>
<a name="ln139">        if (left)</a>
<a name="ln140">            leftNode()-&gt;destroySubTree();</a>
<a name="ln141">        if (right)</a>
<a name="ln142">            rightNode()-&gt;destroySubTree();</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    QMapNode() Q_DECL_EQ_DELETE;</a>
<a name="ln146">    Q_DISABLE_COPY(QMapNode)</a>
<a name="ln147">};</a>
<a name="ln148"> </a>
<a name="ln149">template &lt;class Key, class T&gt;</a>
<a name="ln150">inline QMapNode&lt;Key, T&gt; *QMapNode&lt;Key, T&gt;::lowerBound(const Key &amp;akey)</a>
<a name="ln151">{</a>
<a name="ln152">    QMapNode&lt;Key, T&gt; *n = this;</a>
<a name="ln153">    QMapNode&lt;Key, T&gt; *lastNode = nullptr;</a>
<a name="ln154">    while (n) {</a>
<a name="ln155">        if (!qMapLessThanKey(n-&gt;key, akey)) {</a>
<a name="ln156">            lastNode = n;</a>
<a name="ln157">            n = n-&gt;leftNode();</a>
<a name="ln158">        } else {</a>
<a name="ln159">            n = n-&gt;rightNode();</a>
<a name="ln160">        }</a>
<a name="ln161">    }</a>
<a name="ln162">    return lastNode;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">template &lt;class Key, class T&gt;</a>
<a name="ln166">inline QMapNode&lt;Key, T&gt; *QMapNode&lt;Key, T&gt;::upperBound(const Key &amp;akey)</a>
<a name="ln167">{</a>
<a name="ln168">    QMapNode&lt;Key, T&gt; *n = this;</a>
<a name="ln169">    QMapNode&lt;Key, T&gt; *lastNode = nullptr;</a>
<a name="ln170">    while (n) {</a>
<a name="ln171">        if (qMapLessThanKey(akey, n-&gt;key)) {</a>
<a name="ln172">            lastNode = n;</a>
<a name="ln173">            n = n-&gt;leftNode();</a>
<a name="ln174">        } else {</a>
<a name="ln175">            n = n-&gt;rightNode();</a>
<a name="ln176">        }</a>
<a name="ln177">    }</a>
<a name="ln178">    return lastNode;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">struct Q_CORE_EXPORT QMapDataBase</a>
<a name="ln184">{</a>
<a name="ln185">    QtPrivate::RefCount ref;</a>
<a name="ln186">    int size;</a>
<a name="ln187">    QMapNodeBase header;</a>
<a name="ln188">    QMapNodeBase *mostLeftNode;</a>
<a name="ln189"> </a>
<a name="ln190">    void rotateLeft(QMapNodeBase *x);</a>
<a name="ln191">    void rotateRight(QMapNodeBase *x);</a>
<a name="ln192">    void rebalance(QMapNodeBase *x);</a>
<a name="ln193">    void freeNodeAndRebalance(QMapNodeBase *z);</a>
<a name="ln194">    void recalcMostLeftNode();</a>
<a name="ln195"> </a>
<a name="ln196">    QMapNodeBase *createNode(int size, int alignment, QMapNodeBase *parent, bool left);</a>
<a name="ln197">    void freeTree(QMapNodeBase *root, int alignment);</a>
<a name="ln198"> </a>
<a name="ln199">    static const QMapDataBase shared_null;</a>
<a name="ln200"> </a>
<a name="ln201">    static QMapDataBase *createData();</a>
<a name="ln202">    static void freeData(QMapDataBase *d);</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205">template &lt;class Key, class T&gt;</a>
<a name="ln206">struct QMapData : public QMapDataBase</a>
<a name="ln207">{</a>
<a name="ln208">    typedef QMapNode&lt;Key, T&gt; Node;</a>
<a name="ln209"> </a>
<a name="ln210">    Node *root() const { return static_cast&lt;Node *&gt;(header.left); }</a>
<a name="ln211"> </a>
<a name="ln212">    // using reinterpret_cast because QMapDataBase::header is not</a>
<a name="ln213">    // actually a QMapNode.</a>
<a name="ln214">    const Node *end() const { return reinterpret_cast&lt;const Node *&gt;(&amp;header); }</a>
<a name="ln215">    Node *end() { return reinterpret_cast&lt;Node *&gt;(&amp;header); }</a>
<a name="ln216">    const Node *begin() const { if (root()) return static_cast&lt;const Node*&gt;(mostLeftNode); return end(); }</a>
<a name="ln217">    Node *begin() { if (root()) return static_cast&lt;Node*&gt;(mostLeftNode); return end(); }</a>
<a name="ln218"> </a>
<a name="ln219">    void deleteNode(Node *z);</a>
<a name="ln220">    Node *findNode(const Key &amp;akey) const;</a>
<a name="ln221">    void nodeRange(const Key &amp;akey, Node **firstNode, Node **lastNode);</a>
<a name="ln222"> </a>
<a name="ln223">    Node *createNode(const Key &amp;k, const T &amp;v, Node *parent = nullptr, bool left = false)</a>
<a name="ln224">    {</a>
<a name="ln225">        Node *n = static_cast&lt;Node *&gt;(QMapDataBase::createNode(sizeof(Node), Q_ALIGNOF(Node),</a>
<a name="ln226">                                      parent, left));</a>
<a name="ln227">        QT_TRY {</a>
<a name="ln228">            new (&amp;n-&gt;key) Key(k);</a>
<a name="ln229">            QT_TRY {</a>
<a name="ln230">                new (&amp;n-&gt;value) T(v);</a>
<a name="ln231">            } QT_CATCH(...) {</a>
<a name="ln232">                n-&gt;key.~Key();</a>
<a name="ln233">                QT_RETHROW;</a>
<a name="ln234">            }</a>
<a name="ln235">        } QT_CATCH(...) {</a>
<a name="ln236">            QMapDataBase::freeNodeAndRebalance(n);</a>
<a name="ln237">            QT_RETHROW;</a>
<a name="ln238">        }</a>
<a name="ln239">        return n;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    static QMapData *create() {</a>
<a name="ln243">        return static_cast&lt;QMapData *&gt;(createData());</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    void destroy() {</a>
<a name="ln247">        if (root()) {</a>
<a name="ln248">            root()-&gt;destroySubTree();</a>
<a name="ln249">            freeTree(header.left, Q_ALIGNOF(Node));</a>
<a name="ln250">        }</a>
<a name="ln251">        freeData(this);</a>
<a name="ln252">    }</a>
<a name="ln253">};</a>
<a name="ln254"> </a>
<a name="ln255">template &lt;class Key, class T&gt;</a>
<a name="ln256">QMapNode&lt;Key, T&gt; *QMapNode&lt;Key, T&gt;::copy(QMapData&lt;Key, T&gt; *d) const</a>
<a name="ln257">{</a>
<a name="ln258">    QMapNode&lt;Key, T&gt; *n = d-&gt;createNode(key, value);</a>
<a name="ln259">    n-&gt;setColor(color());</a>
<a name="ln260">    if (left) {</a>
<a name="ln261">        n-&gt;left = leftNode()-&gt;copy(d);</a>
<a name="ln262">        n-&gt;left-&gt;setParent(n);</a>
<a name="ln263">    } else {</a>
<a name="ln264">        n-&gt;left = nullptr;</a>
<a name="ln265">    }</a>
<a name="ln266">    if (right) {</a>
<a name="ln267">        n-&gt;right = rightNode()-&gt;copy(d);</a>
<a name="ln268">        n-&gt;right-&gt;setParent(n);</a>
<a name="ln269">    } else {</a>
<a name="ln270">        n-&gt;right = nullptr;</a>
<a name="ln271">    }</a>
<a name="ln272">    return n;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">template &lt;class Key, class T&gt;</a>
<a name="ln276">void QMapData&lt;Key, T&gt;::deleteNode(QMapNode&lt;Key, T&gt; *z)</a>
<a name="ln277">{</a>
<a name="ln278">    QMapNodeBase::callDestructorIfNecessary(z-&gt;key);</a>
<a name="ln279">    QMapNodeBase::callDestructorIfNecessary(z-&gt;value);</a>
<a name="ln280">    freeNodeAndRebalance(z);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">template &lt;class Key, class T&gt;</a>
<a name="ln284">QMapNode&lt;Key, T&gt; *QMapData&lt;Key, T&gt;::findNode(const Key &amp;akey) const</a>
<a name="ln285">{</a>
<a name="ln286">    if (Node *r = root()) {</a>
<a name="ln287">        Node *lb = r-&gt;lowerBound(akey);</a>
<a name="ln288">        if (lb &amp;&amp; !qMapLessThanKey(akey, lb-&gt;key))</a>
<a name="ln289">            return lb;</a>
<a name="ln290">    }</a>
<a name="ln291">    return nullptr;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294"> </a>
<a name="ln295">template &lt;class Key, class T&gt;</a>
<a name="ln296">void QMapData&lt;Key, T&gt;::nodeRange(const Key &amp;akey, QMapNode&lt;Key, T&gt; **firstNode, QMapNode&lt;Key, T&gt; **lastNode)</a>
<a name="ln297">{</a>
<a name="ln298">    Node *n = root();</a>
<a name="ln299">    Node *l = end();</a>
<a name="ln300">    while (n) {</a>
<a name="ln301">        if (qMapLessThanKey(akey, n-&gt;key)) {</a>
<a name="ln302">            l = n;</a>
<a name="ln303">            n = n-&gt;leftNode();</a>
<a name="ln304">        } else if (qMapLessThanKey(n-&gt;key, akey)) {</a>
<a name="ln305">            n = n-&gt;rightNode();</a>
<a name="ln306">        } else {</a>
<a name="ln307">            *firstNode = n-&gt;leftNode() ? n-&gt;leftNode()-&gt;lowerBound(akey) : nullptr;</a>
<a name="ln308">            if (!*firstNode)</a>
<a name="ln309">                *firstNode = n;</a>
<a name="ln310">            *lastNode = n-&gt;rightNode() ? n-&gt;rightNode()-&gt;upperBound(akey) : nullptr;</a>
<a name="ln311">            if (!*lastNode)</a>
<a name="ln312">                *lastNode = l;</a>
<a name="ln313">            return;</a>
<a name="ln314">        }</a>
<a name="ln315">    }</a>
<a name="ln316">    *firstNode = *lastNode = l;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">template &lt;class Key, class T&gt;</a>
<a name="ln321">class QMap</a>
<a name="ln322">{</a>
<a name="ln323">    typedef QMapNode&lt;Key, T&gt; Node;</a>
<a name="ln324"> </a>
<a name="ln325">    QMapData&lt;Key, T&gt; *d;</a>
<a name="ln326"> </a>
<a name="ln327">public:</a>
<a name="ln328">    inline QMap() Q_DECL_NOTHROW : d(static_cast&lt;QMapData&lt;Key, T&gt; *&gt;(const_cast&lt;QMapDataBase *&gt;(&amp;QMapDataBase::shared_null))) { }</a>
<a name="ln329">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln330">    inline QMap(std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt; list)</a>
<a name="ln331">        : d(static_cast&lt;QMapData&lt;Key, T&gt; *&gt;(const_cast&lt;QMapDataBase *&gt;(&amp;QMapDataBase::shared_null)))</a>
<a name="ln332">    {</a>
<a name="ln333">        for (typename std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt;::const_iterator it = list.begin(); it != list.end(); ++it)</a>
<a name="ln334">            insert(it-&gt;first, it-&gt;second);</a>
<a name="ln335">    }</a>
<a name="ln336">#endif</a>
<a name="ln337">    QMap(const QMap&lt;Key, T&gt; &amp;other);</a>
<a name="ln338"> </a>
<a name="ln339">    inline ~QMap() { if (!d-&gt;ref.deref()) d-&gt;destroy(); }</a>
<a name="ln340"> </a>
<a name="ln341">    QMap&lt;Key, T&gt; &amp;operator=(const QMap&lt;Key, T&gt; &amp;other);</a>
<a name="ln342">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln343">    inline QMap(QMap&lt;Key, T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln344">        : d(other.d)</a>
<a name="ln345">    {</a>
<a name="ln346">        other.d = static_cast&lt;QMapData&lt;Key, T&gt; *&gt;(</a>
<a name="ln347">                const_cast&lt;QMapDataBase *&gt;(&amp;QMapDataBase::shared_null));</a>
<a name="ln348">    }</a>
<a name="ln349"> </a>
<a name="ln350">    inline QMap&lt;Key, T&gt; &amp;operator=(QMap&lt;Key, T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln351">    { QMap moved(std::move(other)); swap(moved); return *this; }</a>
<a name="ln352">#endif</a>
<a name="ln353">    inline void swap(QMap&lt;Key, T&gt; &amp;other) Q_DECL_NOTHROW { qSwap(d, other.d); }</a>
<a name="ln354">    explicit QMap(const typename std::map&lt;Key, T&gt; &amp;other);</a>
<a name="ln355">    std::map&lt;Key, T&gt; toStdMap() const;</a>
<a name="ln356"> </a>
<a name="ln357">    bool operator==(const QMap&lt;Key, T&gt; &amp;other) const;</a>
<a name="ln358">    inline bool operator!=(const QMap&lt;Key, T&gt; &amp;other) const { return !(*this == other); }</a>
<a name="ln359"> </a>
<a name="ln360">    inline int size() const { return d-&gt;size; }</a>
<a name="ln361"> </a>
<a name="ln362">    inline bool isEmpty() const { return d-&gt;size == 0; }</a>
<a name="ln363"> </a>
<a name="ln364">    inline void detach() { if (d-&gt;ref.isShared()) detach_helper(); }</a>
<a name="ln365">    inline bool isDetached() const { return !d-&gt;ref.isShared(); }</a>
<a name="ln366">#if !defined(QT_NO_UNSHARABLE_CONTAINERS)</a>
<a name="ln367">    inline void setSharable(bool sharable)</a>
<a name="ln368">    {</a>
<a name="ln369">        if (sharable == d-&gt;ref.isSharable())</a>
<a name="ln370">            return;</a>
<a name="ln371">        if (!sharable)</a>
<a name="ln372">            detach();</a>
<a name="ln373">        // Don't call on shared_null</a>
<a name="ln374">        d-&gt;ref.setSharable(sharable);</a>
<a name="ln375">    }</a>
<a name="ln376">#endif</a>
<a name="ln377">    inline bool isSharedWith(const QMap&lt;Key, T&gt; &amp;other) const { return d == other.d; }</a>
<a name="ln378"> </a>
<a name="ln379">    void clear();</a>
<a name="ln380"> </a>
<a name="ln381">    int remove(const Key &amp;key);</a>
<a name="ln382">    T take(const Key &amp;key);</a>
<a name="ln383"> </a>
<a name="ln384">    bool contains(const Key &amp;key) const;</a>
<a name="ln385">    const Key key(const T &amp;value, const Key &amp;defaultKey = Key()) const;</a>
<a name="ln386">    const T value(const Key &amp;key, const T &amp;defaultValue = T()) const;</a>
<a name="ln387">    T &amp;operator[](const Key &amp;key);</a>
<a name="ln388">    const T operator[](const Key &amp;key) const;</a>
<a name="ln389"> </a>
<a name="ln390">    QList&lt;Key&gt; uniqueKeys() const;</a>
<a name="ln391">    QList&lt;Key&gt; keys() const;</a>
<a name="ln392">    QList&lt;Key&gt; keys(const T &amp;value) const;</a>
<a name="ln393">    QList&lt;T&gt; values() const;</a>
<a name="ln394">    QList&lt;T&gt; values(const Key &amp;key) const;</a>
<a name="ln395">    int count(const Key &amp;key) const;</a>
<a name="ln396"> </a>
<a name="ln397">    inline const Key &amp;firstKey() const { Q_ASSERT(!isEmpty()); return constBegin().key(); }</a>
<a name="ln398">    inline const Key &amp;lastKey() const { Q_ASSERT(!isEmpty()); return (constEnd() - 1).key(); }</a>
<a name="ln399"> </a>
<a name="ln400">    inline T &amp;first() { Q_ASSERT(!isEmpty()); return *begin(); }</a>
<a name="ln401">    inline const T &amp;first() const { Q_ASSERT(!isEmpty()); return *constBegin(); }</a>
<a name="ln402">    inline T &amp;last() { Q_ASSERT(!isEmpty()); return *(end() - 1); }</a>
<a name="ln403">    inline const T &amp;last() const { Q_ASSERT(!isEmpty()); return *(constEnd() - 1); }</a>
<a name="ln404"> </a>
<a name="ln405">    class const_iterator;</a>
<a name="ln406"> </a>
<a name="ln407">    class iterator</a>
<a name="ln408">    {</a>
<a name="ln409">        friend class const_iterator;</a>
<a name="ln410">        Node *i;</a>
<a name="ln411"> </a>
<a name="ln412">    public:</a>
<a name="ln413">        typedef std::bidirectional_iterator_tag iterator_category;</a>
<a name="ln414">        typedef qptrdiff difference_type;</a>
<a name="ln415">        typedef T value_type;</a>
<a name="ln416">        typedef T *pointer;</a>
<a name="ln417">        typedef T &amp;reference;</a>
<a name="ln418"> </a>
<a name="ln419">        inline iterator() : i(nullptr) { }</a>
<a name="ln420">        inline iterator(Node *node) : i(node) { }</a>
<a name="ln421"> </a>
<a name="ln422">        inline const Key &amp;key() const { return i-&gt;key; }</a>
<a name="ln423">        inline T &amp;value() const { return i-&gt;value; }</a>
<a name="ln424">        inline T &amp;operator*() const { return i-&gt;value; }</a>
<a name="ln425">        inline T *operator-&gt;() const { return &amp;i-&gt;value; }</a>
<a name="ln426">        inline bool operator==(const iterator &amp;o) const { return i == o.i; }</a>
<a name="ln427">        inline bool operator!=(const iterator &amp;o) const { return i != o.i; }</a>
<a name="ln428"> </a>
<a name="ln429">        inline iterator &amp;operator++() {</a>
<a name="ln430">            i = i-&gt;nextNode();</a>
<a name="ln431">            return *this;</a>
<a name="ln432">        }</a>
<a name="ln433">        inline iterator operator++(int) {</a>
<a name="ln434">            iterator r = *this;</a>
<a name="ln435">            i = i-&gt;nextNode();</a>
<a name="ln436">            return r;</a>
<a name="ln437">        }</a>
<a name="ln438">        inline iterator &amp;operator--() {</a>
<a name="ln439">            i = i-&gt;previousNode();</a>
<a name="ln440">            return *this;</a>
<a name="ln441">        }</a>
<a name="ln442">        inline iterator operator--(int) {</a>
<a name="ln443">            iterator r = *this;</a>
<a name="ln444">            i = i-&gt;previousNode();</a>
<a name="ln445">            return r;</a>
<a name="ln446">        }</a>
<a name="ln447">        inline iterator operator+(int j) const</a>
<a name="ln448">        { iterator r = *this; if (j &gt; 0) while (j--) ++r; else while (j++) --r; return r; }</a>
<a name="ln449">        inline iterator operator-(int j) const { return operator+(-j); }</a>
<a name="ln450">        inline iterator &amp;operator+=(int j) { return *this = *this + j; }</a>
<a name="ln451">        inline iterator &amp;operator-=(int j) { return *this = *this - j; }</a>
<a name="ln452"> </a>
<a name="ln453">#ifndef QT_STRICT_ITERATORS</a>
<a name="ln454">    public:</a>
<a name="ln455">        inline bool operator==(const const_iterator &amp;o) const</a>
<a name="ln456">            { return i == o.i; }</a>
<a name="ln457">        inline bool operator!=(const const_iterator &amp;o) const</a>
<a name="ln458">            { return i != o.i; }</a>
<a name="ln459">#endif</a>
<a name="ln460">        friend class QMap&lt;Key, T&gt;;</a>
<a name="ln461">    };</a>
<a name="ln462">    friend class iterator;</a>
<a name="ln463"> </a>
<a name="ln464">    class const_iterator</a>
<a name="ln465">    {</a>
<a name="ln466">        friend class iterator;</a>
<a name="ln467">        const Node *i;</a>
<a name="ln468"> </a>
<a name="ln469">    public:</a>
<a name="ln470">        typedef std::bidirectional_iterator_tag iterator_category;</a>
<a name="ln471">        typedef qptrdiff difference_type;</a>
<a name="ln472">        typedef T value_type;</a>
<a name="ln473">        typedef const T *pointer;</a>
<a name="ln474">        typedef const T &amp;reference;</a>
<a name="ln475"> </a>
<a name="ln476">        Q_DECL_CONSTEXPR inline const_iterator() : i(nullptr) { }</a>
<a name="ln477">        inline const_iterator(const Node *node) : i(node) { }</a>
<a name="ln478">#ifdef QT_STRICT_ITERATORS</a>
<a name="ln479">        explicit inline const_iterator(const iterator &amp;o)</a>
<a name="ln480">#else</a>
<a name="ln481">        inline const_iterator(const iterator &amp;o)</a>
<a name="ln482">#endif</a>
<a name="ln483">        { i = o.i; }</a>
<a name="ln484"> </a>
<a name="ln485">        inline const Key &amp;key() const { return i-&gt;key; }</a>
<a name="ln486">        inline const T &amp;value() const { return i-&gt;value; }</a>
<a name="ln487">        inline const T &amp;operator*() const { return i-&gt;value; }</a>
<a name="ln488">        inline const T *operator-&gt;() const { return &amp;i-&gt;value; }</a>
<a name="ln489">        Q_DECL_CONSTEXPR inline bool operator==(const const_iterator &amp;o) const { return i == o.i; }</a>
<a name="ln490">        Q_DECL_CONSTEXPR inline bool operator!=(const const_iterator &amp;o) const { return i != o.i; }</a>
<a name="ln491"> </a>
<a name="ln492">        inline const_iterator &amp;operator++() {</a>
<a name="ln493">            i = i-&gt;nextNode();</a>
<a name="ln494">            return *this;</a>
<a name="ln495">        }</a>
<a name="ln496">        inline const_iterator operator++(int) {</a>
<a name="ln497">            const_iterator r = *this;</a>
<a name="ln498">            i = i-&gt;nextNode();</a>
<a name="ln499">            return r;</a>
<a name="ln500">        }</a>
<a name="ln501">        inline const_iterator &amp;operator--() {</a>
<a name="ln502">            i = i-&gt;previousNode();</a>
<a name="ln503">            return *this;</a>
<a name="ln504">        }</a>
<a name="ln505">        inline const_iterator operator--(int) {</a>
<a name="ln506">            const_iterator r = *this;</a>
<a name="ln507">            i = i-&gt;previousNode();</a>
<a name="ln508">            return r;</a>
<a name="ln509">        }</a>
<a name="ln510">        inline const_iterator operator+(int j) const</a>
<a name="ln511">        { const_iterator r = *this; if (j &gt; 0) while (j--) ++r; else while (j++) --r; return r; }</a>
<a name="ln512">        inline const_iterator operator-(int j) const { return operator+(-j); }</a>
<a name="ln513">        inline const_iterator &amp;operator+=(int j) { return *this = *this + j; }</a>
<a name="ln514">        inline const_iterator &amp;operator-=(int j) { return *this = *this - j; }</a>
<a name="ln515"> </a>
<a name="ln516">#ifdef QT_STRICT_ITERATORS</a>
<a name="ln517">    private:</a>
<a name="ln518">        inline bool operator==(const iterator &amp;o) const { return operator==(const_iterator(o)); }</a>
<a name="ln519">        inline bool operator!=(const iterator &amp;o) const { return operator!=(const_iterator(o)); }</a>
<a name="ln520">#endif</a>
<a name="ln521">        friend class QMap&lt;Key, T&gt;;</a>
<a name="ln522">    };</a>
<a name="ln523">    friend class const_iterator;</a>
<a name="ln524"> </a>
<a name="ln525">    class key_iterator</a>
<a name="ln526">    {</a>
<a name="ln527">        const_iterator i;</a>
<a name="ln528"> </a>
<a name="ln529">    public:</a>
<a name="ln530">        typedef typename const_iterator::iterator_category iterator_category;</a>
<a name="ln531">        typedef typename const_iterator::difference_type difference_type;</a>
<a name="ln532">        typedef Key value_type;</a>
<a name="ln533">        typedef const Key *pointer;</a>
<a name="ln534">        typedef const Key &amp;reference;</a>
<a name="ln535"> </a>
<a name="ln536">        key_iterator() = default;</a>
<a name="ln537">        explicit key_iterator(const_iterator o) : i(o) { }</a>
<a name="ln538"> </a>
<a name="ln539">        const Key &amp;operator*() const { return i.key(); }</a>
<a name="ln540">        const Key *operator-&gt;() const { return &amp;i.key(); }</a>
<a name="ln541">        bool operator==(key_iterator o) const { return i == o.i; }</a>
<a name="ln542">        bool operator!=(key_iterator o) const { return i != o.i; }</a>
<a name="ln543"> </a>
<a name="ln544">        inline key_iterator &amp;operator++() { ++i; return *this; }</a>
<a name="ln545">        inline key_iterator operator++(int) { return key_iterator(i++);}</a>
<a name="ln546">        inline key_iterator &amp;operator--() { --i; return *this; }</a>
<a name="ln547">        inline key_iterator operator--(int) { return key_iterator(i--); }</a>
<a name="ln548">        const_iterator base() const { return i; }</a>
<a name="ln549">    };</a>
<a name="ln550"> </a>
<a name="ln551">    typedef QKeyValueIterator&lt;const Key&amp;, const T&amp;, const_iterator&gt; const_key_value_iterator;</a>
<a name="ln552">    typedef QKeyValueIterator&lt;const Key&amp;, T&amp;, iterator&gt; key_value_iterator;</a>
<a name="ln553"> </a>
<a name="ln554">    // STL style</a>
<a name="ln555">    inline iterator begin() { detach(); return iterator(d-&gt;begin()); }</a>
<a name="ln556">    inline const_iterator begin() const { return const_iterator(d-&gt;begin()); }</a>
<a name="ln557">    inline const_iterator constBegin() const { return const_iterator(d-&gt;begin()); }</a>
<a name="ln558">    inline const_iterator cbegin() const { return const_iterator(d-&gt;begin()); }</a>
<a name="ln559">    inline iterator end() { detach(); return iterator(d-&gt;end()); }</a>
<a name="ln560">    inline const_iterator end() const { return const_iterator(d-&gt;end()); }</a>
<a name="ln561">    inline const_iterator constEnd() const { return const_iterator(d-&gt;end()); }</a>
<a name="ln562">    inline const_iterator cend() const { return const_iterator(d-&gt;end()); }</a>
<a name="ln563">    inline key_iterator keyBegin() const { return key_iterator(begin()); }</a>
<a name="ln564">    inline key_iterator keyEnd() const { return key_iterator(end()); }</a>
<a name="ln565">    inline key_value_iterator keyValueBegin() { return key_value_iterator(begin()); }</a>
<a name="ln566">    inline key_value_iterator keyValueEnd() { return key_value_iterator(end()); }</a>
<a name="ln567">    inline const_key_value_iterator keyValueBegin() const { return const_key_value_iterator(begin()); }</a>
<a name="ln568">    inline const_key_value_iterator constKeyValueBegin() const { return const_key_value_iterator(begin()); }</a>
<a name="ln569">    inline const_key_value_iterator keyValueEnd() const { return const_key_value_iterator(end()); }</a>
<a name="ln570">    inline const_key_value_iterator constKeyValueEnd() const { return const_key_value_iterator(end()); }</a>
<a name="ln571">    iterator erase(iterator it);</a>
<a name="ln572"> </a>
<a name="ln573">    // more Qt</a>
<a name="ln574">    typedef iterator Iterator;</a>
<a name="ln575">    typedef const_iterator ConstIterator;</a>
<a name="ln576">    inline int count() const { return d-&gt;size; }</a>
<a name="ln577">    iterator find(const Key &amp;key);</a>
<a name="ln578">    const_iterator find(const Key &amp;key) const;</a>
<a name="ln579">    const_iterator constFind(const Key &amp;key) const;</a>
<a name="ln580">    iterator lowerBound(const Key &amp;key);</a>
<a name="ln581">    const_iterator lowerBound(const Key &amp;key) const;</a>
<a name="ln582">    iterator upperBound(const Key &amp;key);</a>
<a name="ln583">    const_iterator upperBound(const Key &amp;key) const;</a>
<a name="ln584">    iterator insert(const Key &amp;key, const T &amp;value);</a>
<a name="ln585">    iterator insert(const_iterator pos, const Key &amp;key, const T &amp;value);</a>
<a name="ln586">    iterator insertMulti(const Key &amp;key, const T &amp;value);</a>
<a name="ln587">    iterator insertMulti(const_iterator pos, const Key &amp;akey, const T &amp;avalue);</a>
<a name="ln588">    QMap&lt;Key, T&gt; &amp;unite(const QMap&lt;Key, T&gt; &amp;other);</a>
<a name="ln589"> </a>
<a name="ln590">    // STL compatibility</a>
<a name="ln591">    typedef Key key_type;</a>
<a name="ln592">    typedef T mapped_type;</a>
<a name="ln593">    typedef qptrdiff difference_type;</a>
<a name="ln594">    typedef int size_type;</a>
<a name="ln595">    inline bool empty() const { return isEmpty(); }</a>
<a name="ln596">    QPair&lt;iterator, iterator&gt; equal_range(const Key &amp;akey);</a>
<a name="ln597">    QPair&lt;const_iterator, const_iterator&gt; equal_range(const Key &amp;akey) const;</a>
<a name="ln598"> </a>
<a name="ln599">#ifdef Q_MAP_DEBUG</a>
<a name="ln600">    void dump() const;</a>
<a name="ln601">#endif</a>
<a name="ln602"> </a>
<a name="ln603">private:</a>
<a name="ln604">    void detach_helper();</a>
<a name="ln605">    bool isValidIterator(const const_iterator &amp;ci) const</a>
<a name="ln606">    {</a>
<a name="ln607">#if defined(QT_DEBUG) &amp;&amp; !defined(Q_MAP_NO_ITERATOR_DEBUG)</a>
<a name="ln608">        const QMapNodeBase *n = ci.i;</a>
<a name="ln609">        while (n-&gt;parent())</a>
<a name="ln610">            n = n-&gt;parent();</a>
<a name="ln611">        return n-&gt;left == d-&gt;root();</a>
<a name="ln612">#else</a>
<a name="ln613">        Q_UNUSED(ci);</a>
<a name="ln614">        return true;</a>
<a name="ln615">#endif</a>
<a name="ln616">    }</a>
<a name="ln617">};</a>
<a name="ln618"> </a>
<a name="ln619">template &lt;class Key, class T&gt;</a>
<a name="ln620">inline QMap&lt;Key, T&gt;::QMap(const QMap&lt;Key, T&gt; &amp;other)</a>
<a name="ln621">{</a>
<a name="ln622">    if (other.d-&gt;ref.ref()) {</a>
<a name="ln623">        d = other.d;</a>
<a name="ln624">    } else {</a>
<a name="ln625">        d = QMapData&lt;Key, T&gt;::create();</a>
<a name="ln626">        if (other.d-&gt;header.left) {</a>
<a name="ln627">            d-&gt;header.left = static_cast&lt;Node *&gt;(other.d-&gt;header.left)-&gt;copy(d);</a>
<a name="ln628">            d-&gt;header.left-&gt;setParent(&amp;d-&gt;header);</a>
<a name="ln629">            d-&gt;recalcMostLeftNode();</a>
<a name="ln630">        }</a>
<a name="ln631">    }</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">template &lt;class Key, class T&gt;</a>
<a name="ln635">Q_INLINE_TEMPLATE QMap&lt;Key, T&gt; &amp;QMap&lt;Key, T&gt;::operator=(const QMap&lt;Key, T&gt; &amp;other)</a>
<a name="ln636">{</a>
<a name="ln637">    if (d != other.d) {</a>
<a name="ln638">        QMap&lt;Key, T&gt; tmp(other);</a>
<a name="ln639">        tmp.swap(*this);</a>
<a name="ln640">    }</a>
<a name="ln641">    return *this;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">template &lt;class Key, class T&gt;</a>
<a name="ln645">Q_INLINE_TEMPLATE void QMap&lt;Key, T&gt;::clear()</a>
<a name="ln646">{</a>
<a name="ln647">    *this = QMap&lt;Key, T&gt;();</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">QT_WARNING_PUSH</a>
<a name="ln651">QT_WARNING_DISABLE_CLANG(&quot;-Wreturn-stack-address&quot;)</a>
<a name="ln652"> </a>
<a name="ln653">template &lt;class Key, class T&gt;</a>
<a name="ln654">Q_INLINE_TEMPLATE const T QMap&lt;Key, T&gt;::value(const Key &amp;akey, const T &amp;adefaultValue) const</a>
<a name="ln655">{</a>
<a name="ln656">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln657">    return n ? n-&gt;value : adefaultValue;</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">QT_WARNING_POP</a>
<a name="ln661"> </a>
<a name="ln662">template &lt;class Key, class T&gt;</a>
<a name="ln663">Q_INLINE_TEMPLATE const T QMap&lt;Key, T&gt;::operator[](const Key &amp;akey) const</a>
<a name="ln664">{</a>
<a name="ln665">    return value(akey);</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">template &lt;class Key, class T&gt;</a>
<a name="ln669">Q_INLINE_TEMPLATE T &amp;QMap&lt;Key, T&gt;::operator[](const Key &amp;akey)</a>
<a name="ln670">{</a>
<a name="ln671">    detach();</a>
<a name="ln672">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln673">    if (!n)</a>
<a name="ln674">        return *insert(akey, T());</a>
<a name="ln675">    return n-&gt;value;</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">template &lt;class Key, class T&gt;</a>
<a name="ln679">Q_INLINE_TEMPLATE int QMap&lt;Key, T&gt;::count(const Key &amp;akey) const</a>
<a name="ln680">{</a>
<a name="ln681">    Node *firstNode;</a>
<a name="ln682">    Node *lastNode;</a>
<a name="ln683">    d-&gt;nodeRange(akey, &amp;firstNode, &amp;lastNode);</a>
<a name="ln684"> </a>
<a name="ln685">    const_iterator ci_first(firstNode);</a>
<a name="ln686">    const const_iterator ci_last(lastNode);</a>
<a name="ln687">    int cnt = 0;</a>
<a name="ln688">    while (ci_first != ci_last) {</a>
<a name="ln689">        ++cnt;</a>
<a name="ln690">        ++ci_first;</a>
<a name="ln691">    }</a>
<a name="ln692">    return cnt;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">template &lt;class Key, class T&gt;</a>
<a name="ln696">Q_INLINE_TEMPLATE bool QMap&lt;Key, T&gt;::contains(const Key &amp;akey) const</a>
<a name="ln697">{</a>
<a name="ln698">    return d-&gt;findNode(akey) != nullptr;</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">template &lt;class Key, class T&gt;</a>
<a name="ln702">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insert(const Key &amp;akey, const T &amp;avalue)</a>
<a name="ln703">{</a>
<a name="ln704">    detach();</a>
<a name="ln705">    Node *n = d-&gt;root();</a>
<a name="ln706">    Node *y = d-&gt;end();</a>
<a name="ln707">    Node *lastNode = nullptr;</a>
<a name="ln708">    bool  left = true;</a>
<a name="ln709">    while (n) {</a>
<a name="ln710">        y = n;</a>
<a name="ln711">        if (!qMapLessThanKey(n-&gt;key, akey)) {</a>
<a name="ln712">            lastNode = n;</a>
<a name="ln713">            left = true;</a>
<a name="ln714">            n = n-&gt;leftNode();</a>
<a name="ln715">        } else {</a>
<a name="ln716">            left = false;</a>
<a name="ln717">            n = n-&gt;rightNode();</a>
<a name="ln718">        }</a>
<a name="ln719">    }</a>
<a name="ln720">    if (lastNode &amp;&amp; !qMapLessThanKey(akey, lastNode-&gt;key)) {</a>
<a name="ln721">        lastNode-&gt;value = avalue;</a>
<a name="ln722">        return iterator(lastNode);</a>
<a name="ln723">    }</a>
<a name="ln724">    Node *z = d-&gt;createNode(akey, avalue, y, left);</a>
<a name="ln725">    return iterator(z);</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">template &lt;class Key, class T&gt;</a>
<a name="ln729">typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insert(const_iterator pos, const Key &amp;akey, const T &amp;avalue)</a>
<a name="ln730">{</a>
<a name="ln731">    if (d-&gt;ref.isShared())</a>
<a name="ln732">        return this-&gt;insert(akey, avalue);</a>
<a name="ln733"> </a>
<a name="ln734">    Q_ASSERT_X(isValidIterator(pos), &quot;QMap::insert&quot;, &quot;The specified const_iterator argument 'it' is invalid&quot;);</a>
<a name="ln735"> </a>
<a name="ln736">    if (pos == constEnd()) {</a>
<a name="ln737">        // Hint is that the Node is larger than (or equal to) the largest value.</a>
<a name="ln738">        Node *n = static_cast&lt;Node *&gt;(pos.i-&gt;left);</a>
<a name="ln739">        if (n) {</a>
<a name="ln740">            while (n-&gt;right)</a>
<a name="ln741">                n = static_cast&lt;Node *&gt;(n-&gt;right);</a>
<a name="ln742"> </a>
<a name="ln743">            if (!qMapLessThanKey(n-&gt;key, akey))</a>
<a name="ln744">                return this-&gt;insert(akey, avalue); // ignore hint</a>
<a name="ln745">            // This can be optimized by checking equal too.</a>
<a name="ln746">            // we can overwrite if previous node key is strictly smaller</a>
<a name="ln747">            // (or there is no previous node)</a>
<a name="ln748"> </a>
<a name="ln749">            Node *z = d-&gt;createNode(akey, avalue, n, false); // insert right most</a>
<a name="ln750">            return iterator(z);</a>
<a name="ln751">        }</a>
<a name="ln752">        return this-&gt;insert(akey, avalue);</a>
<a name="ln753">    } else {</a>
<a name="ln754">        // Hint indicates that the node should be less (or equal to) the hint given</a>
<a name="ln755">        // but larger than the previous value.</a>
<a name="ln756">        Node *next = const_cast&lt;Node*&gt;(pos.i);</a>
<a name="ln757">        if (qMapLessThanKey(next-&gt;key, akey))</a>
<a name="ln758">            return this-&gt;insert(akey, avalue); // ignore hint</a>
<a name="ln759"> </a>
<a name="ln760">        if (pos == constBegin()) {</a>
<a name="ln761">            // There is no previous value</a>
<a name="ln762">            // Maybe overwrite left most value</a>
<a name="ln763">            if (!qMapLessThanKey(akey, next-&gt;key)) {</a>
<a name="ln764">                next-&gt;value = avalue; // overwrite current iterator</a>
<a name="ln765">                return iterator(next);</a>
<a name="ln766">            }</a>
<a name="ln767">            // insert left most.</a>
<a name="ln768">            Node *z = d-&gt;createNode(akey, avalue, begin().i, true);</a>
<a name="ln769">            return iterator(z);</a>
<a name="ln770">        } else {</a>
<a name="ln771">            Node *prev = const_cast&lt;Node*&gt;(pos.i-&gt;previousNode());</a>
<a name="ln772">            if (!qMapLessThanKey(prev-&gt;key, akey)) {</a>
<a name="ln773">                return this-&gt;insert(akey, avalue); // ignore hint</a>
<a name="ln774">            }</a>
<a name="ln775">            // Hint is ok</a>
<a name="ln776">            if (!qMapLessThanKey(akey, next-&gt;key)) {</a>
<a name="ln777">                next-&gt;value = avalue; // overwrite current iterator</a>
<a name="ln778">                return iterator(next);</a>
<a name="ln779">            }</a>
<a name="ln780"> </a>
<a name="ln781">            // we need to insert (not overwrite)</a>
<a name="ln782">            if (prev-&gt;right == nullptr) {</a>
<a name="ln783">                Node *z = d-&gt;createNode(akey, avalue, prev, false);</a>
<a name="ln784">                return iterator(z);</a>
<a name="ln785">            }</a>
<a name="ln786">            if (next-&gt;left == nullptr) {</a>
<a name="ln787">                Node *z = d-&gt;createNode(akey, avalue, next, true);</a>
<a name="ln788">                return iterator(z);</a>
<a name="ln789">            }</a>
<a name="ln790">            Q_ASSERT(false); // We should have prev-&gt;right == nullptr or next-&gt;left == nullptr.</a>
<a name="ln791">            return this-&gt;insert(akey, avalue);</a>
<a name="ln792">        }</a>
<a name="ln793">    }</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">template &lt;class Key, class T&gt;</a>
<a name="ln797">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insertMulti(const Key &amp;akey,</a>
<a name="ln798">                                                                            const T &amp;avalue)</a>
<a name="ln799">{</a>
<a name="ln800">    detach();</a>
<a name="ln801">    Node* y = d-&gt;end();</a>
<a name="ln802">    Node* x = static_cast&lt;Node *&gt;(d-&gt;root());</a>
<a name="ln803">    bool left = true;</a>
<a name="ln804">    while (x != nullptr) {</a>
<a name="ln805">        left = !qMapLessThanKey(x-&gt;key, akey);</a>
<a name="ln806">        y = x;</a>
<a name="ln807">        x = left ? x-&gt;leftNode() : x-&gt;rightNode();</a>
<a name="ln808">    }</a>
<a name="ln809">    Node *z = d-&gt;createNode(akey, avalue, y, left);</a>
<a name="ln810">    return iterator(z);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">template &lt;class Key, class T&gt;</a>
<a name="ln814">typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insertMulti(const_iterator pos, const Key &amp;akey, const T &amp;avalue)</a>
<a name="ln815">{</a>
<a name="ln816">    if (d-&gt;ref.isShared())</a>
<a name="ln817">        return this-&gt;insertMulti(akey, avalue);</a>
<a name="ln818"> </a>
<a name="ln819">    Q_ASSERT_X(isValidIterator(pos), &quot;QMap::insertMulti&quot;, &quot;The specified const_iterator argument 'pos' is invalid&quot;);</a>
<a name="ln820"> </a>
<a name="ln821">    if (pos == constEnd()) {</a>
<a name="ln822">        // Hint is that the Node is larger than (or equal to) the largest value.</a>
<a name="ln823">        Node *n = static_cast&lt;Node *&gt;(pos.i-&gt;left);</a>
<a name="ln824">        if (n) {</a>
<a name="ln825">            while (n-&gt;right)</a>
<a name="ln826">                n = static_cast&lt;Node *&gt;(n-&gt;right);</a>
<a name="ln827"> </a>
<a name="ln828">            if (!qMapLessThanKey(n-&gt;key, akey))</a>
<a name="ln829">                return this-&gt;insertMulti(akey, avalue); // ignore hint</a>
<a name="ln830">            Node *z = d-&gt;createNode(akey, avalue, n, false); // insert right most</a>
<a name="ln831">            return iterator(z);</a>
<a name="ln832">        }</a>
<a name="ln833">        return this-&gt;insertMulti(akey, avalue);</a>
<a name="ln834">    } else {</a>
<a name="ln835">        // Hint indicates that the node should be less (or equal to) the hint given</a>
<a name="ln836">        // but larger than the previous value.</a>
<a name="ln837">        Node *next = const_cast&lt;Node*&gt;(pos.i);</a>
<a name="ln838">        if (qMapLessThanKey(next-&gt;key, akey))</a>
<a name="ln839">            return this-&gt;insertMulti(akey, avalue); // ignore hint</a>
<a name="ln840"> </a>
<a name="ln841">        if (pos == constBegin()) {</a>
<a name="ln842">            // There is no previous value (insert left most)</a>
<a name="ln843">            Node *z = d-&gt;createNode(akey, avalue, begin().i, true);</a>
<a name="ln844">            return iterator(z);</a>
<a name="ln845">        } else {</a>
<a name="ln846">            Node *prev = const_cast&lt;Node*&gt;(pos.i-&gt;previousNode());</a>
<a name="ln847">            if (!qMapLessThanKey(prev-&gt;key, akey))</a>
<a name="ln848">                return this-&gt;insertMulti(akey, avalue); // ignore hint</a>
<a name="ln849"> </a>
<a name="ln850">            // Hint is ok - do insert</a>
<a name="ln851">            if (prev-&gt;right == nullptr) {</a>
<a name="ln852">                Node *z = d-&gt;createNode(akey, avalue, prev, false);</a>
<a name="ln853">                return iterator(z);</a>
<a name="ln854">            }</a>
<a name="ln855">            if (next-&gt;left == nullptr) {</a>
<a name="ln856">                Node *z = d-&gt;createNode(akey, avalue, next, true);</a>
<a name="ln857">                return iterator(z);</a>
<a name="ln858">            }</a>
<a name="ln859">            Q_ASSERT(false); // We should have prev-&gt;right == nullptr or next-&gt;left == nullptr.</a>
<a name="ln860">            return this-&gt;insertMulti(akey, avalue);</a>
<a name="ln861">        }</a>
<a name="ln862">    }</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865"> </a>
<a name="ln866">template &lt;class Key, class T&gt;</a>
<a name="ln867">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator QMap&lt;Key, T&gt;::constFind(const Key &amp;akey) const</a>
<a name="ln868">{</a>
<a name="ln869">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln870">    return const_iterator(n ? n : d-&gt;end());</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">template &lt;class Key, class T&gt;</a>
<a name="ln874">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator QMap&lt;Key, T&gt;::find(const Key &amp;akey) const</a>
<a name="ln875">{</a>
<a name="ln876">    return constFind(akey);</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">template &lt;class Key, class T&gt;</a>
<a name="ln880">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::find(const Key &amp;akey)</a>
<a name="ln881">{</a>
<a name="ln882">    detach();</a>
<a name="ln883">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln884">    return iterator(n ? n : d-&gt;end());</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">template &lt;class Key, class T&gt;</a>
<a name="ln888">Q_INLINE_TEMPLATE QMap&lt;Key, T&gt; &amp;QMap&lt;Key, T&gt;::unite(const QMap&lt;Key, T&gt; &amp;other)</a>
<a name="ln889">{</a>
<a name="ln890">    QMap&lt;Key, T&gt; copy(other);</a>
<a name="ln891">    const_iterator it = copy.constEnd();</a>
<a name="ln892">    const const_iterator b = copy.constBegin();</a>
<a name="ln893">    while (it != b) {</a>
<a name="ln894">        --it;</a>
<a name="ln895">        insertMulti(it.key(), it.value());</a>
<a name="ln896">    }</a>
<a name="ln897">    return *this;</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">template &lt;class Key, class T&gt;</a>
<a name="ln901">QPair&lt;typename QMap&lt;Key, T&gt;::iterator, typename QMap&lt;Key, T&gt;::iterator&gt; QMap&lt;Key, T&gt;::equal_range(const Key &amp;akey)</a>
<a name="ln902">{</a>
<a name="ln903">    detach();</a>
<a name="ln904">    Node *firstNode, *lastNode;</a>
<a name="ln905">    d-&gt;nodeRange(akey, &amp;firstNode, &amp;lastNode);</a>
<a name="ln906">    return QPair&lt;iterator, iterator&gt;(iterator(firstNode), iterator(lastNode));</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">template &lt;class Key, class T&gt;</a>
<a name="ln910">QPair&lt;typename QMap&lt;Key, T&gt;::const_iterator, typename QMap&lt;Key, T&gt;::const_iterator&gt;</a>
<a name="ln911">QMap&lt;Key, T&gt;::equal_range(const Key &amp;akey) const</a>
<a name="ln912">{</a>
<a name="ln913">    Node *firstNode, *lastNode;</a>
<a name="ln914">    d-&gt;nodeRange(akey, &amp;firstNode, &amp;lastNode);</a>
<a name="ln915">    return qMakePair(const_iterator(firstNode), const_iterator(lastNode));</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">#ifdef Q_MAP_DEBUG</a>
<a name="ln919">template &lt;class Key, class T&gt;</a>
<a name="ln920">void QMap&lt;Key, T&gt;::dump() const</a>
<a name="ln921">{</a>
<a name="ln922">    const_iterator it = begin();</a>
<a name="ln923">    qDebug(&quot;map dump:&quot;);</a>
<a name="ln924">    while (it != end()) {</a>
<a name="ln925">        const QMapNodeBase *n = it.i;</a>
<a name="ln926">        int depth = 0;</a>
<a name="ln927">        while (n &amp;&amp; n != d-&gt;root()) {</a>
<a name="ln928">            ++depth;</a>
<a name="ln929">            n = n-&gt;parent();</a>
<a name="ln930">        }</a>
<a name="ln931">        QByteArray space(4*depth, ' ');</a>
<a name="ln932">        qDebug() &lt;&lt; space &lt;&lt; (it.i-&gt;color() == Node::Red ? &quot;Red  &quot; : &quot;Black&quot;) &lt;&lt; it.i &lt;&lt; it.i-&gt;left &lt;&lt; it.i-&gt;right</a>
<a name="ln933">                 &lt;&lt; it.key() &lt;&lt; it.value();</a>
<a name="ln934">        ++it;</a>
<a name="ln935">    }</a>
<a name="ln936">    qDebug(&quot;---------&quot;);</a>
<a name="ln937">}</a>
<a name="ln938">#endif</a>
<a name="ln939"> </a>
<a name="ln940">template &lt;class Key, class T&gt;</a>
<a name="ln941">Q_OUTOFLINE_TEMPLATE int QMap&lt;Key, T&gt;::remove(const Key &amp;akey)</a>
<a name="ln942">{</a>
<a name="ln943">    detach();</a>
<a name="ln944">    int n = 0;</a>
<a name="ln945">    while (Node *node = d-&gt;findNode(akey)) {</a>
<a name="ln946">        d-&gt;deleteNode(node);</a>
<a name="ln947">        ++n;</a>
<a name="ln948">    }</a>
<a name="ln949">    return n;</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">template &lt;class Key, class T&gt;</a>
<a name="ln953">Q_OUTOFLINE_TEMPLATE T QMap&lt;Key, T&gt;::take(const Key &amp;akey)</a>
<a name="ln954">{</a>
<a name="ln955">    detach();</a>
<a name="ln956"> </a>
<a name="ln957">    Node *node = d-&gt;findNode(akey);</a>
<a name="ln958">    if (node) {</a>
<a name="ln959">        T t = std::move(node-&gt;value);</a>
<a name="ln960">        d-&gt;deleteNode(node);</a>
<a name="ln961">        return t;</a>
<a name="ln962">    }</a>
<a name="ln963">    return T();</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">template &lt;class Key, class T&gt;</a>
<a name="ln967">Q_OUTOFLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::erase(iterator it)</a>
<a name="ln968">{</a>
<a name="ln969">    if (it == iterator(d-&gt;end()))</a>
<a name="ln970">        return it;</a>
<a name="ln971"> </a>
<a name="ln972">    Q_ASSERT_X(isValidIterator(const_iterator(it)), &quot;QMap::erase&quot;, &quot;The specified iterator argument 'it' is invalid&quot;);</a>
<a name="ln973"> </a>
<a name="ln974">    if (d-&gt;ref.isShared()) {</a>
<a name="ln975">        const_iterator oldBegin = constBegin();</a>
<a name="ln976">        const_iterator old = const_iterator(it);</a>
<a name="ln977">        int backStepsWithSameKey = 0;</a>
<a name="ln978"> </a>
<a name="ln979">        while (old != oldBegin) {</a>
<a name="ln980">            --old;</a>
<a name="ln981">            if (qMapLessThanKey(old.key(), it.key()))</a>
<a name="ln982">                break;</a>
<a name="ln983">            ++backStepsWithSameKey;</a>
<a name="ln984">        }</a>
<a name="ln985"> </a>
<a name="ln986">        it = find(old.key()); // ensures detach</a>
<a name="ln987">        Q_ASSERT_X(it != iterator(d-&gt;end()), &quot;QMap::erase&quot;, &quot;Unable to locate same key in erase after detach.&quot;);</a>
<a name="ln988"> </a>
<a name="ln989">        while (backStepsWithSameKey &gt; 0) {</a>
<a name="ln990">            ++it;</a>
<a name="ln991">            --backStepsWithSameKey;</a>
<a name="ln992">        }</a>
<a name="ln993">    }</a>
<a name="ln994"> </a>
<a name="ln995">    Node *n = it.i;</a>
<a name="ln996">    ++it;</a>
<a name="ln997">    d-&gt;deleteNode(n);</a>
<a name="ln998">    return it;</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">template &lt;class Key, class T&gt;</a>
<a name="ln1002">Q_OUTOFLINE_TEMPLATE void QMap&lt;Key, T&gt;::detach_helper()</a>
<a name="ln1003">{</a>
<a name="ln1004">    QMapData&lt;Key, T&gt; *x = QMapData&lt;Key, T&gt;::create();</a>
<a name="ln1005">    if (d-&gt;header.left) {</a>
<a name="ln1006">        x-&gt;header.left = static_cast&lt;Node *&gt;(d-&gt;header.left)-&gt;copy(x);</a>
<a name="ln1007">        x-&gt;header.left-&gt;setParent(&amp;x-&gt;header);</a>
<a name="ln1008">    }</a>
<a name="ln1009">    if (!d-&gt;ref.deref())</a>
<a name="ln1010">        d-&gt;destroy();</a>
<a name="ln1011">    d = x;</a>
<a name="ln1012">    d-&gt;recalcMostLeftNode();</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">template &lt;class Key, class T&gt;</a>
<a name="ln1016">Q_OUTOFLINE_TEMPLATE QList&lt;Key&gt; QMap&lt;Key, T&gt;::uniqueKeys() const</a>
<a name="ln1017">{</a>
<a name="ln1018">    QList&lt;Key&gt; res;</a>
<a name="ln1019">    res.reserve(size()); // May be too much, but assume short lifetime</a>
<a name="ln1020">    const_iterator i = begin();</a>
<a name="ln1021">    if (i != end()) {</a>
<a name="ln1022">        for (;;) {</a>
<a name="ln1023">            const Key &amp;aKey = i.key();</a>
<a name="ln1024">            res.append(aKey);</a>
<a name="ln1025">            do {</a>
<a name="ln1026">                if (++i == end())</a>
<a name="ln1027">                    goto break_out_of_outer_loop;</a>
<a name="ln1028">            } while (!qMapLessThanKey(aKey, i.key()));   // loop while (key == i.key())</a>
<a name="ln1029">        }</a>
<a name="ln1030">    }</a>
<a name="ln1031">break_out_of_outer_loop:</a>
<a name="ln1032">    return res;</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035">template &lt;class Key, class T&gt;</a>
<a name="ln1036">Q_OUTOFLINE_TEMPLATE QList&lt;Key&gt; QMap&lt;Key, T&gt;::keys() const</a>
<a name="ln1037">{</a>
<a name="ln1038">    QList&lt;Key&gt; res;</a>
<a name="ln1039">    res.reserve(size());</a>
<a name="ln1040">    const_iterator i = begin();</a>
<a name="ln1041">    while (i != end()) {</a>
<a name="ln1042">        res.append(i.key());</a>
<a name="ln1043">        ++i;</a>
<a name="ln1044">    }</a>
<a name="ln1045">    return res;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">template &lt;class Key, class T&gt;</a>
<a name="ln1049">Q_OUTOFLINE_TEMPLATE QList&lt;Key&gt; QMap&lt;Key, T&gt;::keys(const T &amp;avalue) const</a>
<a name="ln1050">{</a>
<a name="ln1051">    QList&lt;Key&gt; res;</a>
<a name="ln1052">    const_iterator i = begin();</a>
<a name="ln1053">    while (i != end()) {</a>
<a name="ln1054">        if (i.value() == avalue)</a>
<a name="ln1055">            res.append(i.key());</a>
<a name="ln1056">        ++i;</a>
<a name="ln1057">    }</a>
<a name="ln1058">    return res;</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">template &lt;class Key, class T&gt;</a>
<a name="ln1062">Q_OUTOFLINE_TEMPLATE const Key QMap&lt;Key, T&gt;::key(const T &amp;avalue, const Key &amp;defaultKey) const</a>
<a name="ln1063">{</a>
<a name="ln1064">    const_iterator i = begin();</a>
<a name="ln1065">    while (i != end()) {</a>
<a name="ln1066">        if (i.value() == avalue)</a>
<a name="ln1067">            return i.key();</a>
<a name="ln1068">        ++i;</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">    return defaultKey;</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">template &lt;class Key, class T&gt;</a>
<a name="ln1075">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; QMap&lt;Key, T&gt;::values() const</a>
<a name="ln1076">{</a>
<a name="ln1077">    QList&lt;T&gt; res;</a>
<a name="ln1078">    res.reserve(size());</a>
<a name="ln1079">    const_iterator i = begin();</a>
<a name="ln1080">    while (i != end()) {</a>
<a name="ln1081">        res.append(i.value());</a>
<a name="ln1082">        ++i;</a>
<a name="ln1083">    }</a>
<a name="ln1084">    return res;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">template &lt;class Key, class T&gt;</a>
<a name="ln1088">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; QMap&lt;Key, T&gt;::values(const Key &amp;akey) const</a>
<a name="ln1089">{</a>
<a name="ln1090">    QList&lt;T&gt; res;</a>
<a name="ln1091">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln1092">    if (n) {</a>
<a name="ln1093">        const_iterator it(n);</a>
<a name="ln1094">        do {</a>
<a name="ln1095">            res.append(*it);</a>
<a name="ln1096">            ++it;</a>
<a name="ln1097">        } while (it != constEnd() &amp;&amp; !qMapLessThanKey&lt;Key&gt;(akey, it.key()));</a>
<a name="ln1098">    }</a>
<a name="ln1099">    return res;</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">template &lt;class Key, class T&gt;</a>
<a name="ln1103">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator QMap&lt;Key, T&gt;::lowerBound(const Key &amp;akey) const</a>
<a name="ln1104">{</a>
<a name="ln1105">    Node *lb = d-&gt;root() ? d-&gt;root()-&gt;lowerBound(akey) : nullptr;</a>
<a name="ln1106">    if (!lb)</a>
<a name="ln1107">        lb = d-&gt;end();</a>
<a name="ln1108">    return const_iterator(lb);</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">template &lt;class Key, class T&gt;</a>
<a name="ln1112">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::lowerBound(const Key &amp;akey)</a>
<a name="ln1113">{</a>
<a name="ln1114">    detach();</a>
<a name="ln1115">    Node *lb = d-&gt;root() ? d-&gt;root()-&gt;lowerBound(akey) : nullptr;</a>
<a name="ln1116">    if (!lb)</a>
<a name="ln1117">        lb = d-&gt;end();</a>
<a name="ln1118">    return iterator(lb);</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">template &lt;class Key, class T&gt;</a>
<a name="ln1122">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator</a>
<a name="ln1123">QMap&lt;Key, T&gt;::upperBound(const Key &amp;akey) const</a>
<a name="ln1124">{</a>
<a name="ln1125">    Node *ub = d-&gt;root() ? d-&gt;root()-&gt;upperBound(akey) : nullptr;</a>
<a name="ln1126">    if (!ub)</a>
<a name="ln1127">        ub = d-&gt;end();</a>
<a name="ln1128">    return const_iterator(ub);</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">template &lt;class Key, class T&gt;</a>
<a name="ln1132">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::upperBound(const Key &amp;akey)</a>
<a name="ln1133">{</a>
<a name="ln1134">    detach();</a>
<a name="ln1135">    Node *ub = d-&gt;root() ? d-&gt;root()-&gt;upperBound(akey) : nullptr;</a>
<a name="ln1136">    if (!ub)</a>
<a name="ln1137">        ub = d-&gt;end();</a>
<a name="ln1138">    return iterator(ub);</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">template &lt;class Key, class T&gt;</a>
<a name="ln1142">Q_OUTOFLINE_TEMPLATE bool QMap&lt;Key, T&gt;::operator==(const QMap&lt;Key, T&gt; &amp;other) const</a>
<a name="ln1143">{</a>
<a name="ln1144">    if (size() != other.size())</a>
<a name="ln1145">        return false;</a>
<a name="ln1146">    if (d == other.d)</a>
<a name="ln1147">        return true;</a>
<a name="ln1148"> </a>
<a name="ln1149">    const_iterator it1 = begin();</a>
<a name="ln1150">    const_iterator it2 = other.begin();</a>
<a name="ln1151"> </a>
<a name="ln1152">    while (it1 != end()) {</a>
<a name="ln1153">        if (!(it1.value() == it2.value()) || qMapLessThanKey(it1.key(), it2.key()) || qMapLessThanKey(it2.key(), it1.key()))</a>
<a name="ln1154">            return false;</a>
<a name="ln1155">        ++it2;</a>
<a name="ln1156">        ++it1;</a>
<a name="ln1157">    }</a>
<a name="ln1158">    return true;</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161">template &lt;class Key, class T&gt;</a>
<a name="ln1162">Q_OUTOFLINE_TEMPLATE QMap&lt;Key, T&gt;::QMap(const std::map&lt;Key, T&gt; &amp;other)</a>
<a name="ln1163">{</a>
<a name="ln1164">    d = QMapData&lt;Key, T&gt;::create();</a>
<a name="ln1165">    typename std::map&lt;Key,T&gt;::const_iterator it = other.end();</a>
<a name="ln1166">    while (it != other.begin()) {</a>
<a name="ln1167">        --it;</a>
<a name="ln1168">        d-&gt;createNode((*it).first, (*it).second, d-&gt;begin(), true); // insert on most left node.</a>
<a name="ln1169">    }</a>
<a name="ln1170">}</a>
<a name="ln1171"> </a>
<a name="ln1172">template &lt;class Key, class T&gt;</a>
<a name="ln1173">Q_OUTOFLINE_TEMPLATE std::map&lt;Key, T&gt; QMap&lt;Key, T&gt;::toStdMap() const</a>
<a name="ln1174">{</a>
<a name="ln1175">    std::map&lt;Key, T&gt; map;</a>
<a name="ln1176">    const_iterator it = end();</a>
<a name="ln1177">    while (it != begin()) {</a>
<a name="ln1178">        --it;</a>
<a name="ln1179">        map.insert(map.begin(), std::pair&lt;Key, T&gt;(it.key(), it.value()));</a>
<a name="ln1180">    }</a>
<a name="ln1181">    return map;</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">template &lt;class Key, class T&gt;</a>
<a name="ln1185">class QMultiMap : public QMap&lt;Key, T&gt;</a>
<a name="ln1186">{</a>
<a name="ln1187">public:</a>
<a name="ln1188">    QMultiMap() Q_DECL_NOTHROW {}</a>
<a name="ln1189">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln1190">    inline QMultiMap(std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt; list)</a>
<a name="ln1191">    {</a>
<a name="ln1192">        for (typename std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt;::const_iterator it = list.begin(); it != list.end(); ++it)</a>
<a name="ln1193">            insert(it-&gt;first, it-&gt;second);</a>
<a name="ln1194">    }</a>
<a name="ln1195">#endif</a>
<a name="ln1196">    QMultiMap(const QMap&lt;Key, T&gt; &amp;other) : QMap&lt;Key, T&gt;(other) {}</a>
<a name="ln1197">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln1198">    QMultiMap(QMap&lt;Key, T&gt; &amp;&amp;other) Q_DECL_NOTHROW : QMap&lt;Key, T&gt;(std::move(other)) {}</a>
<a name="ln1199">#endif</a>
<a name="ln1200">    void swap(QMultiMap&lt;Key, T&gt; &amp;other) Q_DECL_NOTHROW { QMap&lt;Key, T&gt;::swap(other); }</a>
<a name="ln1201"> </a>
<a name="ln1202">    inline typename QMap&lt;Key, T&gt;::iterator replace(const Key &amp;key, const T &amp;value)</a>
<a name="ln1203">    { return QMap&lt;Key, T&gt;::insert(key, value); }</a>
<a name="ln1204">    inline typename QMap&lt;Key, T&gt;::iterator insert(const Key &amp;key, const T &amp;value)</a>
<a name="ln1205">    { return QMap&lt;Key, T&gt;::insertMulti(key, value); }</a>
<a name="ln1206">    inline typename QMap&lt;Key, T&gt;::iterator insert(typename QMap&lt;Key, T&gt;::const_iterator pos, const Key &amp;key, const T &amp;value)</a>
<a name="ln1207">    { return QMap&lt;Key, T&gt;::insertMulti(pos, key, value); }</a>
<a name="ln1208"> </a>
<a name="ln1209">    inline QMultiMap &amp;operator+=(const QMultiMap &amp;other)</a>
<a name="ln1210">    { this-&gt;unite(other); return *this; }</a>
<a name="ln1211">    inline QMultiMap operator+(const QMultiMap &amp;other) const</a>
<a name="ln1212">    { QMultiMap result = *this; result += other; return result; }</a>
<a name="ln1213"> </a>
<a name="ln1214">    using QMap&lt;Key, T&gt;::contains;</a>
<a name="ln1215">    using QMap&lt;Key, T&gt;::remove;</a>
<a name="ln1216">    using QMap&lt;Key, T&gt;::count;</a>
<a name="ln1217">    using QMap&lt;Key, T&gt;::find;</a>
<a name="ln1218">    using QMap&lt;Key, T&gt;::constFind;</a>
<a name="ln1219"> </a>
<a name="ln1220">    bool contains(const Key &amp;key, const T &amp;value) const;</a>
<a name="ln1221"> </a>
<a name="ln1222">    int remove(const Key &amp;key, const T &amp;value);</a>
<a name="ln1223"> </a>
<a name="ln1224">    int count(const Key &amp;key, const T &amp;value) const;</a>
<a name="ln1225"> </a>
<a name="ln1226">    typename QMap&lt;Key, T&gt;::iterator find(const Key &amp;key, const T &amp;value) {</a>
<a name="ln1227">        typename QMap&lt;Key, T&gt;::iterator i(find(key));</a>
<a name="ln1228">        typename QMap&lt;Key, T&gt;::iterator end(this-&gt;end());</a>
<a name="ln1229">        while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1230">            if (i.value() == value)</a>
<a name="ln1231">                return i;</a>
<a name="ln1232">            ++i;</a>
<a name="ln1233">        }</a>
<a name="ln1234">        return end;</a>
<a name="ln1235">    }</a>
<a name="ln1236">    typename QMap&lt;Key, T&gt;::const_iterator find(const Key &amp;key, const T &amp;value) const {</a>
<a name="ln1237">        typename QMap&lt;Key, T&gt;::const_iterator i(constFind(key));</a>
<a name="ln1238">        typename QMap&lt;Key, T&gt;::const_iterator end(QMap&lt;Key, T&gt;::constEnd());</a>
<a name="ln1239">        while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1240">            if (i.value() == value)</a>
<a name="ln1241">                return i;</a>
<a name="ln1242">            ++i;</a>
<a name="ln1243">        }</a>
<a name="ln1244">        return end;</a>
<a name="ln1245">    }</a>
<a name="ln1246">    typename QMap&lt;Key, T&gt;::const_iterator constFind(const Key &amp;key, const T &amp;value) const</a>
<a name="ln1247">        { return find(key, value); }</a>
<a name="ln1248">private:</a>
<a name="ln1249">    T &amp;operator[](const Key &amp;key);</a>
<a name="ln1250">    const T operator[](const Key &amp;key) const;</a>
<a name="ln1251">};</a>
<a name="ln1252"> </a>
<a name="ln1253">template &lt;class Key, class T&gt;</a>
<a name="ln1254">Q_INLINE_TEMPLATE bool QMultiMap&lt;Key, T&gt;::contains(const Key &amp;key, const T &amp;value) const</a>
<a name="ln1255">{</a>
<a name="ln1256">    return constFind(key, value) != QMap&lt;Key, T&gt;::constEnd();</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">template &lt;class Key, class T&gt;</a>
<a name="ln1260">Q_INLINE_TEMPLATE int QMultiMap&lt;Key, T&gt;::remove(const Key &amp;key, const T &amp;value)</a>
<a name="ln1261">{</a>
<a name="ln1262">    int n = 0;</a>
<a name="ln1263">    typename QMap&lt;Key, T&gt;::iterator i(find(key));</a>
<a name="ln1264">    typename QMap&lt;Key, T&gt;::iterator end(QMap&lt;Key, T&gt;::end());</a>
<a name="ln1265">    while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1266">        if (i.value() == value) {</a>
<a name="ln1267">            i = this-&gt;erase(i);</a>
<a name="ln1268">            ++n;</a>
<a name="ln1269">        } else {</a>
<a name="ln1270">            ++i;</a>
<a name="ln1271">        }</a>
<a name="ln1272">    }</a>
<a name="ln1273">    return n;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">template &lt;class Key, class T&gt;</a>
<a name="ln1277">Q_INLINE_TEMPLATE int QMultiMap&lt;Key, T&gt;::count(const Key &amp;key, const T &amp;value) const</a>
<a name="ln1278">{</a>
<a name="ln1279">    int n = 0;</a>
<a name="ln1280">    typename QMap&lt;Key, T&gt;::const_iterator i(constFind(key));</a>
<a name="ln1281">    typename QMap&lt;Key, T&gt;::const_iterator end(QMap&lt;Key, T&gt;::constEnd());</a>
<a name="ln1282">    while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1283">        if (i.value() == value)</a>
<a name="ln1284">            ++n;</a>
<a name="ln1285">        ++i;</a>
<a name="ln1286">    }</a>
<a name="ln1287">    return n;</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">Q_DECLARE_ASSOCIATIVE_ITERATOR(Map)</a>
<a name="ln1291">Q_DECLARE_MUTABLE_ASSOCIATIVE_ITERATOR(Map)</a>
<a name="ln1292"> </a>
<a name="ln1293">QT_END_NAMESPACE</a>
<a name="ln1294"> </a>
<a name="ln1295">#endif // QMAP_H</a>

</code></pre>
<div class="balloon" rel="214"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapNodeBase' to derived class 'QMapNode'.</p></div>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapNodeBase' to derived class 'QMapNode'.</p></div>
<div class="balloon" rel="328"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapDataBase' to derived class 'QMapData'.</p></div>
<div class="balloon" rel="331"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapDataBase' to derived class 'QMapData'.</p></div>
<div class="balloon" rel="346"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapDataBase' to derived class 'QMapData'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
